
\documentclass[oneside]{book}
\usepackage{xcolor}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage[framemethod=TikZ]{mdframed}
\newtheorem{example}{Example}
\mdfdefinestyle{MyFrame}{innerleftmargin=20pt}

\definecolor{warningbg}{rgb}{0.95,0.90,0.90}
\newenvironment{warning}%
  {\begin{mdframed}[style=MyFrame,backgroundcolor=warningbg]}%
  {\end{mdframed}}
\definecolor{explanationbg}{rgb}{0.90,0.95,0.95}
\newenvironment{explanation}%
  {\begin{mdframed}[style=MyFrame,backgroundcolor=explanationbg]}%
  {\end{mdframed}}

\usepackage{parskip}
\usepackage{minted}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{makeidx}
\usepackage[toc]{glossaries}
\makeindex
\usemintedstyle{friendly}
\setminted{bgcolor=bg,xleftmargin=20pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\autoref*{#1} \nameref*{#1}}}
\title{The Felix Language}
\author{John Skaller}
\makeglossaries

\newglossaryentry{coroutine}{name=coroutine, description={a programming unit 
which exchanges control with others on a neutral basis}}

\newglossaryentry{polymorphism}{name=polymorphism, description={a language
feature which allows a function to process arguments of
more than one type, and to behave differently depending
on the argument type}}

\newglossaryentry{pthread}{name=pthread, description={a programming unit 
which runs concurrently with others and which may be suspended and resumed
by the operating system at any time}}

\newglossaryentry{setwise lookup}{name=setwise lookup, description={
a method of lookup where a symbol may be used before or after it is
defined
}}

\begin{document}
\maketitle
\tableofcontents
\chapter{Introduction}
The Felix programming language is based on algebra, in particular
\href{ https://en.wikipedia.org/wiki/Category_theory}{category theory.}

The construction begins with a category \(\mathcal{M}\) which is a cartesian closed category
of monomorphic types, including a set of primitive types \(p_i\), primitive functions \(f_i\)
and the usual type combinators for products, coproducts, function types, and recursion.

Our objective is to construct a category \(\mathcal{P}\) of polymorphic types. Initially,
the objects of this category will be functors  \(\mathcal{P}^n\rightarrow \mathcal{P}\).
Let \(F: \mathcal{M}^m \rightarrow M\) and \(G: \mathcal{M}^m \rightarrow M^n\) then application
of the composite can be given by 
$$F (G_1 (t_1, t_2, .. t_m),  G_2 (t_1, ... t_m) , ... G_n (t_1, .. t_m))$$
where G is split into component functors. in other words, compostion is just substitution, as is 
reduction of applications.

Let \(\mathcal{K}\) be the category with objects \(\mathcal{P}^i\) for finite natural
numbers $i$, and arrows all the functors between them, then let \(\mathcal{P}\) 
be the category with objects these functors, and arrows the natural transformnations
of \(\mathcal{K}\). In other words, the objects are polymorphic data types,
and the arrows polymorphic functions.



\clearpage
\printglossaries
\clearpage
\addcontentsline{toc}{chapter}{Index}
\printindex
\backmatter
\end{document}
