#include <cstdlib>
#include <stdio.h>

#include <string>

#include "flx_world.hpp"
#include "flx_ts_collector.hpp"
#include "flx_eh.hpp"

using namespace std;
using namespace flx::rtl;
using namespace flx::run;

#if FLX_HAVE_GNU_X86
register void *sp __asm__("esp");
#elif FLX_HAVE_GNU_X86_64
register void *sp __asm__("rsp");
#else
static void *sp = 0;
#endif

// non async drivers don't depend on faio<-demux<-winsock
// and so aren't linked with mswsock and ws2_32
#if FLX_WIN32 && FLX_SUPPORT_ASYNC
  #include "demux_iocp_demuxer.hpp"
  // needed to perform win socket io (calls WSAInit). Must happen
  // before iocp_demuxer is instantiated and (I assume) happen
  // only once.
  // JS: No, it can be called any number of times, provided
  // the destructor WSACleanup is called same number of times
  // Use of this RAII object ensures WSAinit/Cleanup calls balance.
  // RF: Still has to happen before any socket calls. Putting it in
  // the async object which is created on demand is already too late.
  // If that's a problem then any socket creation calls would have to
  // gratuitously make async calls.
  flx::demux::winsock_initer wsinit;
#endif

// Actually on Cygwin it might be cygflx_async_dynamic .. not sure
#if FLX_HAVE_MSVC
   #define FLX_ASYNC_DLL_NAME "flx_async_dynamic"
#else
   #define FLX_ASYNC_DLL_NAME "libflx_async_dynamic"
#endif

#ifdef FLX_STATIC_LINK
extern "C" void *flx_main;
extern void *static_create_thread_frame;
extern void *static_flx_start;
#endif

// these are part of the rtl, I don't think there's a driver namespace
namespace flx { namespace rtl {

// TODO: make this less weird (sets ptr_create_async_hooker)
void init_ptr_create_async_hooker(flx_config *c, bool debug_driver) {
#if !FLX_SUPPORT_ASYNC
  if(debug_driver)
    fprintf(stderr,"doflx: FLX_SUPPORT_ASYNC FALSE\n");
  c->ptr_create_async_hooker = 0;
#else
  c->ptr_create_async_hooker = create_async_hooker;
  if(debug_driver)
    fprintf(stderr,"doflx: FLX_SUPPORT_ASYNC TRUE, create_async_hooker = %p\n", create_async_hooker);
#ifndef FLX_STATIC_LINK
  // Try to dynamically load the felix asynchronous library

  if(debug_driver)
    fprintf(stderr,"doflx: dymamic_link: trying to load %s\n",FLX_ASYNC_DLL_NAME);

  LIBHANDLE async_lib = flx_load_module(FLX_ASYNC_DLL_NAME);

  // Error out if we couldn't load the library.
  if (async_lib == NULL) {
    fprintf(stderr,
      "doflx: Unable to find module '%s'\n",FLX_ASYNC_DLL_NAME);
    exit(1);
  }
  // debug only ..
  else {
    if (debug_driver)
      fprintf(stderr, "module '%s' loaded!\n",FLX_ASYNC_DLL_NAME);
  }

  // Get the hooker function
  c->ptr_create_async_hooker =
    (create_async_hooker_t*)DLSYM(async_lib, create_async_hooker);

  // Error out if we couldn't find the hooker function in the
  // library.
  if (c->ptr_create_async_hooker == NULL) {
    fprintf(stderr,
      "doflx: Unable to find symbol 'create_async_hooker' in module "
      "'%s'\n",FLX_ASYNC_DLL_NAME);
    exit(1);
  }
  // debug only
  else {
    if (debug_driver)
      fprintf(stderr, "found 'create_async_hooker'!\n");
  }
#endif
  if(debug_driver)
    fprintf(stderr,"doflx: static_link: flx_async_static SHOULD BE LINKED IN\n");
#endif
}

int get_flx_args_config(int argc, char **argv, flx_config *c) {
#ifndef FLX_STATIC_LINK
  c->static_link = false;
  if (argc<2)
  {
    printf("usage: flx_run [--debug] dll_filename options ..\n");
    printf("  environment variables (numbers can be decimals):\n");
    printf("  FLX_DEBUG               # enable debugging traces (default off)\n");
    printf("  FLX_DEBUG_ALLOCATIONS   # enable debugging allocator (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_COLLECTIONS   # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_REPORT_COLLECTIONS  # report collections (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_THREADS       # enable debugging collector (default FLX_DEBUG)\n");
    printf("  FLX_DEBUG_DRIVER        # enable debugging driver (default FLX_DEBUG)\n");
    printf("  FLX_FINALISE            # whether to cleanup on termination (default NO)\n");
    printf("  FLX_GC_FREQ=n           # how often to call garbage collector (default 1000)\n");
    printf("  FLX_MIN_MEM=n           # initial memory pool n Meg (default 10)\n");
    printf("  FLX_MAX_MEM=n           # maximum memory n Meg (default -1 = infinite)\n");
    printf("  FLX_FREE_FACTOR=n.m     # reset FLX_MIN_MEM to actual usage by n.m after gc (default 1.1) \n");
    printf("  FLX_ALLOW_COLLECTION_ANYWHERE # (default yes)\n");
    return 1;
  }
  c->filename = argv[1];
  c->flx_argv = argv+1;
  c->flx_argc = argc-1;
  c->debug = (argc > 1) && (strcmp(argv[1], "--debug")==0);
  if (c->debug)
  {
    if (argc < 3)
    {
      printf("usage: flx_run [--debug] dll_filename options ..\n");
      return 1;
    }
    c->filename = argv[2];
    --c->flx_argc;
    ++c->flx_argv;
  }
#else
  c->static_link = true;
  c->filename = argv[0];
  c->flx_argv = argv;
  c->flx_argc = argc;
  c->debug = false;

//  printf("Statically linked Felix program running\n");
#endif
  return 0;
}

::std::string modulenameoffilename(::std::string const &s)
{
  ::std::size_t i = s.find_last_of("\\/");
  ::std::size_t j = s.find_first_of(".",i+1);
  return s.substr (i+1,j-i-1);
}

flx_dynlink_t *link_library(flx_config *c) {
  flx_dynlink_t* library;
#ifdef FLX_STATIC_LINK
  library = new flx_dynlink_t(
      modulenameoffilename(c->filename),
      (thread_frame_creator_t)static_create_thread_frame,
      (start_t)static_flx_start,
      (main_t)&flx_main);
#else
  library = new flx_dynlink_t;
  library->dynamic_link(c->filename);
#endif
  return library;
}

}} // namespaces

int FELIX_MAIN (int argc, char** argv)
{
  // NOTE: TODO: Figure out how to delete these suckers properly
  flx_config *c = new flx_config(link_library, init_ptr_create_async_hooker, get_flx_args_config);
  flx_world *world=new flx_world(c);

  int error_exit_code = world->setup(argc, argv);

  if(0 != error_exit_code) return error_exit_code;

  // MAINLINE, ONLY DONE ONCE
  // TODO: simply return error_exit_code
  try {
    // We're all set up, so run felix
	world->begin_flx_code();

    // Run the felix usercode.
    while(world->run_until_blocked()) ;

	world->end_flx_code();

    error_exit_code = world->teardown();
  }
  catch (flx_exception_t &x) { error_exit_code = flx_exception_handler(&x); }
  catch (std::exception &x) { error_exit_code = std_exception_handler (&x); }
  catch (...)
  {
    fprintf(stderr, "flx_run driver ends with unknown EXCEPTION\n");
    error_exit_code = 4;
  }
  delete world;
  delete c;

  return error_exit_code;
}
