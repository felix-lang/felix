@tangler scalar=share/lib/std/scalar/ctypedefs.flx
@title Core Scalar Types

@h1 Language features.
In these definitions, we introduce basic types into Felix with
bindings to C. These are expressed by the @{type} statement,
which gives the Felix name of the type, and then the C 
name in quotes.

Note very particularly each type is distinct, type names
such as @{size_t} in C and C++ are merely aliases for
some other integer type, in Felix these types are 
completely distinct.

The adjective @{pod} stands for <em>plain old datatype</em>
and tells the system that the type has a trivial destructor
and does not require finalisation.

The adjective @{_gc_pointer} tells the system the abstract
primitive is in fact a pointer and the garbage collector
must follow it.

The @{requires} clause, if specified, tells the system
that the named floating insertion must be emitted into
the generated C++ code.  We will use the names of code
fragments specifying header files defined
in the <strong>cheaders</strong> package.

@h1 Character type
A basic 8 bit character type.
@tangle scalar
pod type char = "char";

@h1 Efficient Integer types
These types correspond to C99 integer types.
Note that Felix mandates the existence of the long long types.

Note we also require the C99 @{intmax_t} and @{uintmax_t}
types. These will usually be signed and unsigned
long long, however they may be an even larger type if the
C implementor desires.

We also map C89 @{size_t} and the less useful C99 @{ssize_t},
a signed variant of @{size_t}. These are used for array
lengths and in particular can span byte arrays as large
as can be addressed.

@tangle scalar
pod type tiny = "signed char";
pod type short = "short";
pod type int = "int";
pod type long = "long";
pod type vlong = "long long";
pod type utiny = "unsigned char";
pod type ushort = "unsigned short";
pod type uint = "unsigned int";
pod type ulong = "unsigned long";
pod type uvlong = "unsigned long long";

pod type intmax = "intmax_t" requires C99_headers::stdint_h;
pod type uintmax = "uintmax_t" requires C99_headers::stdint_h;
pod type size = "size_t" requires C89_headers::stddef_h;
pod type ssize = "ssize_t" requires C89_headers::stddef_h;


@h1 Exact Integer types
Here are the usual exact integer types.
Note that Felix mandates the existence of the @{stdint.h}
header file from C99, and that all the exact types are
defined. This includes 64 bit signed and unsigned integers,
even on a 32 bit machine.

@tangle scalar
pod type int8 = "int8_t" requires C99_headers::stdint_h;
pod type int16 = "int16_t" requires C99_headers::stdint_h;
pod type int32 = "int32_t" requires C99_headers::stdint_h;
pod type int64 = "int64_t" requires C99_headers::stdint_h;
pod type uint8 = "uint8_t" requires C99_headers::stdint_h;
pod type uint16 = "uint16_t" requires C99_headers::stdint_h;
pod type uint32 = "uint32_t" requires C99_headers::stdint_h;
pod type uint64 = "uint64_t" requires C99_headers::stdint_h;

@h1 Floating types
Note that Felix requires the long double type from C99.
Also note that the complex types are taken from C++ and
not C!
@tangle scalar
pod type float = "float";
pod type double = "double";
pod type ldouble = "long double";
pod type fcomplex = "::std::complex<float>" requires Cxx_headers::complex;
pod type dcomplex = "::std::complex<double>" requires Cxx_headers::complex;
pod type lcomplex = "::std::complex<long double>" requires Cxx_headers::complex;

@h1 Raw Memory
Raw memory operations provide an uninterpreted byte and
two address types.
 
We also provide a mapping of @{ptrdiff_t} which is a signed
type holding the result of subtracting two pointers or
addresses of the same type.

Finally, we provide signed and unsigned integers of the same
size as addresses and pointers which can be used to perform
arbitrary integer operations.

@tangle scalar
pod type byte = "unsigned char";
type caddress = "void *";
_gc_pointer type address = "void *";

pod type ptrdiff = "ptrdiff_t" requires C89_headers::stddef_h;

pod type intptr = "intptr_t" requires C99_headers::stdint_h;
pod type uintptr = "uintptr_t" requires C99_headers::stdint_h;
@

@h1 Groupings of the types.
We can define sets of types so they may be used in
in function bindings to avoid a lot of repetition.

The @{typesetof} operator takes a comma separated list
of parenthesised type names, and represents a finite
set of types.

The \(\cup\) operator, spelled @{\cup}, can be used to find the setwise
union of two typesets.


@tangle scalar
//$ Types associated with raw address calculations.
typedef addressing = typesetof (
  byte,
  address,
  caddress
);

//$ Character types.
typedef chars = typesetof (char);

@h2 Integers
@tangle scalar
//$ "natural" sized signed integer types.
//$ These correspond to C/C++ core types.
typedef fast_sints = typesetof (tiny, short, int, long, vlong);

//$ Exact sized signed integer types.
//$ In C these are typedefs.
//$ In Felix they're distinct types.
typedef exact_sints = typesetof(int8,int16,int32,int64);

//$ "natural" sized unsigned integer types.
//$ These correspond to C/C++ core types.
typedef fast_uints = typesetof (utiny, ushort, uint, ulong,uvlong);

//$ Exact sized unsigned integer types.
//$ In C these are typedefs.
//$ In Felix they're distinct types.
typedef exact_uints = typesetof (uint8,uint16,uint32,uint64);

//$ Weirdo signed integers types corresponding to
//$ typedefs in C.
typedef weird_sints = typesetof (ptrdiff, ssize, intmax, intptr);

//$ Weirdo unsigned integers types corresponding to
//$ typedefs in C.
typedef weird_uints = typesetof (size, uintmax, uintptr);

//$ All the signed integers.
typedef sints = fast_sints \cup exact_sints \cup weird_sints;

//$ All the usigned integers.
typedef uints = fast_uints \cup exact_uints \cup weird_uints;

//$ All the fast integers.
typedef fast_ints = fast_sints \cup fast_uints;

//$ All the exact integers.
typedef exact_ints = exact_sints \cup exact_uints;

//$ All the integers.
typedef ints = sints \cup uints;

@h2 Floats
@tangle scalar
//$ All the core floating point types.
typedef floats = typesetof (float, double, ldouble);

//$ All the core approximations to real types.
typedef reals = ints \cup floats;

//$ All the core approximations to complex types.
typedef complexes = typesetof (fcomplex,dcomplex,lcomplex);

//$ All the core approximations to numbers.
typedef numbers = reals \cup complexes;
@

@h2 All Scalars.
@tangle scalar
//$ All the basic scalar types.
typedef basic_types = bool \cup numbers \cup chars \cup addressing;

// we define this now, we will open it later...
instance [t in basic_types] Eq[t] {
  fun == : t * t -> bool = "$1==$2";
}

// we open this now even though we haven't developed
// the instances yet....
open[T in basic_types] Show[T];
