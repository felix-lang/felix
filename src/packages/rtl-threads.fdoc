@title Run Time Library Pthread support.

@tangler pthread_thread.hpp               = share/lib/rtl/pthread_thread.hpp
@tangler pthread_posix_thread.cpp         = share/src/pthread/pthread_posix_thread.cpp
@tangler pthread_win_thread.cpp           = share/src/pthread/pthread_win_thread.cpp
@tangler pthread_mutex.hpp                = share/lib/rtl/pthread_mutex.hpp
@tangler pthread_mutex.cpp                = share/src/pthread/pthread_mutex.cpp
@tangler pthread_condv.hpp                = share/lib/rtl/pthread_condv.hpp
@tangler pthread_condv.cpp                = share/src/pthread/pthread_condv.cpp
@tangler pthread_win_posix_condv_emul.hpp = share/lib/rtl/pthread_win_posix_condv_emul.hpp
@tangler pthread_win_posix_condv_emul.cpp = share/src/pthread/pthread_win_posix_condv_emul.cpp
@tangler pthread_semaphore.hpp            = share/lib/rtl/pthread_semaphore.hpp
@tangler pthread_semaphore.cpp            = share/src/pthread/pthread_semaphore.cpp
@tangler pthread_monitor.hpp              = share/lib/rtl/pthread_monitor.hpp
@tangler pthread_monitor.cpp              = share/src/pthread/pthread_monitor.cpp
@tangler pthread_counter.hpp              = share/lib/rtl/pthread_counter.hpp
@tangler pthread_counter.cpp              = share/src/pthread/pthread_counter.cpp
@tangler pthread_waitable_bool.hpp        = share/lib/rtl/pthread_waitable_bool.hpp
@tangler pthread_waitable_bool.cpp        = share/src/pthread/pthread_waitable_bool.cpp
@tangler pthread_thread_control.cpp       = share/src/pthread/pthread_thread_control.cpp
@tangler pthread_bound_queue.hpp          = share/lib/rtl/pthread_bound_queue.hpp
@tangler pthread_bound_queue.cpp          = share/src/gc/pthread_bound_queue.cpp
@tangler pthread_work_fifo.hpp            = share/lib/rtl/pthread_work_fifo.hpp
@tangler pthread_work_fifo.cpp            = share/src/gc/pthread_work_fifo.cpp
@tangler pthread_fast_lock.hpp            = share/lib/rtl/pthread_fast_lock.hpp
@tangler pthread_fast_lock.cpp            = share/src/gc/pthread_fast_lock.cpp
@tangler pthread_fast_lock.flx            = share/lib/std/pthread/pthread_fast_lock.flx
@tangler flx_pthread.py                   = $PWD/buildsystem/flx_pthread.py

@h1 Pthreads
The @{pthread_thread.hpp} defines pthreads and the system 
pthread control class. The control is implemented separately.

Felix pthreads are tightly integrated with the garbage
collector via the pthread control class. This is necessary
because the collector must stop all the pthreads before
it can reliably sweep the thread stacks for roots.

Thread control also ensure Felix programs do not terminate
until all managed pthreads have completed.

The Felix system uses detached threads. We provide joinable
threads here too, but Felix programmers should use detached
threads and pchannels for synchronisation.


@tangle pthread_thread.hpp
#ifndef __FLX_PTHREAD_THREAD_H__
#define __FLX_PTHREAD_THREAD_H__
#include "flx_pthread_config.hpp"

#if FLX_WIN32
#include <windows.h>
#else
#include <pthread.h>
#endif

// auto pthread, because I forget how to deallocate them nicely
// could init in the constructor, but ultimately you don't want the thread
// barging in before you've finished doing other stuff
// Addendum (20051128): doing stdio in turns out to be not very safe.
// I don't know if printf et al are supposed to be thread safe (most impls
// seem to try to be) but I sometimes get deadlocks in ppc64 os x 10.4.2
// with 4.0.1 when printfing to stdout. Nasty.

#include "pthread_mutex.hpp"
#include "pthread_condv.hpp"

#include <utility>
#include <map>
#include <vector>
#include <functional>

namespace flx { namespace pthread {

// ********************************************************
/// Posix Threads. This class simply wraps the creation
/// and joining of threads. It is not safe.
// ********************************************************

#ifdef _WIN32
typedef HANDLE flx_native_thread_t;
#else
typedef pthread_t flx_native_thread_t;
#endif

flx_native_thread_t PTHREAD_EXTERN get_current_native_thread();

struct thread_data_t {
  thread_data_t(void *b) : stack_base(b), stack_top(0), active(true) {}
  void *stack_base;
  void *stack_top;
  bool active;
};

struct memory_range_t {
  memory_range_t(void *b_, void *e_) : b(b_), e(e_) {}
  void *b;
  void *e;
};

typedef std::pair<flx_native_thread_t const, thread_data_t> thread_entry_t;
typedef std::map<flx_native_thread_t, thread_data_t, std::less<flx_native_thread_t> > thread_registry_t;
typedef std::vector<memory_range_t> memory_ranges_t;

class PTHREAD_EXTERN thread_control_base_t
{
public:
  virtual bool world_stop() = 0;
  virtual void world_start() = 0;
  virtual void resume() = 0;
  virtual void suspend() = 0;
  virtual void yield() = 0;
  virtual ~thread_control_base_t();
  virtual  memory_ranges_t *get_block_list() = 0; // called owns result and should delete it
};

class PTHREAD_EXTERN thread_control_t : public virtual thread_control_base_t
{
    thread_control_t (thread_control_t const &); // uncopyable
    void operator=(thread_control_t const&); // uncopyable
    bool do_world_stop;
    unsigned int thread_counter;
    unsigned int active_counter;
    flx_condv_t stop_guard;
    flx_mutex_t stop_mutex;
    thread_registry_t threads;
    void unsafe_stop_check();
    void unsafe_suspend();
    void unsafe_resume();
public:
    bool debug;
    thread_control_t (bool);
    int thread_count();
    int active_count();
    void add_thread(void*);
    void remove_thread();
    bool world_stop();
    void join_all() ;
    void world_start();
    void yield();
    void suspend();
    void resume();
    memory_ranges_t *get_block_list(); // called owns result and should delete it
};

struct tstart_t
{
  void (*sr)(void*);
  void *cd;
  thread_control_t *tc;
  flx_mutex_t *spawner_lock;
  flx_condv_t *spawner_cond;
  bool *spawner_flag;

  tstart_t(void (*s)(void*),void* c,thread_control_t *t, flx_mutex_t *sl, flx_condv_t *sc, bool *sf)
    : sr(s), cd(c), tc(t), spawner_lock(sl), spawner_cond(sc), spawner_flag(sf)
  {}
};

// a class for threads that can't be joined. upon exit all their resources
// are freed. they just evaporate. probably the best type of thread.
class PTHREAD_EXTERN flx_detached_thread_t {
  flx_native_thread_t thr;        ///< the thread
  flx_detached_thread_t(flx_detached_thread_t const&); // uncopyable
  void operator=(flx_detached_thread_t const&); // uncopyable
public:
  flx_detached_thread_t();
  ~flx_detached_thread_t();
  int init(void (*start)(void*), void* udat, thread_control_t*, flx_mutex_t*, flx_condv_t*, bool*);
};

// rf: joinable threads. is it an error to not join joinable threads?
class PTHREAD_EXTERN flx_thread_t {
  flx_native_thread_t thr;        ///< the thread
  flx_thread_t(flx_thread_t const&); // uncopyable
  void operator=(flx_thread_t const&); // uncopyable
public:
  flx_thread_t();
  ~flx_thread_t();
  int init(void (*start)(void*), void* udat, thread_control_t*);
  void join();
};

/// RAII wrapper for thread class
class PTHREAD_EXTERN flx_thread_wrapper_t {
  flx_thread_t thread;
  flx_thread_wrapper_t(flx_thread_wrapper_t const&); // uncopyable
  void operator=(flx_thread_wrapper_t const&); // uncopyable
public:
  ~flx_thread_wrapper_t();
  flx_thread_wrapper_t(void (*start)(void*), void* udat, thread_control_t *tc);
};

}}
#endif

@
@tangle pthread_posix_thread.cpp
#include "pthread_thread.hpp"
#if FLX_POSIX
#include <stdio.h>
#include <string.h>  // strerror
#include <cstdlib>
#include <setjmp.h>
#include <functional> // less
#include <assert.h>

namespace flx { namespace pthread {

flx_native_thread_t get_current_native_thread() { return pthread_self(); }

static void *get_stack_pointer() { unsigned long x; return &x; }

extern "C" void *flx_pthread_start_wrapper(void *e)
{
  void *stack_base = get_stack_pointer();
  tstart_t *ehd = (tstart_t*)e;
  thread_control_t *tc = ehd -> tc;
  if(tc && tc->debug)
    fprintf(stderr,"Spawned Thread %p start stack base = %p, tc=%p\n",get_current_native_thread(),stack_base, tc);
  if(tc)tc->add_thread(stack_base);
  void (*sr)(void*)=ehd->sr;
  void *cd = ehd->cd;
  if(ehd->spawner_lock)
  {
    flx_mutex_locker_t dummy(*ehd->spawner_lock);
    //fprintf(stderr,"Thread %lx acquired mutex\n", get_current_native_thread());
    //fprintf(stderr,"Thread %lx notifying spawner it has registered itself\n", get_current_native_thread());
    *ehd->spawner_flag=true;
    ehd->spawner_cond->broadcast();
    //fprintf(stderr,"Thread %lx releasing mutex\n", get_current_native_thread());
  }
  delete ehd;
  if(tc)tc->yield();
  try {
    (*sr)(cd);
  }
  catch (...) {
    fprintf(stderr,"Uncaught exception in thread\n");
    exit(1);
  }
  if(tc)tc->remove_thread();
  return NULL;
}


// ---- detached threads ----------

flx_detached_thread_t::flx_detached_thread_t(flx_detached_thread_t const&){} // uncopyable
void flx_detached_thread_t::operator=(flx_detached_thread_t const&){} // uncopyable

int
flx_detached_thread_t::init(void (*start)(void*), void* udat, thread_control_t *tc,
  flx_mutex_t * m,flx_condv_t *c,bool *flag)
{
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  int res = pthread_create(&thr, &attr, flx_pthread_start_wrapper,
    new tstart_t(start, udat, tc, m,c,flag));
  if(res)
  {
     fprintf(stderr, "WARNING: flx_detached_thread_t: pthread_create failed: %s\n",
       strerror(res));
  }
  pthread_attr_destroy(&attr);
  return res;
}

flx_detached_thread_t::~flx_detached_thread_t() { }
flx_detached_thread_t::flx_detached_thread_t() { }

// ---- joinable threads ----------
flx_thread_t::flx_thread_t(flx_thread_t const&){} // uncopyable
void flx_thread_t::operator=(flx_thread_t const&){} // uncopyable

int
flx_thread_t::init(void (*start)(void*), void* udat, thread_control_t*tc)
{
  int res = pthread_create(&thr, NULL, flx_pthread_start_wrapper,
    new tstart_t(start, udat, tc,NULL,NULL,NULL));
  if(res)
  {
     fprintf(stderr, "WARNING: flx_thread_t: pthread_create failed: %s\n",
       strerror(res));
  }
  return res;
}

void flx_thread_t::join() {
  int res = pthread_join(thr, NULL);
  if(res)
  {
     fprintf(stderr, "flx_thread_t: FATAL: pthread_join failed: %s\n",
       strerror(res));
#ifdef exit
     // Someone wants to replace exit with their own thing ...
     exit(1);
#else
     std::exit(1);
#endif
  }
}

flx_thread_t::~flx_thread_t() { }
flx_thread_t::flx_thread_t() { }

// ---- joinable thread wrapper ----------

flx_thread_wrapper_t::flx_thread_wrapper_t(flx_thread_wrapper_t const&){} // uncopyable
void flx_thread_wrapper_t::operator=(flx_thread_wrapper_t const&){} // uncopyable

flx_thread_wrapper_t::flx_thread_wrapper_t(void (*start)(void*), void* udat, thread_control_t*tc)
{
  int res = thread.init(start,udat,tc);
  {
    if(res)
    {
       fprintf(stderr, "FATAL: flx_thread_wapper_t: flx_thread_t.init failed: %s\n",
         strerror(res));
#ifdef exit
     // Someone wants to replace exit with their own thing ...
     exit(1);
#else
     std::exit(1);
#endif
    }
  }
}

flx_thread_wrapper_t::~flx_thread_wrapper_t() { thread.join(); }
}}

#endif
@
@tangle pthread_win_thread.cpp
#include "pthread_thread.hpp"
#if FLX_WIN32
#include <stdio.h>
#include <cstdlib>

namespace flx { namespace pthread {

flx_native_thread_t get_current_native_thread() { return GetCurrentThread(); }

#if defined(_MSC_VER)
#  pragma warning(push)
#  pragma warning(disable:4172)
#endif //defined(_MSC_VER)

static void *get_stack_pointer() { unsigned long x; return &x; }

#if defined(_MSC_VER)
#  pragma warning(pop)
#endif //defined(_MSC_VER)

DWORD WINAPI flx_pthread_start_wrapper(LPVOID e)
{
  void *stack_base = get_stack_pointer();
  tstart_t *ehd = (tstart_t*)e;
  thread_control_t *tc = ehd -> tc;
  if(tc && tc->debug)
    fprintf(stderr,"Spawned Thread %lx start stack base = %p, tc=%p\n",GetCurrentThreadId(),stack_base, tc);
  if(tc)tc->add_thread(stack_base);
  void (*sr)(void*)=ehd->sr;
  void *cd = ehd->cd;
  delete ehd;
  if(tc)tc->yield();
  try {
    (*sr)(cd);
  }
  catch (...) {
    fprintf(stderr,"Uncaught exception in thread\n");
    std::exit(1);
  }
  if(tc)tc->remove_thread();
  return 0;
}


// ---- detached threads ----------

flx_detached_thread_t::flx_detached_thread_t(flx_detached_thread_t const&){} // uncopyable
void flx_detached_thread_t::operator=(flx_detached_thread_t const&){} // uncopyable

// returns -1 on failure with error in GetLastError, 0 if all good.
int
flx_detached_thread_t::init(void (*start)(void*), void *lParam, thread_control_t *tc,
  flx_mutex_t * m,flx_condv_t *c,bool *flag)
{
  DWORD thread_id = 0;
  thr = (HANDLE)CreateThread(NULL, 0,
    (LPTHREAD_START_ROUTINE)flx_pthread_start_wrapper,
    new tstart_t(start,lParam, tc, m, c, flag), 0,
    &thread_id
  );

  if(!thr)
  {
    DWORD err = GetLastError();
    fprintf(stderr, "flx_detached_thread_t: CreateThread failed: %i\n", err);
    return err;
  }
  return 0;
}

flx_detached_thread_t::~flx_detached_thread_t() { CloseHandle(thr); }
flx_detached_thread_t::flx_detached_thread_t() { }

// ---- joinable threads ----------
flx_thread_t::flx_thread_t(flx_thread_t const&){} // uncopyable
void flx_thread_t::operator=(flx_thread_t const&){} // uncopyable


flx_thread_t::flx_thread_t() { }
flx_thread_t::~flx_thread_t() { }

// this should be idempotent
void
flx_thread_t::join()
{
  // Let's try and wait for the thread to finish, however first I have to
  // tell it to finish up.

  DWORD  wait_res = WaitForSingleObject(thr, INFINITE);

  // will this give me my return status? how do I get that?
  if(WAIT_FAILED == wait_res)
  {
    fprintf(stderr,"WARNING: thread wait failed (%li)\n", GetLastError());
  }

  // I've already tried waiting on the  thread's #include <stdlib> exit
  if(!CloseHandle(thr))
  {
    fprintf(stderr,"FATAL: failed to delete thread (%li)\n", GetLastError());
    std::exit(1);
  }
}

// returns -1 on failure with error in GetLastError, 0 if all good.
int
flx_thread_t::init(void (*fn)(void*), void *lParam, thread_control_t *tc)
{
  DWORD thread_id = 0;
  thr= (HANDLE)CreateThread(NULL, 0,
    (LPTHREAD_START_ROUTINE)flx_pthread_start_wrapper,
    new tstart_t(fn,lParam, tc,NULL,NULL,NULL), 0,
    &thread_id
  );

  if(!thr)
  {
    DWORD err = GetLastError();
    fprintf(stderr, "WARNING: flx_thread_t: CreateThread failed: %i\n", err);
    return err;
  }

  return 0;
}

// ---- joinable thread wrapper ----------
flx_thread_wrapper_t::flx_thread_wrapper_t(void (*f)(void*), void *lParam, thread_control_t*tc)
{
  int res = thread.init(f,lParam,tc);
  if(res)
  {
    fprintf(stderr,"flx_thread_wrapper_t: FATAL: flx_thread_t.init failed\n");
    std::exit(1);
  }
}
flx_thread_wrapper_t::~flx_thread_wrapper_t() { thread.join(); }

}}

#endif
@
@h1 Mutex
@tangle pthread_mutex.hpp
#ifndef __FLX_PTHREAD_MUTEX_H__
#define __FLX_PTHREAD_MUTEX_H__
#include "flx_pthread_config.hpp"

#include "pthread_win_posix_condv_emul.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Mutex.
// ********************************************************
class PTHREAD_EXTERN flx_mutex_t {
  flx_mutex_t(flx_mutex_t const&); // uncopyable
  void operator=(flx_mutex_t const&); // uncopyable
public:
  pthread_mutex_t m;        // be nice, don't touch
  flx_mutex_t();
  ~flx_mutex_t();
  void lock();
  void unlock();
};

class PTHREAD_EXTERN flx_mutex_locker_t {
  flx_mutex_t* p;
  flx_mutex_locker_t(flx_mutex_locker_t const&); // uncopyable
  void operator=(flx_mutex_locker_t const&); // uncopyable
public:
  flx_mutex_locker_t(flx_mutex_t& pm);
  ~flx_mutex_locker_t();
};

}} // namespace pthread, flx
#endif

@
@tangle pthread_mutex.cpp
#include "pthread_mutex.hpp"

namespace flx { namespace pthread {
flx_mutex_t::flx_mutex_t(flx_mutex_t const&){} // uncopyable
void flx_mutex_t::operator=(flx_mutex_t const&){} // uncopyable

flx_mutex_t::flx_mutex_t() { pthread_mutex_init(&m, NULL); }

flx_mutex_t::~flx_mutex_t() { pthread_mutex_destroy(&m); }
void flx_mutex_t::lock() { pthread_mutex_lock(&m); }
void flx_mutex_t::unlock() { pthread_mutex_unlock(&m);}

flx_mutex_locker_t::flx_mutex_locker_t(flx_mutex_locker_t const&){} // uncopyable
void flx_mutex_locker_t::operator=(flx_mutex_locker_t const&){} // uncopyable
flx_mutex_locker_t::flx_mutex_locker_t(flx_mutex_t& pm) : p(&pm) { p->lock(); }
flx_mutex_locker_t::~flx_mutex_locker_t() { p->unlock(); }

}}

@
@h1 Condition Variables
@tangle pthread_condv.hpp
#ifndef __FLX_PTHREAD_CONDV_H__
#define __FLX_PTHREAD_CONDV_H__
#include "flx_pthread_config.hpp"
#include "pthread_mutex.hpp"

#include "pthread_win_posix_condv_emul.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Condition Variable.
// ********************************************************
class PTHREAD_EXTERN flx_condv_t {
public:
  pthread_cond_t cv;        // be nice, don't touch
  flx_condv_t();
  ~flx_condv_t();
  void signal();
  void broadcast();
  void wait(flx_mutex_t*);
  int timedwait(flx_mutex_t*, struct timespec const*);
  int timedwait(flx_mutex_t *m, double t);
};

}} // namespace pthread, flx
#endif

@
@tangle pthread_condv.cpp
#include "pthread_condv.hpp"
#include <stdio.h>        // printf debugging
#include <assert.h>
#include <math.h>

namespace flx { namespace pthread {

flx_condv_t::flx_condv_t() { 
  int res = pthread_cond_init(&cv, NULL); 
  #if !FLX_WIN32
  if(res==EINVAL) {
    // I suspect this is an error .. perhaps something got deleted
    fprintf(stderr,"pthread_cond_init returned EINVAL!");
  }
  #endif
}
flx_condv_t::~flx_condv_t() { 
  int res = pthread_cond_destroy(&cv); 
  #if !FLX_WIN32
  if(res==EINVAL) {
    // I suspect this is an error .. perhaps something got deleted
    fprintf(stderr,"pthread_cond_destroy returned EINVAL!");
  }
  #endif
}
void flx_condv_t::wait(flx_mutex_t *m) { 
  int res = pthread_cond_wait(&cv,&(m->m)); 
  #if !FLX_WIN32
  if(res==EINVAL) {
    // I suspect this is an error .. perhaps something got deleted
    fprintf(stderr,"pthread_cond_wait returned EINVAL!");
  }
  #endif
}
void flx_condv_t::signal() { 
  int res =  pthread_cond_signal(&cv);
  #if !FLX_WIN32
  if(res==EINVAL) {
    // I suspect this is an error .. perhaps something got deleted
    fprintf(stderr,"pthread_cond_signal returned EINVAL!");
  }
  #endif
}
void flx_condv_t::broadcast() { 
  int res = pthread_cond_broadcast(&cv); 
  #if !FLX_WIN32
  if(res==EINVAL) {
    // I suspect this is an error .. perhaps something got deleted
    fprintf(stderr,"pthread_cond_broadcast returned EINVAL!");
  }
  #endif
}
int flx_condv_t::timedwait(flx_mutex_t *m, struct timespec const *t) {
  int res = pthread_cond_timedwait(&cv,&(m->m),t);
  #if !FLX_WIN32
  if(res==EINVAL) {
    // I suspect this is an error .. perhaps something got deleted
    fprintf(stderr,"pthread_cond_timedwait returned EINVAL!");
    return 0; // this is NOT an error!
  }
  #endif
  return res;
}

int flx_condv_t::timedwait(flx_mutex_t *m, double t) {
  struct timespec tv;
  tv.tv_sec = (unsigned long) (t);
  tv.tv_nsec = (unsigned long) ((t - floor (t)) * 1E9); // NanoSeconds
  return timedwait (m, &tv);
}

}}

@
@tangle pthread_win_posix_condv_emul.hpp
#ifndef __FLX_PTHREAD_WIN_POSIX_CONDV_EMUL_H__
#define __FLX_PTHREAD_WIN_POSIX_CONDV_EMUL_H__
// Note: no namespaces here!
// See http://www.cs.wustl.edu/~schmidt/win32-cv-1.html

#include "flx_pthread_config.hpp"
#if FLX_WIN32
#include <windows.h>

typedef HANDLE pthread_mutex_t;
typedef void pthread_mutexattr_t; // do NOT use them!
typedef void pthread_condattr_t; // do NOT use them!

struct timespec {
  unsigned long tv_sec;
  unsigned long tv_nsec;
};


struct pthread_cond_t
{
  int waiters_count_;
  // Number of waiting threads.

  CRITICAL_SECTION waiters_count_lock_;
  // Serialize access to <waiters_count_>.

  HANDLE sema_;
  // Semaphore used to queue up threads waiting for the condition to
  // become signaled.

  HANDLE waiters_done_;
  // An auto-reset event used by the broadcast/signal thread to wait
  // for all the waiting thread(s) to wake up and be released from the
  // semaphore.

  size_t was_broadcast_;
  // Keeps track of whether we were broadcasting or signaling.  This
  // allows us to optimize the code if we're just signaling.
};

// THIS IS SICK but there ain't no other way in C
#ifndef ETIMEDOUT
#define ETIMEDOUT WAIT_TIMEOUT
#endif
// looks like EAGAIN is available in minggw, but not in vs sdk.
#ifndef EAGAIN
#define EAGAIN WAIT_TIMEOUT
#endif

int PTHREAD_EXTERN pthread_mutex_init (pthread_mutex_t*, const pthread_mutexattr_t*);
int PTHREAD_EXTERN pthread_mutex_lock(pthread_mutex_t*);
int PTHREAD_EXTERN pthread_mutex_unlock(pthread_mutex_t*);
int PTHREAD_EXTERN pthread_mutex_destroy(pthread_mutex_t*);

int PTHREAD_EXTERN pthread_cond_init (pthread_cond_t*, const pthread_condattr_t*);
int PTHREAD_EXTERN pthread_cond_destroy(pthread_cond_t*);
int PTHREAD_EXTERN pthread_cond_wait (pthread_cond_t*, pthread_mutex_t*);
int PTHREAD_EXTERN pthread_cond_timedwait(pthread_cond_t*, pthread_mutex_t*, struct timespec const*);
int PTHREAD_EXTERN pthread_cond_uswait(pthread_cond_t*, pthread_mutex_t*, unsigned long us);
int PTHREAD_EXTERN pthread_cond_signal (pthread_cond_t*);
int PTHREAD_EXTERN pthread_cond_broadcast (pthread_cond_t*);


typedef HANDLE sem_t;

int PTHREAD_EXTERN sem_init(sem_t *sem, int pshared, unsigned int value);
int PTHREAD_EXTERN sem_wait(sem_t * sem);
int PTHREAD_EXTERN sem_trywait(sem_t * sem);
int PTHREAD_EXTERN sem_post(sem_t * sem);
int PTHREAD_EXTERN sem_getvalue(sem_t * sem, int * sval);
int PTHREAD_EXTERN sem_destroy(sem_t * sem);

#else
#include <errno.h>
#include <pthread.h>
#include <semaphore.h>
// emulate the native Window functionality
int PTHREAD_EXTERN pthread_cond_uswait( pthread_cond_t*, pthread_mutex_t*, unsigned long us);
#endif
#endif

@
@tangle pthread_win_posix_condv_emul.cpp
#include "pthread_win_posix_condv_emul.hpp"
#include <assert.h>
#if FLX_WIN32
#include <string.h>

// RF: unlike real pthread mutexes, windows mutexes are always recursive.
// that's annoying because I use deadlock as a debugging tool. the upshot
// is that recursively acquiring a mutex gives undefined results.
int pthread_mutex_init (pthread_mutex_t *m, const pthread_mutexattr_t*)
{
  *m = CreateMutex(NULL,FALSE,NULL);
  return 0;
}

int pthread_mutex_lock(pthread_mutex_t *m)
{
  WaitForSingleObject(*m,INFINITE);
  return 0;
}

int pthread_mutex_unlock(pthread_mutex_t *m)
{
  ReleaseMutex(*m);
  return 0;
}

int pthread_mutex_destroy(pthread_mutex_t *m)
{
  CloseHandle(*m);
  return 0;
}

int
pthread_cond_init
(
  pthread_cond_t *cv,
  const pthread_condattr_t *
)
{
  cv->waiters_count_ = 0;
  cv->was_broadcast_ = 0;
  cv->sema_ = CreateSemaphore
  (
    NULL,       // no security
    0,          // initially 0
    0x7fffffff, // max count .. (I hate limits .. but thats a lot of pthreads)
    NULL        // unnamed
  );
  InitializeCriticalSection (&cv->waiters_count_lock_);
  cv->waiters_done_ = CreateEvent
  (
    NULL,  // no security
    FALSE, // auto-reset
    FALSE, // non-signaled initially
    NULL   // unnamed
  );
  return 0;
}

int
pthread_cond_destroy(pthread_cond_t *cv)
{
  CloseHandle(cv->sema_);
  CloseHandle(cv->waiters_done_);
  return 0;
}

// returns ETIMEDOUT = WAIT_TIMEOUT
static int
private_cond_wait
(
  pthread_cond_t *cv,
  pthread_mutex_t *external_mutex,
  unsigned long ms // MilliSeconds
)
{
  // Avoid race conditions.
  EnterCriticalSection (&cv->waiters_count_lock_);
  cv->waiters_count_++;
  LeaveCriticalSection (&cv->waiters_count_lock_);

  // This call atomically releases the mutex and waits on the
  // semaphore until <pthread_cond_signal> or <pthread_cond_broadcast>
  // are called by another thread.
  int res = SignalObjectAndWait (*external_mutex, cv->sema_, ms, FALSE); // MilliSeconds

  // Reacquire lock to avoid race conditions.
  EnterCriticalSection (&cv->waiters_count_lock_);

  // We're no longer waiting...
  cv->waiters_count_--;

  // Check to see if we're the last waiter after <pthread_cond_broadcast>.
  int last_waiter = cv->was_broadcast_ && cv->waiters_count_ == 0;

  LeaveCriticalSection (&cv->waiters_count_lock_);

  // If we're the last waiter thread during this particular broadcast
  // then let all the other threads proceed.
  if (last_waiter)
    // This call atomically signals the <waiters_done_> event and waits until
    // it can acquire the <external_mutex>.  This is required to ensure fairness.
    SignalObjectAndWait (cv->waiters_done_, *external_mutex, INFINITE, FALSE);
  else
    // Always regain the external mutex since that's the guarantee we
    // give to our callers.
    WaitForSingleObject (*external_mutex, INFINITE);
  return res;
}

int
pthread_cond_wait
(
  pthread_cond_t *cv,
  pthread_mutex_t *external_mutex
)
{
  return private_cond_wait(cv,external_mutex,INFINITE);
}

// Posix is a pain in the butt here
// we have to get the current time and subtract it
// from the target time to get a duration
// the pain is that we probably wanted a duration
// and had to construct a target time by adding it
// to the current time
//
// to fix this we add the native Windows mode (a duration)
// to posix

int
pthread_cond_uswait
(
  pthread_cond_t *cv,
  pthread_mutex_t *external_mutex,
  unsigned long us // MicroSeconds
)
{

  // Windows waits in ms, ours in us
  return private_cond_wait(cv,external_mutex,us / 1000ul); // MilliSeconds
}

int
pthread_cond_timedwait
(
  pthread_cond_t *cv,
  pthread_mutex_t *external_mutex,
  struct timespec const *abstime
)
{
  unsigned long t1 = abstime->tv_sec * 1000ul + abstime->tv_nsec / 1000000ul; // MilliSeconds
  SYSTEMTIME tod;
  GetSystemTime(&tod);
  FILETIME ft;
  SystemTimeToFileTime(&tod,&ft);
  ULARGE_INTEGER now;  // so we can do some maths
  assert(sizeof(now) == sizeof(ft));
  memcpy(&now, &ft, sizeof(now));
  unsigned long t0 = now.QuadPart / 10; // us now
  unsigned long timeout = t1>t0 ? t1 - t0 : 0;
  return private_cond_wait(cv,external_mutex,timeout);
}

int
pthread_cond_signal (pthread_cond_t *cv)
{
  EnterCriticalSection (&cv->waiters_count_lock_);
  int have_waiters = cv->waiters_count_ > 0;
  LeaveCriticalSection (&cv->waiters_count_lock_);

  // If there aren't any waiters, then this is a no-op.
  if (have_waiters)
    ReleaseSemaphore (cv->sema_, 1, 0);
  return 0;
}

int
pthread_cond_broadcast (pthread_cond_t *cv)
{
  // This is needed to ensure that <waiters_count_> and <was_broadcast_> are
  // consistent relative to each other.
  EnterCriticalSection (&cv->waiters_count_lock_);
  int have_waiters = 0;

  if (cv->waiters_count_ > 0) {
    // We are broadcasting, even if there is just one waiter...
    // Record that we are broadcasting, which helps optimize
    // <pthread_cond_wait> for the non-broadcast case.
    cv->was_broadcast_ = 1;
    have_waiters = 1;
  }

  if (have_waiters) {
    // Wake up all the waiters atomically.
    ReleaseSemaphore (cv->sema_, cv->waiters_count_, 0);

    LeaveCriticalSection (&cv->waiters_count_lock_);

    // Wait for all the awakened threads to acquire the counting
    // semaphore.
    WaitForSingleObject (cv->waiters_done_, INFINITE);
    // This assignment is okay, even without the <waiters_count_lock_> held
    // because no other waiter threads can wake up to access it.
    cv->was_broadcast_ = 0;
  }
  else
    LeaveCriticalSection (&cv->waiters_count_lock_);
  return 0;
}

int sem_init(sem_t *sem, int pshared, unsigned int value)
{
  *sem = CreateSemaphore(NULL,value,0x7FFFFFFF,NULL);
  return 0;
}

int sem_wait(sem_t * sem)
{
  return WaitForSingleObject(*sem,INFINITE);
}

int sem_trywait(sem_t * sem)
{
  return WaitForSingleObject(*sem,0);
}

int sem_post(sem_t * sem)
{
  return ReleaseSemaphore(*sem,1,NULL);
}

int sem_getvalue(sem_t * sem, int * sval)
{
  LONG x;
  ReleaseSemaphore(*sem,0,&x);
  *sval = x;
  return 0;
}

int sem_destroy(sem_t * sem)
{
  return CloseHandle(*sem);
}


#else

//POSIX
#include <time.h>
#include <sys/time.h>

int pthread_cond_uswait(
  pthread_cond_t *cv,
  pthread_mutex_t *m,
  unsigned long us
)
{
  timeval tv;
  gettimeofday(&tv,NULL);
  unsigned long t0 = tv.tv_sec * 1000000uL + tv.tv_usec;
  unsigned long t1 = t0 + us;
  timespec ts;
  ts.tv_sec = t1 / 1000000uL;
  ts.tv_nsec = (t1 % 1000000uL) * 1000;
  return pthread_cond_timedwait(cv,m,&ts);
}

#endif

@
@h1 Semaphores
@tangle pthread_semaphore.hpp
@
@tangle pthread_semaphore.cpp
#ifndef __FLX_PTHREAD_SEMAPHORE_H__
#define __FLX_PTHREAD_SEMAPHORE_H__
#include "flx_pthread_config.hpp"
#include "pthread_mutex.hpp"

#include "pthread_win_posix_condv_emul.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Semaphore
// ********************************************************
class PTHREAD_EXTERN flx_semaphore_t {
  sem_t sem;
public:
  flx_semaphore_t(int n=0);
  ~flx_semaphore_t();
  void post();
  void operator++() { post(); }
  void wait();
  void operator--() { wait(); }
  int get();
  int operator*() { return get(); }

  /// atomic test and decrement if non-zero function.
  /// returns EAGAIN on failure to decrement.
  int trywait();
};

}} // namespace pthread, flx
#endif

@
@h1 Monitor
@tangle pthread_monitor.hpp
#ifndef __FLX_PTHREAD_MONITOR_H__
#define __FLX_PTHREAD_MONITOR_H__
#include "flx_pthread_config.hpp"
#include "pthread_mutex.hpp"
#include "pthread_condv.hpp"
#include "pthread_semaphore.hpp"

// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

namespace flx { namespace pthread {

// ********************************************************
/// A monitor is a concurrent version of a channel.
/// It matches up readers and writers in pairs,
/// synchronising transfer of one datum.
///
/// Unlike the bounded queue below, a monitor is a fully
/// synchronised unbuffered transfer, mediated by a full
/// handshake.
///
/// In particular, unlike the queue of size 1, the writer
/// cannot proceed until the reader sends an acknowledge
/// signal.
///
/// This logic matches that provides by schannels, but
/// across an asynchronous boundary.
// ********************************************************

class PTHREAD_EXTERN monitor_t {
  flx_mutex_t m;
  flx_mutex_t rm;
  flx_mutex_t wm;
  int dataput;
  int datagot;
  flx_condv_t ack;
  void *data;
public:
  monitor_t();
  ~monitor_t();
  void enqueue(void*);
  void* dequeue();
};

}} // namespace pthread, flx
#endif

@
@tangle pthread_monitor.cpp
#include "pthread_monitor.hpp"
#include <queue>        // stl to the bloated rescue
#include <string.h>       // strerror
#include <assert.h>

using namespace std;

namespace flx { namespace pthread {

monitor_t::monitor_t() : dataput(0),datagot(0) {}
monitor_t::~monitor_t() { }
inline static void handshake_pos(int &a, flx_condv_t &c, flx_mutex_t &m)
{
  ++a;
  if(a != 0) do { c.wait(&m); } while (a != 0);
  else c.signal();
  assert(a == 0);
  //if(!(a == 0)) fprintf(stderr,"ASSER FAIL\n");
}

inline static void handshake_neg(int &a, flx_condv_t &c, flx_mutex_t &m)
{
  --a;
  if(a != 0) do { c.wait(&m); } while (a != 0);
  else c.signal();
  assert(a == 0);
  //if(!(a == 0)) fprintf(stderr,"ASSER FAIL\n");
}

void
monitor_t::enqueue(void* elt)
{
  flx_mutex_locker_t   wl(wm); // exclude other writers
  flx_mutex_locker_t   l(m);
  data = elt;
  handshake_pos(dataput, ack, m);
  handshake_pos(datagot, ack, m);
}

void*
monitor_t::dequeue()
{
  flx_mutex_locker_t   rl(rm); // exclude other readers
  flx_mutex_locker_t   l(m);
  handshake_neg(dataput, ack, m);
  void *d = data;              // get the data
  handshake_neg(datagot, ack, m);
  return d;
}

}}

@
@h1 Shared Counter
@tangle pthread_counter.hpp
#ifndef __FLX_PTHREAD_COUNTER_H__
#define __FLX_PTHREAD_COUNTER_H__
#include "flx_pthread_config.hpp"
#include "pthread_mutex.hpp"
#include "pthread_condv.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Counter with zero signal
// ********************************************************
class PTHREAD_EXTERN flx_ts_counter_t {
  flx_mutex_t m;
  flx_condv_t c;
  long x;
  void operator=(flx_ts_counter_t const &);
  flx_ts_counter_t(flx_ts_counter_t const &);
public:
  flx_ts_counter_t();
  ~flx_ts_counter_t();
  long pre_incr(); // value AFTER increment
  long pre_decr(); // value AFTER decrement
  long post_incr(); // value BEFORE increment
  long post_decr(); // value BEFORE decrement

  long get();
  long set(long);   // returns argument
  long swap(long);  // returns old value
  long decr_pos(); // decrement if >0
  void wait_zero(); // wait for zero
  long operator++() { return pre_incr(); }
  long operator--() { return pre_decr(); }
  long operator++(int) { return post_incr(); }
  long operator--(int) { return post_decr(); }
  long operator*() { return get(); }
  long operator=(long a) { return set(a); }
};
}}

#endif

@
@tangle pthread_counter.cpp
#include "pthread_counter.hpp"
#include <stdio.h>

namespace flx { namespace pthread {


flx_ts_counter_t::flx_ts_counter_t() : x(0) {}

flx_ts_counter_t::~flx_ts_counter_t() {
  wait_zero();
}

long flx_ts_counter_t::pre_incr() {
  flx_mutex_locker_t l(m);
  ++x;
  return x;
}

long flx_ts_counter_t::pre_decr() {
  flx_mutex_locker_t l(m);
  --x;
  if(x==0) c.signal();
  return x;
}

long flx_ts_counter_t::post_incr() {
  flx_mutex_locker_t l(m);
  ++x;
  return x+1;
}

long flx_ts_counter_t::post_decr() {
  flx_mutex_locker_t l(m);
  --x;
  if(x==0) c.signal();
  return x+1;
}

long flx_ts_counter_t::decr_pos() {
  flx_mutex_locker_t l(m);
  if(x>0)--x;
  if(x==0) c.signal();
  return x;
}

long flx_ts_counter_t::get() {
  flx_mutex_locker_t l(m);
  return x;
}

long flx_ts_counter_t::set(long a) {
  flx_mutex_locker_t l(m);
  x = a;
  return x;
}

long flx_ts_counter_t::swap(long a) {
  flx_mutex_locker_t l(m);
  long tmp = x;
  x = a;
  if(x==0) c.signal();
  return tmp;
}

void flx_ts_counter_t::wait_zero() {
  flx_mutex_locker_t l(m);
  while(1){
    if(x==0)return;
    c.wait(&m);
  }
}

}}

@
@h1 Shared Boolean
@tangle pthread_waitable_bool.hpp
#ifndef __FLX_PTHREAD_WAIT_BOOL_H__
#define __FLX_PTHREAD_WAIT_BOOL_H__
#include "flx_pthread_config.hpp"
#include "pthread_mutex.hpp"  // mutexes
#include "pthread_condv.hpp"  // condition var for same

namespace flx { namespace pthread {

// a waitable boolean.
class PTHREAD_EXTERN waitable_bool {
  flx::pthread::flx_mutex_t cv_lock;       // to work with the condition var
  flx::pthread::flx_condv_t finished_cond;
  bool finished;   // might seem redundant, but that's how CVs work.
public:
  waitable_bool();

  void wait_until_true();
  void signal_true();
};

}} // namespace pthread, flx
#endif // __FLX_PTHREAD_WAIT_BOOL_H__

@
@tangle pthread_waitable_bool.cpp
#include "pthread_waitable_bool.hpp"

namespace flx { namespace pthread {

waitable_bool::waitable_bool()
  : finished(false)
{
  // nothing
}

// can be called from any thread
void
waitable_bool::wait_until_true()
{
  flx::pthread::flx_mutex_locker_t    locker(cv_lock);

  // wait for the wakeup to say it's finished
  while(!finished)
  {
    finished_cond.wait(&cv_lock);
  }
}

void
waitable_bool::signal_true()
{
  { // the mutex is required for the memory barrier..
    flx::pthread::flx_mutex_locker_t    locker(cv_lock);
    finished = true;
  }
  finished_cond.signal();
  // do absolutely NOTHING here as a typical use of this class is to
  // wait for a thread exit and then destruct its resources, which could
  // very well include this object. boom.
}

} }

@
@h1 Thread Control
@tangle pthread_thread_control.cpp
#include "pthread_thread.hpp"
#include <stdio.h>
#include <cstdlib>
#include <cassert>

#define FLX_SAVE_REGS \
  jmp_buf reg_save_on_stack; \
  setjmp (reg_save_on_stack)


namespace flx { namespace pthread {

static void *get_stack_pointer() { void *x = (void*)&x; return x; }

thread_control_base_t::~thread_control_base_t(){}

thread_control_t::thread_control_t (thread_control_t const &) {}
void thread_control_t::operator=(thread_control_t const &) {}

thread_control_t::thread_control_t (bool d) :
  do_world_stop(false), thread_counter(0), active_counter(0), debug(d)
  {
    if(debug)
      fprintf(stderr,"INITIALISING THREAD CONTROL OBJECT\n");
  }

int thread_control_t::thread_count()
  {
    flx_mutex_locker_t m(stop_mutex);
    return thread_counter;
  }

int thread_control_t::active_count()
  {
    flx_mutex_locker_t m(stop_mutex);
    return active_counter;
  }

void thread_control_t::add_thread(void *stack_base)
  {
    flx_mutex_locker_t m(stop_mutex);
    flx_native_thread_t id = get_current_native_thread();
    threads.insert (std::make_pair(id, thread_data_t (stack_base)));
    ++thread_counter;
    ++active_counter;
    if(debug)
      fprintf(stderr, "Adding thread %lx base %p, count=%d\n", (unsigned long)id, stack_base, thread_counter);
    stop_guard.broadcast();
  }

void thread_control_t::remove_thread()
  {
    flx_mutex_locker_t m(stop_mutex);
    flx_native_thread_t id = get_current_native_thread();
    if (threads.erase(id) == 0)
    {
      fprintf(stderr, "Remove thread %lx which is not registered\n", (unsigned long)id);
      std::abort();
    }
    --thread_counter;
    --active_counter;
    if(debug)
      fprintf(stderr, "Removed thread %lx, count=%d\n", (unsigned long)id, thread_counter);
    stop_guard.broadcast();
  }

// stop the world!

// NOTE: ON EXIT, THE MUTEX REMAINS LOCKED

bool thread_control_t::world_stop()
  {
    stop_mutex.lock();
    if(debug)
      fprintf(stderr,"Thread %lx Stopping world, active threads=%d\n", (unsigned long)get_current_native_thread(), active_counter);
    if (do_world_stop) {
      stop_mutex.unlock();
      return false; // race! Someone else beat us
    }
    do_world_stop = true;
    stop_guard.broadcast();
    while(active_counter>1) {
      if(debug)
        for(
          thread_registry_t::iterator it = threads.begin();
          it != threads.end();
          ++it
        )
        {
          fprintf(stderr, "Thread = %lx is %s\n",(unsigned long)(*it).first, (*it).second.active? "ACTIVE": "SUSPENDED");
        }
      if(debug)
        fprintf(stderr,"Thread %lx Stopping world: begin wait, threads=%d\n",  (unsigned long)get_current_native_thread(), thread_counter);
      stop_guard.wait(&stop_mutex);
      if(debug)
        fprintf(stderr,"Thread %lx Stopping world: checking threads=%d\n", (unsigned long)get_current_native_thread(), thread_counter);
    }
    // this code has to be copied here, we cannot use 'yield' because
    // it would deadlock ourself
    {
      flx_native_thread_t id = get_current_native_thread();
      FLX_SAVE_REGS;
      void *stack_pointer = get_stack_pointer();
      if(debug)
        fprintf(stderr,"World stop thread=%lx, stack=%p!\n",(unsigned long)id, stack_pointer);
      thread_registry_t::iterator it = threads.find(id);
      if(it == threads.end()) {
        fprintf(stderr,"MAIN THREAD: Cannot find thread %lx in registry\n",(unsigned long)id);
        abort();
      }
      (*it).second.stack_top = stack_pointer;
      if(debug)
        fprintf(stderr,"Stack size = %ld\n",(long)((char*)(*it).second.stack_base -(char*)(*it).second.stack_top));
    }
    if(debug)
      fprintf(stderr,"World STOPPED\n");
    return true; // we stopped the world
  }

// used by mainline to wait for other threads to die
void thread_control_t::join_all()
  {
    flx_mutex_locker_t m(stop_mutex);
    if(debug)
      fprintf(stderr,"Thread %lx Joining all\n", (unsigned long)get_current_native_thread());
    while(do_world_stop || thread_counter>1) {
      unsafe_stop_check();
      stop_guard.wait(&stop_mutex);
    }
    if(debug)
      fprintf(stderr,"World restarted: do_world_stop=%d, Yield thread count now %d\n",do_world_stop,thread_counter);
  }

// restart the world
void thread_control_t::world_start()
  {
    if(debug)
      fprintf(stderr,"Thread %lx Restarting world\n", (unsigned long)get_current_native_thread());
    do_world_stop = false;
    stop_mutex.unlock();
    stop_guard.broadcast();
  }

memory_ranges_t *thread_control_t::get_block_list()
{
  memory_ranges_t *v = new std::vector<memory_range_t>;
  thread_registry_t::iterator end = threads.end();
  for(thread_registry_t::iterator i = threads.begin();
    i != end;
    ++i
  )
  {
    thread_data_t const &td = (*i).second;
    // !(base < top) means top <= base, i.e. stack grows downwards
    assert(!std::less<void*>()(td.stack_base,td.stack_top));
    // from top upto base..
    v->push_back(memory_range_t(td.stack_top, td.stack_base));
  }
  return v;
}

void thread_control_t::suspend()
{
  flx_mutex_locker_t m(stop_mutex);
  if(debug)
    fprintf(stderr,"suspend %lx\n", (unsigned long)get_current_native_thread());
  unsafe_suspend();
}

void thread_control_t::resume()
{
  flx_mutex_locker_t m(stop_mutex);
  if(debug)
    fprintf(stderr,"resume %lx\n", (unsigned long)get_current_native_thread());
  unsafe_resume();
}


void thread_control_t::unsafe_suspend()
{
  void *stack_pointer = get_stack_pointer();
  flx_native_thread_t id = get_current_native_thread();
  if(debug)
    fprintf(stderr,"Suspend found world stop, thread=%lx, stack=%p!\n",(unsigned long)id, stack_pointer);
  thread_registry_t::iterator it = threads.find(id);
  if(it == threads.end()) {
    if(debug)
      fprintf(stderr,"Suspend::Cannot find thread %lx in registry\n",(unsigned long)id);
      abort();
  }
  (*it).second.stack_top = stack_pointer;
  (*it).second.active = false;
  if(debug)
    fprintf(stderr,"Stack size = %ld\n",(long)((char*)(*it).second.stack_base -(char*)(*it).second.stack_top));
  --active_counter;
  if(debug)
    fprintf(stderr,"Suspend: active thread count now %d\n",active_counter);
  stop_guard.broadcast();
}

void thread_control_t::unsafe_resume()
{
  if(debug)
    fprintf(stderr,"Unsafe resume %lx\n", (unsigned long)get_current_native_thread());
  stop_guard.broadcast();
  while(do_world_stop) stop_guard.wait(&stop_mutex);
  ++active_counter;
  flx_native_thread_t id = get_current_native_thread();
  thread_registry_t::iterator it = threads.find(id);
  if(it == threads.end()) {
    if(debug)
      fprintf(stderr,"Suspend::Cannot find thread %lx in registry\n",(unsigned long)id);
      abort();
  }
  (*it).second.active = true;
  if(debug) {
    fprintf(stderr,"Thread %lx resumed, active count= %d\n",(unsigned long)get_current_native_thread(),active_counter);
  }
  stop_guard.broadcast();
}

// mutex already held
void thread_control_t::unsafe_stop_check()
{
  if (do_world_stop)
  {
    if(debug)
      fprintf(stderr,"Thread %lx Unsafe stop check (world_stop detected) \n", (unsigned long)get_current_native_thread());
    FLX_SAVE_REGS;
    unsafe_suspend();
    unsafe_resume();
  }
}

void thread_control_t::yield()
{
  flx_mutex_locker_t m(stop_mutex);
  if(debug)
    fprintf(stderr,"Yield %lx\n", (unsigned long)get_current_native_thread());
  unsafe_stop_check();
}

}}

@
@h1 Bound Queue
@tangle pthread_bound_queue.hpp
#ifndef __FLX_PTHREAD_BOUND_QUEUE_H__
#define __FLX_PTHREAD_BOUND_QUEUE_H__
#include "flx_pthread_config.hpp"
#include "pthread_mutex.hpp"
#include "pthread_condv.hpp"
#include "flx_gc.hpp"

// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

namespace flx { namespace pthread {

// ********************************************************
/// Thread safe bounded queue.
///
/// The queue can be locked by setting bound=0.
/// In this state it can only be unlocked by setting a non-zero bound.
///
/// If the bound is set to 1 (the default),
/// then the queue is always either empty or full.
/// An empty queue blocks readers until a writer sends some data.
/// A full queue blocks writers, until a reader reads the data.
/// Note that when the queue is empty a writer can write data
/// and continues without waiting for the data to be read.
// ********************************************************

class GC_EXTERN bound_queue_t {
  flx_condv_t size_changed;
  size_t bound;
public:
  void *lame_opaque; // has to be public for the scanner to find it
  flx_mutex_t member_lock;
  bound_queue_t(size_t);
  ~bound_queue_t();
  void enqueue(void*);
  void* dequeue();
  void* maybe_dequeue();
  void resize(size_t);
  void wait_until_empty();
  size_t len();
};

GC_EXTERN ::flx::gc::generic::scanner_t bound_queue_scanner;

}} // namespace pthread, flx
#endif

@

@tangle pthread_bound_queue.cpp
#include "pthread_bound_queue.hpp"
#include <queue>        // stl to the bloated rescue
#include <stdio.h>      // debugging in scanner

using namespace std;

namespace flx { namespace pthread {
typedef deque<void*> void_queue;

#define ELTQ ((void_queue*)lame_opaque)

bound_queue_t::bound_queue_t(size_t n) : bound(n)
{
  lame_opaque = new void_queue;
}

// Much care is needed deleting a queue.
// A safe method is possible .. but not provided here
bound_queue_t::~bound_queue_t()
{
  delete ELTQ;
}

// get the number of element in the queue
// (NOT the bound!)
size_t bound_queue_t::len() {
  flx_mutex_locker_t   l(member_lock);
  return ELTQ->size();
}

void bound_queue_t::wait_until_empty() {
  flx_mutex_locker_t   l(member_lock);
  while(!ELTQ->empty())
    size_changed.wait(&member_lock);
}

void
bound_queue_t::enqueue(void* elt)
{
  flx_mutex_locker_t   l(member_lock);
  while(ELTQ->size() >= bound) // guard against spurious wakeups!
    size_changed.wait(&member_lock);
  ELTQ->push_back(elt);
  size_changed.broadcast(); // cannot return an error
}

void*
bound_queue_t::dequeue()
{
  flx_mutex_locker_t   l(member_lock);
  while(ELTQ->empty())  // guard against spurious wakeups!
    size_changed.wait(&member_lock);
  void *elt = ELTQ->front();
  ELTQ->pop_front();
  size_changed.broadcast();
  return elt;
}

void*
bound_queue_t::maybe_dequeue()
{
  flx_mutex_locker_t   l(member_lock);
  void *elt = NULL;
  if (ELTQ->size() > 0)
  {
    elt = ELTQ->front();
    ELTQ->pop_front();
    size_changed.broadcast();
  }
  return elt;
}


void
bound_queue_t::resize(size_t n)
{
  flx_mutex_locker_t   l(member_lock);
  bound = n;
  // get things rolling again
  size_changed.broadcast();
}

using namespace flx;;
using namespace gc;
using namespace generic;

void *bound_queue_scanner(
  collector_t *collector, 
  gc_shape_t *shape, void *pp, 
  unsigned long dyncount, 
  int reclimit
)
{
  // input is a pointer to a pointer to a bound queue object
  void *p = *(void**)pp;
  bound_queue_t *bq = (bound_queue_t*)p;
  void_queue *pq = (void_queue*) bq->lame_opaque;
  printf("Scanning bound queue %p->%p\n", pp, p);
  
  ::std::deque<void*>::const_iterator stl_end = pq->end();
  for(
    ::std::deque<void*>::const_iterator iter= pq->begin(); 
    iter < stl_end;
    ++iter
  ) {
    void *value = *iter;
    printf("bound_queue scanning p=%p\n",value); 
    collector->register_pointer(value,reclimit);
  }
  return 0;
}


}}


@

@h1 Thread Pool
This thread pool is used internally for C++ jobs by the
asynchronous I/O system.  The threads are Felix threads
and the Felix bound queue is used for the fifo.


@tangle pthread_work_fifo.hpp
#ifndef __FLX_PTHREAD_WORKER_FIFO_H__
#define __FLX_PTHREAD_WORKER_FIFO_H__
#include "flx_pthread_config.hpp"
#include "pthread_thread.hpp"
#include "pthread_mutex.hpp"
#include "pthread_bound_queue.hpp"

namespace flx { namespace pthread {

/// Class of jobs to be queued in fifo for execution.
class GC_EXTERN worker_task
{
public:
  virtual ~worker_task() {}   // c++ should do this automatically

  /// function called by worker thread to carry out user job
  virtual void doit() = 0;

  /// function called by worker thread after doit() is completed
  /// used to notify job completion
  virtual void finished() = 0; // finished hook (mi serve start gancia?)
};

/// Job scheduler, executes jobs in turn from queue
/// Does not delete dequeued jobs
class GC_EXTERN worker_fifo
{
  flx_mutex_t nlock;
  int nthreads;                 /// scheduled number of threads
  bound_queue_t fifo;

  static void thread_start(void*); // thread entry point, passed this
  bool thread_loop_body();      // returns keep going flag
  void stop_worker_thread();
  void start_worker_thread();

public:
  worker_fifo(int n, int m);   /// n: Q bound, m: # of threads
  ~worker_fifo();
  void add_worker_task(worker_task* task);
  int get_nthreads();
  void set_nthreads(int);
};

}} // namespace pthread, flx
#endif  // __WORKER_FIFO__

@
@tangle pthread_work_fifo.cpp
#include <stdio.h>    // printf
#include "pthread_work_fifo.hpp"
namespace flx { namespace pthread {

int worker_fifo::get_nthreads() {
  flx_mutex_locker_t dummy(nlock);
  return nthreads;
}

void worker_fifo::set_nthreads(int n)
{
  flx_mutex_locker_t dummy(nlock);
  while(nthreads<n) start_worker_thread();
  while(nthreads>n) stop_worker_thread();
}

void worker_fifo::start_worker_thread()
{
  ++nthreads;
  //fprintf(stderr,"Spawn detached worker thread, count=%d\n",nthreads);
  flx_detached_thread_t().init(thread_start, this,NULL, NULL, NULL, NULL);
}

worker_fifo::worker_fifo(int n, int m) : nthreads(0), fifo(n)
{
  set_nthreads(m);
}

void
worker_fifo::stop_worker_thread()
{
  //fprintf(stderr,"Kill detached worker thread, count=%d\n",nthreads);
  --nthreads;
  add_worker_task(NULL);    // thread safe takedown.
}

worker_fifo::~worker_fifo()
{
  while(nthreads>0)stop_worker_thread();
  fifo.wait_until_empty();
}

// io thread entry point, passed this
void
worker_fifo::thread_start(void* udat)
{
  worker_fifo*  fio = (worker_fifo*)udat;
  while(fio->thread_loop_body()) ;
}

// dequeues one task and executes it, calling finished hook. interprets
// null task as a request to exit.
bool
worker_fifo::thread_loop_body()
{
  worker_task*  req = (worker_task*)fifo.dequeue();
  //fprintf(stderr,"dequeued worker_task (%p)\n", req);

  if(!req) return false;        // finished, got quit signal

  req->doit();
  req->finished();          // finish hook. I find this handy
  // Note: task not deleted. use finish hook if you want that

  return true;            // keep going
}

void
worker_fifo::add_worker_task(worker_task* task)
{
  //fprintf(stderr,"adding worker task %p\n",task);
  fifo.enqueue(task);         // don't worry, fifo is re-entrant
}

}}

@

@tangle flx_pthread.py
import fbuild
from fbuild.path import Path
from fbuild.record import Record
from fbuild.builders.file import copy

import buildsystem
from buildsystem.config import config_call

# ------------------------------------------------------------------------------

def build_runtime(phase):
    print('[fbuild] [rtl] build pthread')
    path = Path(phase.ctx.buildroot/'share'/'src/pthread')

 
    srcs = [
        path / 'pthread_win_posix_condv_emul.cpp', # portability hackery
        path / 'pthread_mutex.cpp',
        path / 'pthread_condv.cpp',
        path / 'pthread_counter.cpp',
        path / 'pthread_waitable_bool.cpp',
        path / 'pthread_semaphore.cpp',
        path / 'pthread_monitor.cpp',
        path / 'pthread_thread_control.cpp',
        path / 'pthread_win_thread.cpp',
        path / 'pthread_posix_thread.cpp',
    ]
    includes = [
      phase.ctx.buildroot / 'host/lib/rtl', 
      phase.ctx.buildroot / 'share/lib/rtl']
    macros = ['BUILD_PTHREAD']
    flags = []
    libs = []
    external_libs = []

    pthread_h = config_call('fbuild.config.c.posix.pthread_h',
        phase.platform,
        phase.cxx.shared)

    dst = 'host/lib/rtl/flx_pthread'
    if pthread_h.pthread_create:
        flags.extend(pthread_h.flags)
        libs.extend(pthread_h.libs)
        external_libs.extend(pthread_h.external_libs)

    return Record(
        static=buildsystem.build_cxx_static_lib(phase, dst, srcs,
            includes=includes,
            macros=macros,
            cflags=flags,
            libs=libs,
            external_libs=external_libs,
            lflags=flags),
        shared=buildsystem.build_cxx_shared_lib(phase, dst, srcs,
            includes=includes,
            macros=macros,
            cflags=flags,
            libs=libs,
            external_libs=external_libs,
            lflags=flags))

@

@h1 Fast Resource Lock
This is a fast application level lock to be used for serialisation
of transient accessed to data structures. It is a mutex, however
unlike system mutex, it is safe to use with the Felix GC. 

System mutex are NOT GC safe because in Felix every allocation
may potentially trigger a garbage collection which requires a world
stop. Since world stops are cooperative, the collector must wait
until all threads have voluntarily yielded, usually by themselves
performing an allocation or an explicit call to perform a collection,
but suicide should work too. 

However if a thread blocks trying to lock a mutex held by another
thread which is now stopped for the GC, we have a deadlock.
So a user level lock must have a timeout and a spin loop which
includes regular checking for a GC world stop request.

It would be acceptable if the check were done atomically with
blocking on a lock request followed by another check,
because locking itself does not change reachability state.
With those semantics, it's fine for the thread to block,
provided the GC counts it as having yielded, and it cannot
unblock during the GC. That basically means unlocking must
also do the check, to ensure blocked threads stay blocked.

@tangle pthread_fast_lock.hpp
#ifndef __pthread_fast_lock__
#define __pthread_fast_lock__
#include "flx_gc.hpp"
#include <atomic>
namespace flx { namespace rtl {

class GC_EXTERN fast_lock
{
   ::std::atomic_flag flag;
   ::flx::pthread::thread_control_base_t *tc;
public:
   fast_lock(::flx::pthread::thread_control_base_t *);
   fast_lock() = delete;
   fast_lock(fast_lock const&)  = delete;
   void operator = (fast_lock const&) = delete;
   void lock();
   void unlock();
};
}}
#endif
@

@tangle pthread_fast_lock.cpp
#include "pthread_fast_lock.hpp"
#include <chrono>
#include <thread>

namespace flx { namespace rtl {
fast_lock::fast_lock(::flx::pthread::thread_control_base_t *tc_) : tc(tc_), flag(ATOMIC_FLAG_INIT) {}
void fast_lock::unlock() { flag.clear(); }
void fast_lock::lock() {
  while (!flag.test_and_set())
  {
    tc->yield();
    ::std::this_thread::sleep_for(::std::chrono::nanoseconds (200));
  }
}

}}
@

@tangle pthread_fast_lock.flx
class FastLock
{
   type fast_lock = "::flx::rtl::fast_lock*" 
     requires header '#include "pthread_fast_lock.hpp"';
   ctor fast_lock : unit = "new ::flx::rtl::fast_lock(PTF gcp->collector->get_thread_control())";
   proc delete : fast_lock = "delete $1;";
   proc lock : fast_lock = "$1->lock();";
   proc unlock : fast_lock = "$1->unlock();";

}
@

