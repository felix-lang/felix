\documentclass{article}
\usepackage{color}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage{parskip}
\usepackage{minted}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{makeidx}
\makeindex
\usemintedstyle{friendly}
\setminted{bgcolor=bg,xleftmargin=20pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\autoref*{#1} \nameref*{#1}}}
\DeclareMathOperator{\quot}{div}
\DeclareMathOperator{\rmd}{rmd}
\title{Programming with Coroutines}
\author{John Skaller}
\begin{document}
\maketitle
\chapter{Introduction}
Coroutines are not a new concept, however they have been ignored for
far too long. They solve many programming problems in a natural way and
any decent language today should provide a mix of coroutines and procedural
and functional subroutines, as well as explicit continuation passing.

Alas, since no such system exists to my knowledge I have had to create
one to experiment with: Felix will be used in this document simply
because there isn't anything else!

\section{What is a coroutine?}
A coroutine is basically a procedure which can be spawned to begin
a fibre of control which can be suspended and resumed under program
control at specific points. Coroutines communicate with each other
using synchronous channels to read and write data from and to other
coroutines. Read and write operations are synchronisation points,
which are points where a fibre may be suspended or resumed.

Although fibres look like threads, there is a vital distinction: multiple
fibres make up a single thread, and within that only one fibre is ever
executing. Fibration is a technique used to structure sequential programs,
there is no concurrency involved.

The best way to understand coroutines and fibration is to have a look
at a simple example. First, we make a coroutine procedure which writes the integers
from 0 up to but excluding 10 down a channel.

\begin{minted}{felix}
proc producer (out: %>int) () {
  for i in 0..<10 
    perform write (out, i);
}
\end{minted}

Notice that as well as passing the output channel argument \verb%out%,
there is an extra unit argument \verb%()%. This procedure terminates
after it has written 10 integers.

Next, we make a device which repeatedly reads an integer, squares it,
and writes the result. It is an infinite loop, this coroutine never
terminates of its own volition. This is typical of coroutines.

\begin{minted}
proc transducer (inp: %<int, out: %>int) () {
  while true do
    var x = read inp;
    var y = x * x;
    write (out, y);
  done
}
\end{minted}

Now we need a coroutine to print the results:

\begin{minted}{felix}
proc consumer (inp: %<int) () {
  while true do
    var y = read inp;
    println y;
  done
}
\end{minted}

The first two coroutines are pure because they depend only on their
arguments, and interact with the outside world entirely through 
synchronous channels. The do not modify variables in their environment,
and they do not depend on variables in their environment. The consumer,
however, has a side effect, namely printing values to standard output.

Purity is an important property which provide modularity and encapsulation and allows
one to reason about them locally. This is a vital information hiding property which is also
possessed by pure functions, where it is known as functional abstraction. For coroutines,
we would call this cofunctional abstraction, however there's a problem: functions are
abstracted to function types. However the behaviour of a coroutines depend not just
on the data type of the channels, but also on the order in which operations
are performed on these channels, and that information should be approximated
and symbolised by a {\em control type}. Alas, we do not have a suitable type
system.

Now, let us see how we can use these coroutines in the obviously
intended way! First we have to make some channels to connect
the devices:

\begin{minted}{felix}
proc doit () {
  var ich1, och1 = mk_ioschannel_pair[int]();
  var ich2, och2 = mk_ioschannel_pair[int]();
\end{minted}

Note, we have only created two channels here! But we have
made two interfaces to the same channel, the first input,
and the second output.

Now we can connect the devices to the channels:

\begin{minted}{felix}
  var p = producer och1;
  var t = transducer (ich1, och2);
  var c = consumer (ich2);
\end{minted}

We have created procedure closures which bind the channel arguments
to the procedures so that now the three closures all have the type
\verb%unit->void% which is required for the next step, spawning
the coroutines to create active fibres:

\begin{minted}{felix}
  spawn_fthread p;
  spawn_fthread t;
  spawn_fthread c;
}
doit();
\end{minted}

What we have done here is spawn three fibres which then communicate
via the connected channels. The configuration in a series is called
a pipeline and corresponds directly to functional composition.

Now you may wonder, how does it all end? What happens is that
when the producer terminates, the transducer tries to read a value
which is never going to come. The transducer is said to starve.
The consumer also waits forever for a value from the transducer
which is never going to come, because the transducer is starving,
so the consumer also starves.

It is also possible for a coroutine to block. This happens when
it tries to write a value which will never be read. Lets modify
our example to see: an infinite production stream:

\begin{minted}{felix}
proc producer (out: %>int) () {
  var i = 0;
  while true do
    write (out, i);
    ++i;
  done
}
\end{minted}

but a limited sample of data are printed:

\begin{minted}{felix}
proc consumer (inp: %<int) () {
  for i in 0..<10 do
    var y = read inp;
    println y;
  done
}
\end{minted}

Now, the transducer blocks when the consumer terminates, and thus
the producer blocks because the transducer has.

The astute programmer will have a number of questions!
When a pre-emptive thread starves of blocks, it is a serious
problem. Have we made a mistake with our fibres?

Here, you start on your journey to a major paradigm shift!
Blockage and starvation are not an error with coroutines,
its normal, expected, and desirable! This is, in fact,
the main way that we organise termination!


Before I can explain this, however, I have to back step a bit!

Felix runs a garbage collector similar to most functional programming
languages. What a collector does is maintain a specified set of root
objects, and finds all the objects to which there is a pointer
in one of the roots. It then expands the set to include all the objects
for which there is a pointer in one of those objects, and so on.
If an object A has a pointer to an object B, we say B is directly
reachable from A. If B then has a pointer to C, then C is said to be
reachable from A, by first visiting B. The complete set of objects
reachable from the designated roots is the transitive closure of the
reachability relation. The other objects which are not reachable
are garbage and are deleted. There's no way to refer to such an object,
since there are no pointers to it in the roots, or any object reachable
from the root.

Now, the secret of Felix coroutines is as follows: when you spawn
a coroutine, the resulting fibre is reachable by the system,
but it is NOT reachable from the caller. There is no "thread-id"
returned when a coroutine is spawned, if you want to communicate
with it you have to use a channel.

Now what happens is very simple but you will have to concentrate
to get it! Coroutines passed channels can reach the channel.
Any procedure which stores the channel can reach the channel.
But the channel is an object and initially it can't reach anything.
However when a coroutine performs I/O on the channel it can be
suspended. If a read is done, and there is not yet a matching write,
the fibre is suspended by adding it to the channel. Now the channel
can reach the fibre. At the same time the system {\em forgets} the
fibre. The system keeps a list of active fibres, but a suspended
fibre is not active so it is forgotten.

A read operation is matched by a write, and a write operation
is matched by a read. When a matching I/O operation is performed
on a channel it means that the other operation that matches it
has already been performed by another fibre. In this case,
the channel forgets that fibre, and {\em both} that fibre and the
one performing the matching operation become active and reachable
by the system.

When fibres synchronise with matching I/O operations, both become
active but only one actually starts executing. Which one is 
{\em indeterminate}. Felix always runs the reader first, but
in the abstract semantics you are not allowed to know that.
Indeterminacy is as close to concurrency as we can get with
a sequential program and its vital not only for optimisation,
but to ensure the programmer does not get bogged down depending
on implementation details.

So now that you understand reachability, you will begin to 
understand what happens when a fibre starves. Provided there
is no active fibre which can reach the channel, then since
the only object which can reach the fibre is the channel,
which is unreachable, the starving fibre is also unreachable.
So it is garbage collected!

Note {\em very carefully} that it is {\em absolutely essential}
that channels only be reachable by those that wil use them.
Go back and look carefully at the \verb%doit% procedure:

\begin{minted}{felix}
proc doit () {
  var ich1, och1 = mk_ioschannel_pair[int]();
  var ich2, och2 = mk_ioschannel_pair[int]();
  var p = producer och1;
  var t = transducer (ich1, och2);
  var c = consumer (ich2);
  spawn_fthread p;
  spawn_fthread t;
  spawn_fthread c;
}
doit();
\end{minted}

The four channel end points are known to this procedure, so whilst
this procedure is active, those channels are reachable. Indeed
the three closures \verb%p,t,c% are bound to these channels,
and the procedure knows them too. So the fibres spawned by this
procedure are reachable whilst the procedure itself is active.

Now, when you spawn a fibre, what happens? Does the spawned fibre
run immediately, or does the spawning procedure continue?

Did you guess? In the abstract semantics, it is indeterminate!
You're not allowed to design code that depends on which one runs
first. In Felix, the spawned procedure runs first, but that's an
implementation detail!

So what happens here is that sometime or other, the procedure
will return, and the channels it could reach will no longer be
reachable because the procedure itself is no longer reachable.

And then, the procedure's data frame will be reaped by the collector,
and, when the spawned fibres finally terminate, starve or block, they will
also be reaped.

If you're getting the picture you may well wonder how the program
as a whole terminates, and the answer is: in Felix the mainline
is a coroutine! It is not a subroutine. In fact in Felix,
all subroutines are, in the abstract, coroutines. The normal
procedural subroutines are just coroutines that do not do channel I/O.


\chapter{Advantage of coroutines}
You may wonder why bother with coroutines? What's wrong with
ordinary functions and procedures?

The answer is: in the right context, functions and procedures
are very useful. But they're a lot weaker than you think.
Coroutines are to be treated as another technique, not a replacement
for other techniques.

We will example a critical case which shows beyond doubt
that your conceptions about how great functional programming
is are completely misplaced. Functional programming is great for
functions but not work so well when dealing with non termination
or partial functions. In fact, it is so weak that the so called
functional programming paradigm can be considered totally discreted
along with object orientation.

These system has a shared fault: the subroutine. Subroutines involve
a master slave relationship which skews your program design one
way or another, and no way is natural. Coroutines fix this problem
so you only use subroutines when they're natural. Coroutines provide
a peer to peer relationship when that is the best way to do things.

The example I will use requires you to pretend that something simple
could be more complicated and to envisage what that entails. 
I am going to use the classic functional programming function,
the fold and show that functional programming is evil, and fold is 
perfect example of what is wrong with functional programming!

There are many inductive data types which are commonly used in
programming: lists, binary trees, s-expressions, and others.
In fact all inductive data types are trees, lists are just
degenerate trees. Suppose we have some container which holds
integer values we want to add up. If the data type is inductive
an easy way to do this is to write a recurisve function that
scans the data structure, finds the integers, and adds up the
values.

If we want to do something more complicated than addition,
the order may matter. You're all familiar with breadth first
and depth first tree visitation. We can easily write these
using a function, and we can make the operation done a parameter.

And that's where it gets nasty. With functional programming, the
parameter is a callback and so it has no state. It cannot remember
the last integer sum to add to, so the visitor routine must organise
to pass it. Using parametric polymorphism the callback has the signature
\[Element -> State -> State\]

This is really ugly if the state is complicated. Consider that you might
be constructing one data structure from another incrementally, then trying
to keep up with where you're up to can be very difficult. To see how
bad this is consider the control inverse situation as you would use with
C++ iterators. Here the user routine is ordinary code that {\em pulls}
values from the visitor instead of the visitor {\em pushing} them.
This much better .. for the client routine, but it is a nightmare for
the visitor, which has to retain enough state so it can remember where
it is up to in the scan.

Which technique is the best? With functional programming the driver
function can be recursive which allows automatic management of
the state with control flow and local variables: the solution
isn't complete but it covers a lot of territory. With the iterator
based solution, the iterator is the callback instead or the client
operation: the client operation can be recursive.

So you see, in some circumstances the scanner should be
the master and the client code the slave, when the master is harder
to write. And when the client is harder, it should be the master,
and we use an iterator for the scanner. 

In Felix you can do both, but what do you do if {\em both} the scanner
and client code are complicated? Can you make them both masters?
Can you allow both to do recursion?

Oh yes, you can. You can use threads. Of course that is inefficient
and difficult in itself but it is the most commonly use technique
because most programming languages are badly designed. Just have a
look at how many threads Firefox uses to get an idea how bad the
situation is!

Both imperative and functional programming are {\em broken}.
Badly, very very badly broken.

We need two masters. You cannot do that with subroutines.

Oh yes! Coroutines are peers.

Here's the solution. It is universally superior to both
functional folds and iterators:

Write your scanner with functional programming techniques,
but replace the call to the client routine with a write operation.
Send the element data down a channel.

Now, write your client routine with iterator based techniques.
Use recursion if you like. But replace the call to the iterator get
the next value with a read on a channel.

Pipeline the scanner into the client routine. Done.

Why is it better? Because with this method there are {\em two}
stacks to hold local variables and to recurse on. So by using
two coroutines, you have a solution which is superior because it
eliminates the need for a stackless callback.


\chapter{Coroutine Semantics}
\section{Objects}
A coroutine system consists of the following types of objects:
\begin{description}
\item[Scheduler] A device to hold a set of active fibres and
select one to be current.
\item[Channels] An object to support synchronisation and data transfer.
\item[Fibres] A thread of control which can be suspended and resumed.
\item[Continuations] An object representing the future of a coroutine.
\end{description}

\subsection{Scheduler States}
A scheduler is in one of two states:
\begin{description}
\item[Current] The currently running scheduler
\item[Suspended] A scheduler for which the Running fibre is
executing another scheduler.
\end{description}

\subsection{Fibre States}
Each fibre is in one of these states:
\begin{description}
\item[Running] Exactly one fibre per scheduler is always running.
\item[Active] Fibes which are ready to run but not running on a particular scheduler.
\item[Hungry] Fibres suspended waiting for input on a channel.
\item[Blocked] Fibres suspended waiting to perform output on a channel.
\end{description}

\subsection{Channel States}
Each channel is in one of these states:
\begin{description}
\item[Empty] There are no fibres associated with the channel.
\item[Hungry] A set of hungry fibres are waiting for input on the channel.
\item[Blocked] A set of blocked fibres are waiting to perform output on the channel.
\end{description}


\section{Abstract State}
\subsection{State Data by Sets}
A fibration system consists of 
\begin{enumerate}
\item A set of fibres $\mathcal F$
\item A set of channels $\mathcal C$
\item An integer $k$
\item An indexed set of schedulers $\mathcal S= \{s_i\}{\rm\ for\ }i=1 {\rm\ to\ }k$  
\end{enumerate}
and the following relations:
\begin{enumerate}
\item for each $i=1 {\rm\ to\ }k$ a pair $(R_i, \mathcal A_i)$ where $R_i$ is a fibre
and $\mathcal A_i$ is a set of fibres, these fibres being associated with
scheduler $s_i$, $R_i$ is the currently Running fibre of the scheduler,
and $\mathcal A_i$ is the set of Active fibres;
\item for each channel $c$ a set $\mathcal H_c$ of Hungry fibres
and a set $\mathcal B_c$ of Blocked fibres, such that one of these sets
is empty, if both sets are empty, the channel is said to be Empty,
otherwise it is said to be Hungry or Blocked depending on whether
the Hungry or Blocked set is nonempty;

\item A reachability relation to be described below
\end{enumerate}
with the requirement that each fibre is in precisely one of the sets $\{R_i\}$,
$A_i$, $H_c$ or $B_c$.

We define the relation 
\begin{align}
\mathrel H &= \{(f,c) \mid f \in \mathrel H_c\}&\rm Hunger\\
\mathrel B &= \{(f,c) \mid f \in \mathrel B_c\}&\rm Blockage\\
\mathcal F_{\mathcal H} &= \{f \mid \exists c . (f,c) \in \mathcal H\}&\rm Hungry\ Fibres\\
\mathcal F_{\mathcal B} &= \{f \mid \exists c . (f,c) \in \mathcal B\}&\rm Blocked\ Fibres\\
\mathcal C_{\mathcal H} &= \{ c \mid \exists f . (f,c) \in \mathcal H\}&\rm Hungry\ Channels\\
\mathcal C_{\mathcal B} &= \{ c \mid \exists f . (f,c) \in \mathcal B\}&\rm Blocked\ Channels\\
\mathcal E &= \{c \mid | \mathcal H_c = \mathcal B_c = \emptyset \}&\rm Empty\ Channels
\end{align}

\subsection{State Data by ML}
Using an ML like description may make the state data easier
to visualise.

\begin{minted}{felix}
scheduler =
  Run: fibre | NULL, 
  Active: Set[fibre]

channel = 
  | Empty 
  | Hungry: NonemptySet[fibre]
  | Blocked: NonemptySet[fibre]

fibre = (current: continuation)

continuation = 
  caller: continuation | NULL,
  PC: codeaddress,
  local: data
\end{minted}

\section{Operations}

\subsection{Spawn} 
The spawn operation takes as an argument a unit procedure and makes
a closure thereof the initial continuation
of a new fibre.  Of the pair consisting of the currently running
fibre (the spawner) and the new fibre (the spawnee) one will have Active
state and the other will be Running. It is not specified which
of the pair is Running.

\begin{equation}
{\mathcal F} \leftarrow {\mathcal F} \cup \{f\}
\end{equation}

where f is a fresh fibre and

\begin{equation}
R_k,{\mathcal A_k} \leftarrow
\begin{cases}
R_k,{\mathcal A_k} \cup \{f\} \\
f,{\mathcal A_k} \cup \{R_s\} \\
\end{cases}
\end{equation}

where the choice between the two cases is indeterminate.

\subsection{Run} 
The run operation is a subroutine. It increments $k$ and creates
a new scheduler $s_k$. The scheduler $s_{k-1}$ is Suspended. 

\begin{equation}
k \leftarrow k + 1
\end{equation}


It then takes as an argument a unit procedure and makes
a closure thereof the initial continuation
of a new fibre $f$ and makes that the running fibre $R_k$ of
the new current scheduler. The set of active fibres $A_k$
is set to $\emptyset$. 

 
\begin{equation}
{\mathcal F} \leftarrow {\mathcal F} \cup \{f\}
\end{equation}

where f is a fresh fibre and

\begin{equation}
R_k,\mathcal A_k \leftarrow
f,\emptyset
\end{equation}

The scheduler is then run as a subroutine. It returns when there
is no running fibre, which implies also there are no active
fibres left. $k$ is then decremented, scheduler $s_k$ again becomes Current, 
and the the
current continuation of its running fibre resumes.
\begin{equation}
k \leftarrow k - 1
\end{equation}

\subsection{Create channel}
A function which creates a channel.

\begin{align}
{\mathcal C} \leftarrow {\mathcal C} \cup \{c\}\\
{\mathcal E} \leftarrow {\mathcal E} \cup \{c\}
\end{align}
where c is a fresh channel.

\subsection{Read}
The read operation from fibre $r$ takes as an argument a channel $c$.

\begin{enumerate}
\item If the channel is Empty, the Running fibre performing the read
changes state to Hungry, the channel changes state to Hungry,
and the fibre is associated with the channel.
\begin{align}
{\mathcal H}&\leftarrow {\mathcal H} \cup \{(r,c)\}\\
{\mathcal E} &\leftarrow {\mathcal E} \setminus \{c\}
\end{align}

If there are no active fibres, the program terminates,
otherwise the scheduler selects an Active fibre and
changes its state to Running.  It is not specified which active 
fibre is chosen.

\begin{equation}
R_k,{\mathcal A_k} \leftarrow
\begin{cases}
\epsilon,{\mathcal A_k}& {\rm if\ } A_k=\emptyset \\
a,{\mathcal A_k} \setminus \{a\} & {\rm some\ } a\in A
\end{cases}
\end{equation}


\item If the channel is Hungry, the Running fibre changes state
to Hungry, and the fibre is associated with the channel.

\begin{align}
{\mathcal H}&\leftarrow {\mathcal H} \cup \{(r,c)\}\\
\end{align}

If there are no active fibres, the program terminates,
otherwise the scheduler selects an Active fibre and
changes its state to Running.  It is not specified which active 
fibre is chosen.

\begin{equation}
R_k,{\mathcal A_k} \leftarrow
\begin{cases}
\epsilon,{\mathcal A_k}& {\rm if} A_k=\emptyset \\
a,{\mathcal A_k} \setminus \{a\} & {\rm some\ } a\in A_k
\end{cases}
\end{equation}


\item If the channel is Blocked, one of the associated Blocked fibres $w$
is selected, and dissociated from the channel. 

\begin{equation}
{\mathcal B} \leftarrow {\mathcal B}\setminus (w,c)\\ 
\end{equation}

Of these two
fibres, one is changed to state Active and the other to Running.
It is not specified which fibre is chosen to be Running.

\begin{equation}
R_k,{\mathcal A_k} \leftarrow
\begin{cases}
R_k,{\mathcal A_k} \cup \{w\} \\
w,{\mathcal A_k} \cup \{R\} \\
\end{cases}
\end{equation}

The value supplied to the write operation of the Blocked
fibre will be pass to the Hungry fibre when it transitions
to Running state.


\end{enumerate}



\subsection{Write}
The write operation performed by fibre $w$ takes two arguments, a channel and a value
to be written.

\begin{enumerate}
\item If the channel is Empty, the Running fibre performing the write
changes state to Blocked, the channel changes state to Blocked,
and the fibre is associated with the channel.
\begin{align}
{\mathcal B}&\leftarrow {\mathcal B} \cup \{(w,c)\}\\
{\mathcal E} &\leftarrow {\mathcal E} \setminus \{c\}
\end{align}


If there are no active fibres, the program terminates,
otherwise the scheduler selects an Active fibre and
changes its state to Running.  It is not specified which active 
fibre is chosen.

\begin{equation}
R_k,{\mathcal A_k} \leftarrow
\begin{cases}
\epsilon,{\mathcal A_k}& {\rm if\ } A_k=\emptyset \\
a,{\mathcal A_k} \setminus \{a\} & {\rm some\ } a\in A
\end{cases}
\end{equation}


\item If the channel is Blocked, the Running fibre changes state
to Blocked, and the fibre is associated with the channel.

\begin{align}
{\mathcal B}&\leftarrow {\mathcal B} \cup \{(w,c)\}\\
\end{align}


If there are no active fibres, the program terminates,
otherwise the scheduler selects an Active fibre and
changes its state to Running.  It is not specified which active 
fibre is chosen.

\begin{equation}
R_k,{\mathcal A_k} \leftarrow
\begin{cases}
\epsilon,{\mathcal A_k}& {\rm if\ } A_k=\emptyset \\
a,{\mathcal A_k} \setminus \{a\} & {\rm some\ } a\in A
\end{cases}
\end{equation}


\item If the channel is Hungry, one of the associated Hungry fibres $r$
is selected, and dissociated from the channel.

\begin{equation}
{\mathcal H} \leftarrow {\mathcal H}\setminus (r,c)\\ 
\end{equation}


Of these two
fibres, one is changed to state Active and the other to Running.
It is not specified which fibre is chosen to be Running.

\begin{equation}
R_k,{\mathcal A_k} \leftarrow
\begin{cases}
R_k,{\mathcal A_k} \cup \{r\} \\
r,{\mathcal A_k} \cup \{R\} \\
\end{cases}
\end{equation}


The value supplied by the write operation of the Blocked
fibre will be pass to the Hungry fibre when it transitions
to Running state.
\end{enumerate}

\subsection{Reachability}
The Running, and, each Active fibre and its associated call chain of 
continuations are deemed to be Reachable.

If a channel is known to reachable fibre, it is also reachable.
A channel may be known because its address is stored in the local
data of a continuation of a fibre, or, it is reachable via some object
which can be reached from local data. The exact rules are 
programming language dependent.

Each fibre associated with a reachable channel is reachable.

The transitive closure of the reachability relation consists
of a closed, finite, collection or channels and fibres which
are reachable.

Unreachable fibres and channels are automtically garbage
collected.

\subsection{Elimination}
Fibres and channels are eliminated when they are 
no longer reachable.

A fibre may become unreachable in three ways.

\subsubsection{Suicide}
A fibre for which the initial continuation returns is said to be
dead, and  becomes unreachable. If there are no longer any Active fibres,
the program returns, otherwise the scheduler picks
one Active fibre and changes its state to Running.

\subsubsection{Starvation}
A fibre in the Hungry state becomes unreachable when the
channel on which it is waiting becomes unreachable.

\subsubsection{Blockage}
A fibre in the Blocked state becomes unreachable 
when the channel on which it is waiting becomes unreachable.

\section{LiveLock}
If a fibre is Hungry (or Blocked) on a reachable channel
but no future Running fibre will write (or read) that
channel, the fibre is said to be livelocked. The fibre
will never proceed but it cannot be removed from
the system because it is reachable via the channel.

A livelock is considered to transition to a deadlock
if the channel becomes unreachable, in which case
the fibre will becomes unreachable and is said to
die through Starvation (or Blockage),
disolving the deadlock. In other words, fibres cannot deadlock.


\section{Fibre Structure}
Each fibre consists of a single current continuation.
Each continuation may have an associated continuation
known as its caller. The initial continuation of a freshly
spawned fibre has no caller.

The closure of the caller relation leads to a linear
sequence of continuations starting with the current
continuation and ending with the initial continuation
of a freshly spawned fibre.

The main program consists of an initially Running
fibre with a specified initial continuation.

Continuations have the usual operations of a procedure.
They may return, call another procedure, spawn new
fibres, create channels, and read and write channels,
as well as the other usual operations of a procedure
in a general purpose programming language.

A continuation is reachable if it is the current
continuation of a reachable fibre, or the caller
of a reachable continuation.

A continuation is formed by calling a procedure,
which causes a data frame to be constructed which
contains the return address of the caller,
parameters and local variables of the procedure,
and a program counter containing the current
locus of control (code address) within the procedure.
The program counter is initially set to the specified
entry point of the procedure.

A coroutine is a procedure which directly or indirectly
performs channel I/O. Coroutines may be called by 
other coroutines, but not by procedures or functions.
Instead, a coroutine may be spawned by a procedure,
or run by a procedure or function. This creates a
fibre which hosts the created continuation.

Note: the set of fibres and channels created directly
or indirectly by a run subroutine called inside
a function should be isolated from all other fibres
and channels to ensure the function has no side-effects.



\section{Continuation Structure}
\subsection{Continuation Data}
A continuation has associated with it the following
data:

\begin{description}
\item[caller] Another continuation of the same fibre which is
suspended until this continuation returns.
\item[data frame] Sometimes called the stack frame, contains
local variables the continuation may access.
\item[program counter] A location in the program code representing
the current point of this continuations execution or suspension
\end{description}

\subsection{Continuation operations}
The current continuation of a fibre executes a wide range of
operations including channel I/O, spawning new fibres,
calling a procedure, and returning.

\begin{description}
\item[call] Calling a procedure creates a new continuation
with its program counter set at the procedure entry point,
and a fresh data frame. The new continuation becomes the
current continuation, the current continuation suspends.
The new continuations caller field is set to the caller.
The current continuation program counter is set
to the pointer after the call instruction.

The effect is push an entry onto the fibres continuation chain.

\item[return] Returning from the current continuation causes
the owning fibres current continuation to be set to the
current continuations caller, if one exists, or the 
fibre to be marked Dead if there is no caller. Execution
of the suspended caller continues at its program counter.

The effect is to pop an entry off the fibre's continuation chain.

\item[read/write] Channel I/O suspends the current continuation
of a fibre until a matching operation from another fibre
synchronises with it. A read is matched by a write, and a write
is matched by a read.
\end{description}

By the rules of state change, channel I/O should be viewed
as performing a peer to peer neutral exchange of control:
the current fibre becomes suspended without losing its position
and hands control to another fibre. Later, control is handed
back and the fibre continues.

Coroutine based systems, therefore, operate by repeated exchanges
of control accompanied by data transfers in a direction independent
of the control flow, which sets coroutines aside from functions.

\section{Events}
Each state transfer of the fibration system may be considered
an event. However the key events are
\begin{itemize}
\item spawning
\item suicide
\item entry to a read operation
\item return from a read operation
\item entry to a write operation
\item return from a write operation
\end{itemize}

I/O synchronisation consists of suspension on entry
to a read or write operation, and simultaneously release
of suspension, or resumption, on matching write or read.

I/O suspension occurs when a fibre becomes Hungry or Blocked,
and resumption when it becomes Running or Active.

Fibrated systems are characterised by a simple rule: events are
totally ordered. The order may not be determinate. 

\section{Control Type}
The control type of a coroutine is defined as follows.
We assume the coroutine is spawned as a fibre, and each
and every read request is satisfied by a random value of
the legal input type. Write requests are also satisfied.
We cojoin entry and return from read into a single read
event, and entry and return from write into a single
write event, since we are only interested in the behaviour
of the fibre.

The sequence of all possible events which the fibre
may exhibit is the coroutines control type. Note, the
control type is a property of the coroutine (procedure).

\section{Encoding Control Types}
In general, the control type of a coroutine can be quite
complex. However for special cases, a simple encoding
can be given.

\subsection{One shots}
A one-shot coutine is one that exhibits a bounded number
of events before suiciding. The three most common one
shots are:

\begin{description}
\item[Value: type W] A coroutine which writes a single value to
a channel and then exits.
\item[Result: type R] A coroutine which reads a single value to
from channel and then exits.
\item[Function: type RW] A couroutine which reads one value
from a channel, calculates an answer, writes that
down a channel and then exits.
\end{description}

\subsection{Continuous devices}
A continuous coroutine is one which does not exit.
It can therefore terminate only by starvation or blockage.
The three most common kinds of such devices are
\begin{description}
\item[Source: type W+] Writes a continuous stream of values
to a channel.
\item[Sink: type R+] Reads a continuous stream of values
from a channel.
\item[Transducer] Reads and writes.
\end{description}

Because the sequence of events is a stream, we may use
convenient notations to describe control types.
If possible, a regular expression will be used.
Sometimes, a grammar will be required. In other cases
there is no simple notation for the behaviour of a coroutine.

We will use postfix \verb%+% for repetition.
 
\subsection{Transducer Types}
A transducer which read a value, write a value, then loops
back and repeats is called a {\em functional transducer},
it may be given the type (RW)+.

In a functional language, a partial function has no natural
encoding. There are two common solutions. The first is to
return an option type, say Some v, if there is a result,
or None if there is not. This solution involves modifying
the codomain. The other solution is to restrict the domain so
that the subroutine is a function.

Coroutines, however, represent partial functions naturally.
If a value is read for which there is no result, none is written!
The type of a {\em partial function transducer} is therefore
given by ((R+)W)+, in other words multiple reads may occur
for each write. Note that two writes may not occur in succession.

This type may also be applied to many other coroutines,
for example the list filter higher order function.

\subsection{Duality}
Coroutines are dual to functions. The core difference is that
they operate in time not space. Thus, in the dual space
a spatial product type becomes a temporal sequence.

Coroutines are ideal for processing streams. Whereas
function code cannot construct streams without laziness,
and cannot deconstruct them without eagerness, coroutines
are neither eager nor lazy.

One may view an eager functional application as driving a
value into a function to get a result, and a lazy application
as pulling a value into a function. Pushing value implies
eagerly evaluating it, pulling implies the value is calculated
on demand.

Coroutine simultaneously push and pull values across channels
and so eliminate the evaluation model dichotomy that plagues
functional programming. This coherence does not come for
free: it is replaced by indeterminate event ordering.

\section{Composition}
By far the biggest advantage of coroutine modelling is the 
ultimate flexibility of composition. Coroutines provide
far better modularity and reusability than functions,
but this comes at the price of complexity. You will observe
considerably more housekeeping is required to compose
coroutines than procedures or functions, because, simply,
there are more way to compose them.

A collection of coroutines can be regarded as black boxes
resembling chips on a circuit board, with the wires
connecting pins representing channels. So instead of using
variables and binding constructions, we can construct more
or less arbitrary networks.

\subsection{Pipelines}
The simplest kind of composition is the pipeline. It is a sequence
of transduces wired together with the output of one transducer
connected by a channel to the input of the next.

If the pipeline consists entirely of transducers is is an open
pipeline. If there is a source at one end and a sink at the other
it is a closed pipeline. Partially open pipelines can also exist.

The composition of two transducers has a type dependent on
the left and right transducer types. 

With a functional transducer, you would expect the composition
of (R1W1)+ with (R2W2)+ to be (R1W2)+ but this is not the case!

Consider, the left transducer performs R1, then W1, then right
performs R2. At this point it is not determinate whether left
or right proceeds. If left proceeds, we have R1 again, then W1.
then right proceeds and performs W2 before coming back to read R2,
and what happens next is again indeterminate. The sequence is
therefore R1, W1/R2, R1, W1/R2 which shows R1 can be read twice
before W2 is observed. We have written w/r here to indicate synchronised
events which are abstracted away when describing the observable
behaviour of the composite.

Clearly, (R1?R1W2?W2)+ contains the set of possible event sequences,
but then (R1+R2+)+ contains it, and therefore the set of possible
event sequences as well. So we should seek the most precise, or
{\em principal} type of the composite.

We can calculate the type from the operational semantics.
At any point in time, the system must be in one of a finite
number of states. Where we have indeterminacy, the transitions
out of a given state are not fully specified. The result is
clearly a non-deterministic finite state automaton.

We must observe, such an automaton corresponds to (one or more) 
larger deterministic finite state automata. This is an important
result because it has practical implications: it means we can
pick a DFA and use it to optimise away abstracted synchronisation
points. In other words, we build a fast model of the system
by inlining and using shared variables instead of channels,
and then eliminate the variables by functional composition.

This is the primary reason we insist on indeterminate behaviour:
it allows composition to be subject to a reduction calculus.

\section{Felix Implementation}
The following functions and procedures are provided in Felix:

\begin{minted}{felix}
spawn_fthread: (1 -> 0) -> 0;
run: (1 -> 0) -> 0;
mk_ioschannel_pair[T]: 1 -> ischannel[T] * oschannel[T];
read[T]: ischannel[T] -> T
write[T]: oschannel[T] * T -> 0
\end{minted}

In the abstract, channels are bidirectional and untyped.
However we will restrict our attention to channels
typed to support either read (ischannel) or write (oschannel)
of a value of a fixed data type.

The following shorthand types are available:

\begin{minted}{felix}
%<T    ischannel[T]
%>T    oschannel[T]
\end{minted}

More advanced typing exploiting channel capabilities are
discussed later.

Simple example program:

\begin{minted}{felix}
proc demo () {
  var inp, out = mk_ioschannel_pair[int]();

  proc source () {
    for i in 1..10 perform write (out,i);
  }

  proc sink () {
    while true do
      var j = read inp;
      println$ j;
    done
  }

  spawn_fthread source;
  spawn_fthread sink;
}
demo();
\end{minted}

In this program, we create a channel with an input and
output end typed to transfer an int. The source coroutine
writes the integers from 1 through to 10 inclusive to
the write end of the channel, the sink coroutine
reads integers from the channel and prints them.

The main fibre calls the demo procedure which launches
two fibres with initial continuations the closures of
the source and sink procedures.

When demo returns, the main fibre's current continuation
no longer knows the channel, so the channel is not reachable
from the main fibre. 

The source coroutine returns after sending 10 integers to
the sink via the channel.  When a fibre no longer has
a current continuation, returning to the non-existent
caller causes the fibre to no longer have a legal
state. This is known as suicide.

After the sink has read the 
last value, it becomes permanently Hungry. The sink 
procedure dies by starvation.

All fibres which die do so either by suicide, starvation,
or blockage. Dead fibres will be reaped by the garbage
collector provided they're unreachable. It is important
for the creator of fibres and their connecting channels
to forget the channels to ensure this occurs.

Unlike typical pre-emptive threading systems, deadlock
is not an error. However a lock up which should lead to
reaping of fibres but which fails to do so because
they remain reachable is univerally an error. This is
known as a livelock: it leads to zombie fibres.

This usually occurs because some other fibre is statically
capable of resolving the lockup, but does not do so 
dynamically. To prevent livelocks, variables holding
channel values to which no I/O will occur dynamically
should also go out of scope.
 
\end{document}
