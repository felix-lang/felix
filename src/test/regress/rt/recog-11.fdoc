@title lazy recogniser
@felix
include "std/strings/recognisers";
include "std/strings/parsers";
open Recognisers;
open Grammars;
open Parsers;

// silly sample grammar, right associative operators +, * ^ parens () and 
// value 9 only
fun strng (s:string) => Terminal[prod_t] (s, match_string s);

var xprod = Alt([
  Seq ([Nonterminal[prod_t] "term", strng "+", Nonterminal[prod_t] "expr"]),
  Nonterminal[prod_t] "term"]);
   
var tprod = Alt ([
  Seq ([Nonterminal[prod_t] "factor", strng "*", Nonterminal[prod_t] "term"]),
  Nonterminal[prod_t] "factor"]);

var fprod = Alt ([Seq ([Nonterminal[prod_t] "atom", strng "^", Nonterminal[prod_t] "factor"]),
  Nonterminal[prod_t] "atom"]);

var atom = Alt ([
  Seq ([strng "(", Nonterminal[prod_t] "expr", strng ")"]),
  strng "9"]);


// library
var xlib = ([
  ("expr",xprod),
  ("term",tprod),
  ("factor",fprod),
  ("atom",atom)
]);

println$ "Xlib=" + xlib.str;

var clx = closure ("expr",xlib);
println$ "Closure="  + clx.str;


var gri,gwi = mk_ioschannel_pair[grammar_t]();
var gro,gwo = mk_ioschannel_pair[recog_t]();
spawn_fthread (make_recogniser_from_grammar (inp=gri,out=gwo));
write (gwi, ("expr",xlib));
var parsr = read gro;
println$ "Got parser";

var test = "9+9*9^(9+9)";
var b = Buffer test;
var ri,wi = mk_ioschannel_pair[Buffer]();
var ro,wo = mk_ioschannel_pair[Buffer]();
spawn_fthread (parsr (inp=ri, out=wo));
write (wi,b);
spawn_fthread { 
  while true do
    var result = read ro;
    println$ "Test1: End pos (should be 11)=" + result.str;
  done
};
@expect
Xlib=list((expr, [(term "+" expr) | term]), (term, [(factor "*" term) | factor]), (factor, [(atom "^" factor) | atom]), (atom, [("(" expr ")") | "9"]))
Closure=list('atom', 'factor', 'term', 'expr')
Got parser
Test1: End pos (should be 11)=@1
Test1: End pos (should be 11)=@3
Test1: End pos (should be 11)=@5
Test1: End pos (should be 11)=@11
@
