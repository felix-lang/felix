//$ This file contains a huge set of operators from TeX, AMSTeX and LaTeX.
// 
//$ The precedence classification is currently very crude.
//$ Some operators are duplicate semantics with different names.
//$ Some are negations, and should be handled properly.
//$
//$ Nouns such as Greek letters are not included because they're atoms and don't
//$ need any parsing.
//$
syntax texsyms {

// A

  bin := "\amalg" =># '(nos _1)'; 
  cmp := "\approx" =># '(nos _1)'; 
  cmp := "\approxeq" =># '(nos _1)'; 
  cmp := "\Arrowvert" =># '(nos _1)'; 
  cmp := "\arrowvert" =># '(nos _1)'; 
  cmp := "\asymp" =># '(nos _1)'; 

// B

  cmp := "\backsim" =># '(nos _1)'; 
  cmp := "\backsimeq" =># '(nos _1)'; 
  cmp := "\bar" =># '(nos _1)'; 
  cmp := "\barwedge" =># '(nos _1)'; 
  cmp := "\between" =># '(nos _1)'; 
  bin := "\bigcap" =># '(nos _1)'; 
  bin := "\bigcirc" =># '(nos _1)'; 
  bin := "\bigcup" =># '(nos _1)'; 
  bin := "\bigodot" =># '(nos _1)'; 
  bin := "\bigoplus" =># '(nos _1)'; 
  bin := "\bigotimes" =># '(nos _1)'; 
  bin := "\bigsqcup" =># '(nos _1)'; 
  bin := "\bigtriangledown" =># '(nos _1)'; 
  bin := "\bigtriangleup" =># '(nos _1)'; 
  bin := "\biguplus" =># '(nos _1)'; 
  bin := "\bigvee" =># '(nos _1)'; 
  bin := "\bigwedge" =># '(nos _1)'; 
  bin := "\bowtie" =># '(nos _1)'; 
  bin := "\Box" =># '(nos _1)'; 
  bin := "\boxdot" =># '(nos _1)'; 
  bin := "\boxminus" =># '(nos _1)'; 
  bin := "\boxplus" =># '(nos _1)'; 
  bin := "\boxtimes" =># '(nos _1)'; 
  cmp := "\Bumpeq" =># '(nos _1)'; 
  cmp := "\bumpeq" =># '(nos _1)'; 

// C

  bin := "\Cap" =># '(nos _1)'; 
  bin := "\cdot" =># '(nos _1)'; 
  bin := "\cdotp" =># '(nos _1)'; 
  cmp := "\circeq" =># '(nos _1)'; 
  bin := "\circledast" =># '(nos _1)'; 
  bin := "\circledcirc" =># '(nos _1)'; 
  bin := "\circleddash" =># '(nos _1)'; 
  cmp := "\cong" =># '(nos _1)'; 
  bin := "\coprod" =># '(nos _1)'; 
  bin := "\Cup" =># '(nos _1)'; 
  cmp := "\curlyeqprec" =># '(nos _1)'; 
  cmp := "\curlyeqsucc" =># '(nos _1)'; 
  bin := "\curlyvee" =># '(nos _1)'; 
  bin := "\curlywedge" =># '(nos _1)'; 

// D

  arr := "\dashleftarrow" =># '(nos _1)'; 
  arr := "\dashrightarrow" =># '(nos _1)'; 
  bin := "\divideontimes" =># '(nos _1)'; 
  cmp := "\doteq" =># '(nos _1)'; 
  cmp := "\Doteq" =># '(nos _1)'; 
  cmp := "\doteqdot" =># '(nos _1)'; 
  bin := "\dotplus" =># '(nos _1)'; 
  bin := "\doublebarwedge" =># '(nos _1)'; 
  bin := "\doublecap" =># '(nos _1)'; 
  bin := "\doublecup" =># '(nos _1)'; 
  bin := "\Downarrow" =># '(nos _1)'; 
  bin := "\downarrow" =># '(nos _1)'; 
  bin := "\downdownarrows" =># '(nos _1)'; 
  bin := "\downharpoonleft" =># '(nos _1)'; 
  bin := "\downharpoonright" =># '(nos _1)'; 

// E

  cmp := "\eqcirc" =># '(nos _1)'; 
  cmp := "\eqsim" =># '(nos _1)'; 
  cmp := "\eqslantgtr" =># '(nos _1)'; 
  cmp := "\eqslantless" =># '(nos _1)'; 
  cmp := "\equiv" =># '(nos _1)'; 

// F

  bin := "\fallingdotseq" =># '(nos _1)'; 

// G

  cmp := "\geqslant" =># '(nos _1)'; 
  arr := "\gets" =># '(nos _1)'; 
  cmp := "\gg" =># '(nos _1)'; 
  cmp := "\ggg" =># '(nos _1)'; 
  cmp := "\gggtr" =># '(nos _1)'; 
  cmp := "\gnapprox" =># '(nos _1)'; 
  cmp := "\gnsim" =># '(nos _1)'; 
  cmp := "\gtrapprox" =># '(nos _1)'; 
  cmp := "\gtrdot" =># '(nos _1)'; 
  cmp := "\gtreqless" =># '(nos _1)'; 
  cmp := "\gtreqqless" =># '(nos _1)'; 
  cmp := "\gtrless" =># '(nos _1)'; 
  cmp := "\gtrsim" =># '(nos _1)'; 
  cmp := "\gvertneqq" =># '(nos _1)'; 

// H

  arr := "\hookleftarrow" =># '(nos _1)'; 
  arr := "\hookrightarrow" =># '(nos _1)'; 

// I

// J

  bin := "\Join" =># '(nos _1)'; 

// K

// L

  arr := "\leadsto" =># '(nos _1)'; 
  arr := "\Leftarrow" =># '(nos _1)'; 
  arr := "\leftarrow" =># '(nos _1)'; 
  arr := "\leftarrowtail" =># '(nos _1)'; 
  arr := "\leftharpoondown" =># '(nos _1)'; 
  arr := "\leftharpoonup" =># '(nos _1)'; 
  arr := "\leftleftarrows" =># '(nos _1)'; 
  arr := "\Leftrightarrow" =># '(nos _1)'; 
  arr := "\leftrightarrow" =># '(nos _1)'; 
  cmp := "\leftrightarrows" =># '(nos _1)'; 
  cmp := "\leftrightharpoons" =># '(nos _1)'; 
  arr := "\leftrightsquigarrow" =># '(nos _1)'; 
  cmp := "\leqslant" =># '(nos _1)'; 
  cmp := "\lessapprox" =># '(nos _1)'; 
  cmp := "\lessdot" =># '(nos _1)'; 
  cmp := "\lesseqgtr" =># '(nos _1)'; 
  cmp := "\lesseqqgtr" =># '(nos _1)'; 
  cmp := "\lessgtr" =># '(nos _1)'; 
  cmp := "\lesssim" =># '(nos _1)'; 
  arr := "\Lleftarrow" =># '(nos _1)'; 
  cmp := "\lll" =># '(nos _1)'; 
  cmp := "\llless" =># '(nos _1)'; 
  cmp := "\lnapprox" =># '(nos _1)'; 
  cmp := "\lnot" =># '(nos _1)'; 
  cmp := "\lnsim" =># '(nos _1)'; 
  arr := "\Longleftarrow" =># '(nos _1)'; 
  arr := "\longleftarrow" =># '(nos _1)'; 
  arr := "\Longleftrightarrow" =># '(nos _1)'; 
  arr := "\longleftrightarrow" =># '(nos _1)'; 
  arr := "\longmapsto" =># '(nos _1)'; 
  arr := "\Longrightarrow" =># '(nos _1)'; 
  arr := "\longrightarrow" =># '(nos _1)'; 
  cmp := "\ltimes" =># '(nos _1)'; 
  cmp := "\lvertneqq" =># '(nos _1)'; 

// M

  arr := "\mapsto" =># '(nos _1)'; 

// N

  cmp := "\ncong" =># '(nos _1)'; 
  cmp := "\ngeqslant" =># '(nos _1)'; 
  cmp := "\ni" =># '(nos _1)'; 
  cmp := "\nleqslant" =># '(nos _1)'; 
  cmp := "\nparallel" =># '(nos _1)'; 
  cmp := "\nprec" =># '(nos _1)'; 
  cmp := "\npreceq" =># '(nos _1)'; 
  cmp := "\nsim" =># '(nos _1)'; 
  cmp := "\nsucc" =># '(nos _1)'; 
  cmp := "\nsucceq" =># '(nos _1)'; 
  cmp := "\ntriangleleft" =># '(nos _1)'; 
  cmp := "\ntrianglelefteq" =># '(nos _1)'; 
  cmp := "\ntriangleright" =># '(nos _1)'; 
  cmp := "\ntrianglerighteq" =># '(nos _1)'; 

// O

  bin := "\odot" =># '(nos _1)'; 
  bin := "\ominus" =># '(nos _1)'; 
  bin := "\oplus" =># '(nos _1)'; 
  bin := "\oslash" =># '(nos _1)'; 
  //bin := "\otimes" =># '(nos _1)'; 

// P

  cmp := "\perp" =># '(nos _1)'; 
  bin := "\pm" =># '(nos _1)'; 
  cmp := "\prec" =># '(nos _1)'; 
  cmp := "\precapprox" =># '(nos _1)'; 
  cmp := "\preccurlyeq" =># '(nos _1)'; 
  cmp := "\preceq" =># '(nos _1)'; 
  cmp := "\precnapprox" =># '(nos _1)'; 
  cmp := "\precneqq" =># '(nos _1)'; 
  cmp := "\precnsim" =># '(nos _1)'; 
  cmp := "\precsim" =># '(nos _1)'; 
  bin := "\prod" =># '(nos _1)'; 
  cmp := "\propto" =># '(nos _1)'; 

// Q

// R

  cmp := "\rhd" =># '(nos _1)'; 
  arr := "\Rightarrow" =># '(nos _1)'; 
  arr := "\rightarrow" =># '(nos _1)'; 
  arr := "\rightarrowtail" =># '(nos _1)'; 
  arr := "\rightharpoondown" =># '(nos _1)'; 
  arr := "\rightharpoonup" =># '(nos _1)'; 
  arr := "\rightleftarrows" =># '(nos _1)'; 
  arr := "\rightleftharpoons" =># '(nos _1)'; 
  arr := "\rightleftharpoons" =># '(nos _1)'; 
  arr := "\rightrightarrows" =># '(nos _1)'; 
  arr := "\rightsquigarrow" =># '(nos _1)'; 
  arr := "\Rrightarrow" =># '(nos _1)'; 
  cmp := "\rtimes" =># '(nos _1)'; 

// S

  bin := "\setminus" =># '(nos _1)'; 
  cmp := "\sim" =># '(nos _1)'; 
  cmp := "\simeq" =># '(nos _1)'; 
  cmp := "\smallsetminus" =># '(nos _1)'; 
  bin := "\sqcap" =># '(nos _1)'; 
  bin := "\sqcup" =># '(nos _1)'; 
  cmp := "\sqsubset" =># '(nos _1)'; 
  cmp := "\sqsubseteq" =># '(nos _1)'; 
  cmp := "\sqsupset" =># '(nos _1)'; 
  cmp := "\sqsupseteq" =># '(nos _1)'; 
  bin := "\square" =># '(nos _1)'; 
  cmp := "\Subset" =># '(nos _1)'; 
  cmp := "\succ" =># '(nos _1)'; 
  cmp := "\succapprox" =># '(nos _1)'; 
  cmp := "\succcurlyeq" =># '(nos _1)'; 
  cmp := "\succeq" =># '(nos _1)'; 
  cmp := "\succnapprox" =># '(nos _1)'; 
  cmp := "\succneqq" =># '(nos _1)'; 
  cmp := "\succnsim" =># '(nos _1)'; 
  cmp := "\succsim" =># '(nos _1)'; 
  cmp := "\Supset" =># '(nos _1)'; 

// T

  cmp := "\thickapprox" =># '(nos _1)'; 
  cmp := "\thicksim" =># '(nos _1)'; 
  bin := "\times" =># '(nos _1)'; 
  arr := "\to" =># '(nos _1)'; 
  bin := "\triangle" =># '(nos _1)'; 
  bin := "\triangledown" =># '(nos _1)'; 
  cmp := "\triangleleft" =># '(nos _1)'; 
  cmp := "\trianglelefteq" =># '(nos _1)'; 
  cmp := "\triangleq" =># '(nos _1)'; 
  cmp := "\triangleright" =># '(nos _1)'; 
  cmp := "\trianglerighteq" =># '(nos _1)'; 
  arr := "\twoheadleftarrow" =># '(nos _1)'; 
  arr := "\twoheadrightarrow" =># '(nos _1)'; 

// U

  cmp := "\unlhd" =># '(nos _1)'; 
  cmp := "\unrhd" =># '(nos _1)'; 
  bin := "\Uparrow" =># '(nos _1)'; 
  bin := "\uparrow" =># '(nos _1)'; 
  bin := "\Updownarrow" =># '(nos _1)'; 
  bin := "\updownarrow" =># '(nos _1)'; 
  bin := "\upharpoonleft" =># '(nos _1)'; 
  bin := "\upharpoonright" =># '(nos _1)'; 
  bin := "\uplus" =># '(nos _1)'; 
  bin := "\upuparrows" =># '(nos _1)'; 

// V

  cmp := "\varsubsetneq" =># '(nos _1)'; 
  cmp := "\varsubsetneqq" =># '(nos _1)'; 
  cmp := "\varsupsetneq" =># '(nos _1)'; 
  cmp := "\varsupsetneqq" =># '(nos _1)'; 
  cmp := "\veebar" =># '(nos _1)'; 

// W


// X

  arr := "\xleftarrow" =># '(nos _1)'; 
  arr := "\xrightarrow" =># '(nos _1)'; 

// Y


// Z



// The precedences here are a hack: so many operators.
// The general effect is: except for keyword logic connectives,
// these operations are all done AFTER any ASCII art ops
// and, only one is allowed per sub-expression: you must use parens
// if you use more than one. We'll fix this for some key operations later,
// particularly the setwise and logic connectors. However, the comparisons
// are at the right precedence.
// (fact is, I don't know what half the operators are for anyhow .. )

  x[stuple_pri] := x[>stuple_pri] "\brace" x[>stuple_pri] =># "(Infix)";
  x[stuple_pri] := x[>stuple_pri] "\brack" x[>stuple_pri] =># "(Infix)";


  x[scomparison_pri]:= x[>scomparison_pri] bin x[>scomparison_pri] =># "`(ast_apply ,_sr (,_2 (,_1 ,_3)))";
  // set ops (note: no setminus, its a standard binop at the moment ;)
  // note: no \Cap or other variants .. would interfere with chain 
  // there's no reason at all to chain these anyhow, they're standard left assoc operators 

  // All arrows are right associative .. hmm ..
  x[sarrow_pri] := x[scase_literal_pri] arr x[sarrow_pri] =># "`(ast_apply ,_sr (,_2 (,_1 ,_3)))"; 
}

