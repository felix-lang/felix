include "std/control/chips";

chip loader(filename: string) 
  connector io
    pin out : %> string
{
  var f = load(filename);
  var lines = split(f,char "\n");
  for line in lines do
    write (io.out, line);
  done
}

chip comment_stripper
  connector io
    pin inp: %< string
    pin out: %> string
{
  while true do
    var s = read(io.inp);
    for (var i=0; i< s.len.int; ++i;) 
      if s.[i] == char "#" goto endline;
  endline:>
    write (io.out, s.[0 .. i - 1]);
  done
}

enum lstate { Spc, Dig, Alph };

fun lex(inp: string) : list[string] {
  // state machine
  var state = Spc;
  var i = 0;
  var tokens = Empty[string];
  var tok = "";

  // add token to output list (in reverse order) and clear token
  proc emit() { if tok != "" do tokens = Cons (tok, tokens); tok = ""; done }

  // scan the whole string
  var n = inp.len.int;
  var ch = inp.[0];
  while i < n do
   // character under consideration

   // routine to add it to token
   proc addch() { tok = tok + ch; ++i; ch = inp.[i]; }

   // routine to ignore a character
   proc skipch() { ++i; ch = inp.[i]; }

   // routine to start a new token
   proc newtoken() { emit; state = Spc; }

   // switch on the automaton state
    match state with
      // processing spaces
      | Spc => 
        if ch.isblank do skipch;
        elif ch.isdigit do
          emit;
          addch;
          state = Dig;
        elif ch.isidstart do
          emit;
          addch;
          state = Alph;
        elif ch == char "." do
          emit;
          addch;
          newtoken;
        elif ch in "()+-*/%^|&{}" do
          emit;
          addch;
          newtoken;
        elif ch in "<>=!" do
          emit;
          var op2 = inp.[i to i+2];
          if op2 in ("!=","==","<<",">>",">=","<=") perform
            addch;
          addch;
          newtoken;
        else
          println$ "Unknown character " + ch;
          System::exit(1);
        done

      // processing a digit sequence
      | Dig =>
        if ch.isdigit do
          addch;
        else
         newtoken;
        done

     // Processing an identifier
    | Alph =>
      if ch.iscidcont do
        addch;
      else
        newtoken;
      done
    endmatch;
  done
   // finalise any current token
  emit;

   // return the token list
  return tokens.rev;
}

// recursive descent expression parser
variant expr = 
  | Binop of string * expr * expr
  | Unop of string * expr 
  | Const of string // integer constant
  | Ident of string // variable name
  | Error
;
instance Str[expr] {
  fun str: expr -> string =
  | Binop (op, l, r) => "(" + l.str + ") " + op + " (" + r.str + ")"
  | Unop (op, l) => op + "(" + l.str + ")"
  | Const s => s
  | Ident s => s
  | Error => "ERROR"
  ;
}

var binop_map = strdict[string]();
var unop_map = strdict[string]();

binop_map.add "+" "u32unchecked_add\n";
binop_map.add "-" "u32unchecked_sub\n";
binop_map.add "*" "u32unchecked_mul\n";
binop_map.add "/" "u32unchecked_div\n";
binop_map.add "%" "u32unchecked_mod\n";

binop_map.add "&" "u32unchecked_and\n";
binop_map.add "|" "u32unchecked_or\n";
binop_map.add "^" "u32unchecked_xor\n";

binop_map.add "<<" "u32unchecked_shl\n";
binop_map.add ">>" "u32unchecked_shr\n";

binop_map.add ">" "u32unchecked_gt\n";
binop_map.add "<" "u32unchecked_lt\n";
binop_map.add "<=" "u32unchecked_le\n";
binop_map.add ">=" "u32unchecked_ge\n";
binop_map.add "==" "u32unchecked_eq\n";
binop_map.add "!=" "u32unchecked_neq\n";

unop_map.add "-" "u32unchecked_neg\n";
unop_map.add "!" "u32unchecked_not\n";

struct syminfo_t {
  loc : int;
  typ : string;
  mut : bool;
}

struct symbol_table_t {
  counter : int;
  table: strdict[syminfo_t];
}

proc add(tab: &symbol_table_t) (key:string) (mut:bool) (typ:string) {
  if tab->table.haskey key do
    println$ "Duplicate symbol " + key;
    System::exit(1);
  else
   var dat = syminfo_t (tab->counter, typ, mut);
   tab->table.add key dat;
   post_incr(tab.counter);
  done
} 

fun get_info (tab: &symbol_table_t) (key:string) : syminfo_t {
  match tab->table.get key with
  | Some info => return info;
  | None => fail("Fetch from or store to undefined variable " + key);
  endmatch;
}

fun get_address (tab: &symbol_table_t) (key:string) : int {
  return (get_info tab key).loc;
}

fun postfix (ps: &symbol_table_t) (e:expr) (indent: int) : string =>
  let fun pf(e:expr):string => postfix ps e indent in
  match e with
  | Const s => "  " * indent + "push."+s+" # constant\n"
  | Ident s => let a = ps.get_address s in "  " * indent + "push.local."+a.str+" # get " + s+"\n"
  | Error => "ERROR\n"

  | Binop (op, a, b) =>
    let op = match binop_map.get op with
    | None => "# Can't find '" + op "' in operator map\n"
    | Some x => "  " * indent + x
    in
    pf a + pf b + op

  | Unop (op, a) =>
    let op = match unop_map.get op with
    | None => "# Can't find '" + op "' in operator map\n"
    | Some x => "  " * indent + x
    in
    pf a  + op
;

typedef toks_t = list[string];
typedef pstate_t = expr * toks_t;

proc fail(e: string) {
  println$ "Parse Error: " + e;
  System::exit(1);
}

fun parse_atom (inp: toks_t)  : pstate_t {
  match inp with
  | Empty => 
    fail "Expected atom got End of Line";
  | Cons (head, tail) =>
    match head with
    | "(" =>
       var node, rest = parse_expr tail;
       match rest with
       | Empty => fail "Expected ) parsing atom got Eno of Line";
       | Cons (head, tail) => 
         match head with
         | ")" =>
           return node, tail; // success
         | _ => fail ("Expected ) got " + head)  ;
         endmatch;
       endmatch;
     | x when (x.0).iscidstart =>
       return Ident x, tail;
     | x when (x.0).isdigit =>
       return Const x, tail;
     | x => fail ("Unexpected Symbol " + x + " parsing " + inp.str);
     endmatch;
  endmatch;
}
    
// repeated prefix ops not supported (eg - - 1 is not allowed)
fun parse_prefixop (inp: toks_t) : pstate_t {
//println$ "Parsing prefixop " + inp.str;
  match inp with
  | Empty => 
    fail "Expected prefix expr got End of Lin";
  | Cons(op, tail) => 
    if not (op in ("-","!")) do
      return parse_atom inp;
    else
      var a, rest = parse_atom tail;
      return (Unop (op,a), rest);
    done
  endmatch;
}


fun parse_factor(inp: toks_t) : pstate_t {
  match inp with
  | Empty =>
    fail "Expected factor got End of Line";
  | _ =>
    var tail = inp;
    def var left, tail = parse_prefixop tail; 
    while true do
      match tail with
      | Empty =>
        return left, tail;

      | Cons(op, tail2) =>
        if not (op in ("*", "/", "%")) do 
          return left, tail;
        else 
          def var right, tail = parse_prefixop tail2;
          left = Binop (op, left, right); // reduce
        done
      endmatch;
    done
  endmatch;
}
fun parse_term (inp: toks_t) : pstate_t {
  match inp with
  | Empty =>
    fail "Expected term got End of Line";
  | _ =>
    var tail = inp;
    def var left, tail = parse_factor tail; 
    while true do
      match tail with
      | Empty =>
        return left, tail;

      | Cons(op, tail2) =>
        if not (op in ("+", "-")) do 
          return left, tail;
        else 
          def var right, tail = parse_factor tail2;
          left = Binop (op, left, right); // reduce
        done
      endmatch;
    done
  endmatch;
}
fun parse_shift (inp: toks_t) : pstate_t {
//println$ "parse_shift";
  var left, tail = parse_term inp;
  match tail with
  | Empty => return left, tail;
  | Cons(op, tail2) =>
    if not (op in ("<<",">>")) do
      return left, tail;
    else
      var right, tail3 = parse_term tail2;
      return Binop(op, left, right), tail3;
    done
  endmatch;
}
fun parse_bitand (inp: toks_t) : pstate_t {
//println$ "parse_bitand";
  match inp with
  | Empty =>
    fail "Expected bitand expr got End of Line";
  | _ =>
    var tail = inp;
    def var left, tail = parse_shift tail; 
    while true do
      match tail with
      | Empty =>
        return left, tail;

      | Cons(op, tail2) =>
        if not (op == "&") do 
          return left, tail;
        else 
          def var right, tail = parse_shift tail2;
          left = Binop (op, left, right); // reduce
        done
      endmatch;
    done
  endmatch;
}
fun parse_bitxor (inp: toks_t) : pstate_t {
//println$ "parse_bitxor";
  match inp with
  | Empty =>
    fail "Expected  bitxor expr got End of Line";
  | _ =>
    var tail = inp;
    def var left, tail = parse_bitand tail; 
    while true do
      match tail with
      | Empty =>
        return left, tail;

      | Cons(op, tail2) =>
        if not (op == "^") do 
          return left, tail;
        else 
          def var right, tail = parse_bitand tail2;
          left = Binop (op, left, right); // reduce
        done
      endmatch;
    done
  endmatch;
}

fun parse_bitor (inp: toks_t) : pstate_t {
//println$ "parse_bitor";
  match inp with
  | Empty =>
    fail "Expected bitor expr got End of Line";
  | _ =>
    var tail = inp;
    def var left, tail = parse_bitxor tail; 
    while true do
      match tail with
      | Empty =>
        return left, tail;

      | Cons(op, tail2) =>
        if not (op == "|") do 
          return left, tail;
        else 
          def var right, tail = parse_bitxor tail2;
          left = Binop (op, left, right); // reduce
        done
      endmatch;
    done
  endmatch;
}
fun parse_comparison (inp: toks_t) : pstate_t {
//println$ "parse_comparison";
  var left, tail = parse_bitor inp;
  match tail with
  | Empty => return left, tail;
  | Cons(op, tail2) =>
    if not (op in ("<",">","==","<=", "=>", "!=")) do
      return left, tail;
    else
      var right, tail3 = parse_bitor tail2;
      return Binop(op, left, right), tail3;
    done
  endmatch;
}
fun parse_expr (inp: toks_t) : pstate_t {
//println$ "parse_expr";
  return parse_comparison inp;
}

variant ifparity_t = 
  | ifblock of int
  | elseblock of int
;

chip stmt
  connector io
    pin inp : %< string
    pin out : %> string
{
  proc pr(s:string) { write (io.out, s); }
  proc prln(s:string) { write (io.out, s + "\n"); }

  var counter = 0;
  var indent = 0;
  var ifelsestack = Empty[ifparity_t];

  var h: string;
  var t: toks_t;
  proc advance() {
    match t with 
    | Cons(h1,t1) => h=h1; t = t1; 
    | _ => h = "";
    endmatch;
  }
  fun lookahead () =>
    match t with 
    | Cons(h1,t1) => h1
    | _ => ""
  ;

  var symtab = symbol_table_t(0, strdict[syminfo_t]());


  while true do
    ++counter;
    var line = read(io.inp);
    //prln$ counter.str + ": " + line;
    var tokens = line.lex;
    match tokens with
    | Cons (head, tail) => 
      h = head;
      t = tail;
      
      if h in ("else", "end")  if indent > 0 perform --indent;

      // eval
      if h == "eval" do
        var e,rest = parse_expr t;
        prln$ "  " * indent + "# " + line;
        //prln$ "# eval[parsed] "  e.str;
        pr$ symtab&.postfix e indent;

      // let
      elif h == "let" do
        prln$  "  " * indent + "# " + line;
        advance;
        var mut = false;
        if h == "mut" do
          mut = true;
          advance;
        done
        var name = h; // check it's an identifier!
        advance;
        if h != "=" do
          fail("Variable decl requires = symbol");
        done
        symtab&.add name mut "u32";
        //prln$ "# Added variable '" + name +"' to symbol table";
        var e2,rest2 = parse_expr t;
        //prln$ "# eval[inp] " + cat " " tokens;
        //prln$ "# eval[parsed] " +  e2.str;
        pr$ symtab&.postfix e2 indent;
        prln$ "  " * indent + "local." + symtab&.get_address name;

        // assignment (requires "assign" binder)

      elif #lookahead == "=" do
        prln$ " # " + line;
        name = h;
        advance;
        e,rest = parse_expr t;
        pr$ symtab&.postfix e indent;
        var sym = symtab&.get_info name;
        if not sym.mut do
          fail("Write to immutable variable " + name);
        done
        prln$ "  " * indent + "pop.local." + sym.loc.str;

/* NOTE on if/else stuff

   There is a problem maintaining the state as follows:

   In the "Rust" input we have the syntax

   } else if expr {

  which leaves the input in "if" mode, which can be
  terminated by a single "}", a "} else {" or another "} else if expr {"

  The action is to pop, swap from "if" to "else" of do nothing, respectively
  So } else if { allows chaining tests like "elif" would.

  However the output syntax has no elif equivalent. So we have to do
  an else, start a new block, evaluate the condition, and then do an if.true.

  So a chain "walks to the right" indentwise with every elif chain step.
  When we finally get a plain else, and it is terminated, we have tgo
  dedent to line up with the opening "if" and emit enough "end" to do that.

  So the stack entry for "if" needs a count >= 1 to keep track of how
  many "end" have to be emitted and, the count needs to be transfered
  to the else constuctor too, when the if is terminated by an else.
  An "elif" just increments the count.
*/
      // begin an Rust if block
      elif h == "if" do
        chainmatch t with
        | [".","true"] => 
          prln$ "  " * indent + "if.true # Miden"; // miden if.true
        ormatch unbox t.rev with
        | Cons ("{", tail) => 
          t = tail.rev;
          // evaluate condition
          e,rest = parse_expr t;
          pr$ symtab&.postfix e indent;
          prln("  " * indent + "if.true # Rust");
          ifelsestack = Cons(ifblock 1,ifelsestack);
          // NOTE: at the end, a leading if indents already
          // this currently applies to both miden "if" and a Rust "if"
          // HACK!!!!
          //++indent;
        | _ => fail ("if requires trailing {");
        endmatch;
      // end an if or else block and maybe start a new if
      elif h == "}" do
        advance;
        match h with
        | "" => // terminate ifelse block
          match ifelsestack with
          | Empty => fail("Unmatched }");
          | Cons(ifblock n,stk) =>
            ifelsestack = stk; // terminate ifelse block (no matching else)
            var nest = n; 
            while nest > 0 do
              --indent;
              prln$ "  " * indent + "end #endif";
              --nest;
            done 
          | Cons(elseblock n,stk) =>
            ifelsestack = stk; // terminate ifelse block else
            nest = n;
            while nest > 0 do
              --indent;
              prln$ "  " * indent + "end #Rust endif";
              --nest;
            done 
          endmatch;

        | "else" => // switch nearest enclosing if to else
          advance;
          match h with
          | "{" => // final else block
            match ifelsestack with
            | Empty => fail("Unmatched else ");
            | Cons(elseblock n,stk) => fail("Unmatched else");
            | Cons(ifblock n,stk) =>
              ifelsestack = Cons (elseblock n, stk);
              --indent;
              prln$ "  " * indent + "else #Rust";
              ++indent;
            endmatch;
 
          | "if" => // chained if
            match ifelsestack with
            | Empty => fail("Unmatched else ");
            | Cons(elseblock n,stk) => fail("Unmatched else if");
            | Cons(ifblock n,stk) =>
              ifelsestack = Cons (ifblock (n+1), stk);
              --indent;
              prln$ "  " * indent + "else #Rust else if";
              ++indent;
              // evaluate condition
              e,rest = parse_expr t;
              pr$ symtab&.postfix e indent;
              prln("  " * indent + "if.true #Rust else if");
              ++indent;
            endmatch; // ifelse
          endmatch; // else 
        endmatch; // leading } symbol
      else
        prln$ "  " * indent + cat "" tokens; 
      done
     
    | _ => ;
    endmatch;
    match tokens with
    | Cons (head, tail) => 
      if head in ("begin", "proc", "if", "else", "while", "repeat") perform ++indent;
    | _ => ;
    endmatch;
  done
}

// NOTE: tabs comments to column 35
chip printer  
  connector io
    pin inp : %< string
{
  var x = "";
  while true do
    var s = read io.inp;
    x += s;
    var xs = split(x,"\n");
    var n = xs.len.int - 1;
    for(var i = 0; i<n; ++i;) do
      var line = head xs;
      xs = tail xs;
      match find(line, char "#") with
      | None => ;
      | Some k =>
        var l = line.[to k];
        var r = line.[k to];
        if l.len.int > 32 do
          l= l+ " ";
        else
          l = (l.rstrip + " " * 35).[0 to 35];
        done
        if r.len.int > 0 do
          line = l + r;
        else
          line = l;
        done
      endmatch;
      println line;
    done
  done
}


proc run(filename:string) {
  device source = loader (filename);
  circuit 
    connect source.out, comment_stripper.inp
    connect comment_stripper.out, stmt.inp
    connect stmt.out, printer.inp
  endcircuit
}

run(System::argv 1);
