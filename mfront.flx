include "std/control/chips";
include "./mfront_lexer";
include "./mfront_symtab";
include "./mfront_expr";

chip loader(filename: string) 
  connector io
    pin out : %> string
{
  var f = load(filename);
  var lines = split(f,char "\n");
  for line in lines do
    write (io.out, line);
  done
}

chip comment_stripper
  connector io
    pin inp: %< string
    pin out: %> string
{
  while true do
    var s = read(io.inp);
    for (var i=0; i< s.len.int; ++i;) 
      if s.[i] == char "#" goto endline;
  endline:>
    write (io.out, s.[0 .. i - 1]);
  done
}
// recursive descent expression parser
variant expr = 
  | Binop of string * expr * expr
  | Unop of string * expr 
  | Const of string // integer constant
  | Ident of string // variable name
  | Error
;
instance Str[expr] {
  fun str: expr -> string =
  | Binop (op, l, r) => "(" + l.str + ") " + op + " (" + r.str + ")"
  | Unop (op, l) => op + "(" + l.str + ")"
  | Const s => s
  | Ident s => s
  | Error => "ERROR"
  ;
}

var binop_map = strdict[string]();
var unop_map = strdict[string]();

binop_map.add "+" "u32unchecked_add # +\n";
binop_map.add "-" "u32unchecked_sub # -\n";
binop_map.add "*" "u32unchecked_mul # *\n";
binop_map.add "/" "u32unchecked_div # /\n";
binop_map.add "%" "u32unchecked_mod # %\n";

binop_map.add "&" "u32unchecked_and # and\n";
binop_map.add "|" "u32unchecked_or # or \n";
binop_map.add "^" "u32unchecked_xor # xor\n";

binop_map.add "<<" "u32unchecked_shl # <<\n";
binop_map.add ">>" "u32unchecked_shr # >>\n";

binop_map.add ">" "u32unchecked_gt # >\n";
binop_map.add "<" "u32unchecked_lt # <\n";
binop_map.add "<=" "u32unchecked_le # <=\n";
binop_map.add ">=" "u32unchecked_ge # >=\n";
binop_map.add "==" "u32unchecked_eq # ==\n";
binop_map.add "!=" "u32unchecked_neq # !=\n";

unop_map.add "-" "u32unchecked_neg # neg\n";
unop_map.add "!" "u32unchecked_not # not\n";

fun postfix (ps: &symbol_table_t) (e:expr) (indent: int) : string =>
  let fun pf(e:expr):string => postfix ps e indent in
  match e with
  | Const s => "  " * indent + "push."+s+" # "+s+"\n"
  | Ident s => let a = ps.get_address s in "  " * indent + "push.local."+a.str+" # <-" + s+"\n"
  | Error => "ERROR\n"

  | Binop (op, a, b) =>
    let op = match binop_map.get op with
    | None => "# Can't find '" + op "' in operator map\n"
    | Some x => "  " * indent + x
    in
    pf a + pf b + op

  | Unop (op, a) =>
    let op = match unop_map.get op with
    | None => "# Can't find '" + op "' in operator map\n"
    | Some x => "  " * indent + x
    in
    pf a  + op
;

typedef toks_t = list[string];
typedef pstate_t = expr * toks_t;

proc fail(e: string) {
  println$ "Parse Error: " + e;
  System::exit(1);
}
proc checkint(x:string) {
  for ch in x do
    if not isdigit(ch) perform
      fail("GOTO target must be integer, got " + x);
  done
}

variant ifparity_t = 
  | ifblock of int
  | elseblock of int
  | whileblock
;

chip stmt
  connector io
    pin inp : %< string
    pin out : %> string
{
  proc pr(s:string) { write (io.out, s); }
  proc prln(s:string) { write (io.out, s + "\n"); }

  var counter = 0;
  var indent = 0;
  var ifelsestack = Empty[ifparity_t];
  var label_counter = 2; // the first user label must be 2
  var max_lab = (0,0); // error tracking: label index, line used
  var h: string;
  var t: toks_t;
  proc advance() {
    match t with 
    | Cons(h1,t1) => h=h1; t = t1; 
    | _ => h = "";
    endmatch;
  }
  fun lookahead () =>
    match t with 
    | Cons(h1,t1) => h1
    | _ => ""
  ;

  var symtab = symbol_table_t(0, strdict[syminfo_t]());

  var switch_counter = 1;
  while true do
    ++counter;
    var line = read(io.inp);
    //prln$ counter.str + ": " + line;
    var tokens = line.lex;
    match tokens with
    | Cons (head, tail) => 
      h = head;
      t = tail;
      
      if h in ("else", "end")  if indent > 0 perform --indent;
      if h == "SWITCH" do
        prln$ "push.1 # begin switch  with PC = 1";
        prln$ "pop.mem.0  # PC is memory location 0";
        prln$ "push.1 # make loop start";
        prln$ "while.true # begin the SWITCH";
        prln$ "push.mem.0 # load PC";
        prln$ "u32unchecked_add.1      # increment by 1";
        prln$ "pop.mem.0  # save PC";
        ++indent;
      elif h == "GOTO" do
        advance;
        checkint(h); // check the next token is an integer
        var labval = int h;
        if labval > max_lab.0 perform
          max_lab = labval, counter;
        prln$ "# GOTO " + h;
        prln$ "push."+h+" # jump address"; 
        prln$ "pop.mem.0  # set PC to " + h;
        prln$ "# -------";
      elif h == "LABEL" do
        advance;
        checkint(h); // check the next token is an integer
        labval = int h;
        if labval != label_counter 
          perform fail ("Invalid label counter " + h ", should be " + label_counter.str);
        ++label_counter; 
        --indent;
        prln$ "# LABEL " + h;
        if switch_counter > 2 perform
          prln$ "else # end case " + (switch_counter - 1).str;
        prln$ "u32checked_eq."+h+ " # check if PC is for this case";
        prln$ "if.true # start code for this case";
        ++indent;
        ++switch_counter; // count the number of 'end' we need at the switch end
      elif h == "BREAK" do
        --indent;
        prln$ "push.0 # 0";
        prln$ "pop.mem.0 # ->PC";
        ++indent;

      elif h == "ENDSWITCH" do
        if max_lab.0 > switch_counter perform
          fail("Jump to non existent label " + max_lab.0.str + " line " + max_lab.1.str);
        var end_case = switch_counter;
        while switch_counter > 1 do
          prln$ "end # switch case "+switch_counter.str;
          --switch_counter;
        done
        --indent;
        prln$ "push.mem.0 #load PC";
        prln$ "dup";
        prln$ "u32checked_eq.0"; // test for break
        prln$ "swap";
        prln$ "u32checked_eq." + end_case.str; // test for fall through
        prln$ "u32checked_and";
        prln$ "end #while loop";
        prln$ "# PROGRAM EXIT";
      // eval
      elif h == "eval" do
        var e,rest = parse_expr t;
        prln$ "  " * indent + "# " + line;
        //prln$ "# eval[parsed] "  e.str;
        pr$ symtab&.postfix e indent;

      // let
      elif h == "let" do
        prln$  "  " * indent + "# " + line;
        advance;
        var mut = false;
        if h == "mut" do
          mut = true;
          advance;
        done
        var name = h; // check it's an identifier!
        advance;
        if h != "=" do
          fail("Variable decl requires = symbol");
        done
        symtab&.add name mut "u32";
        //prln$ "# Added variable '" + name +"' to symbol table";
        var e2,rest2 = parse_expr t;
        //prln$ "# eval[inp] " + cat " " tokens;
        //prln$ "# eval[parsed] " +  e2.str;
        pr$ symtab&.postfix e2 indent;
        prln$ "  " * indent + "pop.local." + symtab&.get_address name +"# init " + name;

        // assignment (requires "assign" binder)

      elif #lookahead == "=" do
        prln$ " # " + line;
        name = h;
        advance;
        e,rest = parse_expr t;
        pr$ symtab&.postfix e indent;
        var sym = symtab&.get_info name;
        if not sym.mut do
          fail("Write to immutable variable " + name);
        done
        prln$ "  " * indent + "pop.local." + sym.loc.str + "# " + name + "<-";

      elif h == "while" do
        chainmatch t with
        | [".","true"] => 
          prln$ "  " * indent + "while.true # Miden"; // miden while.true
        ormatch unbox t.rev with
        | Cons ("{", tail) => 
          t = tail.rev;
          // evaluate condition
          e,rest = parse_expr t;
          pr$ symtab&.postfix e indent;
          prln("  " * indent + "while.true # Rust while");
          ifelsestack = Cons(whileblock,ifelsestack);
          // NOTE: at the end, a leading if indents already
          // this currently applies to both miden "if" and a Rust "if"
          // HACK!!!!
          //++indent;
        | _ => fail ("while requires trailing {");
        endmatch;
      

/* NOTE on if/else stuff

   There is a problem maintaining the state as follows:

   In the "Rust" input we have the syntax

   } else if expr {

  which leaves the input in "if" mode, which can be
  terminated by a single "}", a "} else {" or another "} else if expr {"

  The action is to pop, swap from "if" to "else" of do nothing, respectively
  So } else if { allows chaining tests like "elif" would.

  However the output syntax has no elif equivalent. So we have to do
  an else, start a new block, evaluate the condition, and then do an if.true.

  So a chain "walks to the right" indentwise with every elif chain step.
  When we finally get a plain else, and it is terminated, we have tgo
  dedent to line up with the opening "if" and emit enough "end" to do that.

  So the stack entry for "if" needs a count >= 1 to keep track of how
  many "end" have to be emitted and, the count needs to be transfered
  to the else constuctor too, when the if is terminated by an else.
  An "elif" just increments the count.
*/
      // begin an Rust if block
      elif h == "if" do
        chainmatch t with
        | [".","true"] => 
          prln$ "  " * indent + "if.true # Miden"; // miden if.true
        ormatch unbox t.rev with
        | Cons ("{", tail) => 
          t = tail.rev;
          // evaluate condition
          e,rest = parse_expr t;
          pr$ symtab&.postfix e indent;
          prln("  " * indent + "if.true # Rust if");
          ifelsestack = Cons(ifblock 1,ifelsestack);
          // NOTE: at the end, a leading if indents already
          // this currently applies to both miden "if" and a Rust "if"
          // HACK!!!!
          //++indent;
        | _ => fail ("if requires trailing {");
        endmatch;
      // end an if or else block and maybe start a new if
      elif h == "}" do
        advance;
        match h with
        | "" => // terminate ifelse block
          match ifelsestack with
          | Empty => fail("Unmatched }");
          | Cons(ifblock n,stk) =>
            ifelsestack = stk; // terminate ifelse block (no matching else)
            var nest = n; 
            while nest > 0 do
              --indent;
              prln$ "  " * indent + "end # Rust endif";
              --nest;
            done 
          | Cons(elseblock n,stk) =>
            ifelsestack = stk; // terminate ifelse block else
            nest = n;
            while nest > 0 do
              --indent;
              prln$ "  " * indent + "end # Rust endif";
              --nest;
            done 
          | Cons(whileblock,stk) =>
            --indent;
            ifelsestack = stk; // terminate while block (no matching else)
            prln$ "  " * indent + "end # Rust endwhile";
          endmatch;

        | "else" => // switch nearest enclosing if to else
          advance;
          match h with
          | "{" => // final else block
            match ifelsestack with
            | Empty => fail("Unmatched else ");
            | Cons(elseblock n,stk) => fail("Unmatched else");
            | Cons(ifblock n,stk) =>
              ifelsestack = Cons (elseblock n, stk);
              --indent;
              prln$ "  " * indent + "else # Rust else";
              ++indent;
            endmatch;
 
          | "if" => // chained if
            match ifelsestack with
            | Empty => fail("Unmatched else ");
            | Cons(elseblock n,stk) => fail("Unmatched else if");
            | Cons(ifblock n,stk) =>
              ifelsestack = Cons (ifblock (n+1), stk);
              --indent;
              prln$ "  " * indent + "else # Rust else if";
              ++indent;
              // evaluate condition
              e,rest = parse_expr t;
              pr$ symtab&.postfix e indent;
              prln("  " * indent + "if.true # Rust else if");
              ++indent;
            endmatch; // ifelse
          endmatch; // else 
        endmatch; // leading } symbol
      else
        prln$ "  " * indent + cat "" tokens; 
      done
     
    | _ => ;
    endmatch;
    match tokens with
    | Cons (head, tail) => 
      if head in ("begin", "proc", "if", "else", "while", "repeat") perform ++indent;
    | _ => ;
    endmatch;
  done
}

// NOTE: tabs comments to column 35
chip printer  
  connector io
    pin inp : %< string
{
  var x = "";
  while true do
    var s = read io.inp;
    x += s;
    var xs = split(x,"\n");
    var n = xs.len.int - 1;
    for(var i = 0; i<n; ++i;) do
      var line = head xs;
      xs = tail xs;
      match find(line, char "#") with
      | None => ;
      | Some k =>
        var l = line.[to k];
        var r = line.[k to];
        if l.len.int > 32 do
          l= l+ " ";
        else
          l = (l.rstrip + " " * 35).[0 to 35];
        done
        if r.len.int > 0 do
          line = l + r;
        else
          line = l;
        done
      endmatch;
      println line;
    done
    x = head xs;
  done
}


proc run(filename:string) {
  device source = loader (filename);
  circuit 
    connect source.out, comment_stripper.inp
    connect comment_stripper.out, stmt.inp
    connect stmt.out, printer.inp
  endcircuit
}

run(System::argv 1);
