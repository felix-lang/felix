include "std/control/chips";
include "./mfront_lexer";
include "./mfront_symtab";
include "./mfront_expr";

chip loader(filename: string) 
  connector io
    pin out : %> string
{
  var f = load(filename);
  var lines = split(f,char "\n");
  for line in lines do
    write (io.out, line);
  done
}

chip comment_stripper
  connector io
    pin inp: %< string
    pin out: %> string
{
  while true do
    var s = read(io.inp);
    for (var i=0; i< s.len.int; ++i;) 
      if s.[i] == char "#" goto endline;
  endline:>
    write (io.out, s.[0 .. i - 1]);
  done
}

proc fail(e: string) {
  println$ "Parse Error: " + e;
  System::exit(1);
}

class stmt_parser {

  proc checkint(x:string) {
    for ch in x do
      if not isdigit(ch) perform
        fail("GOTO target must be integer, got " + x);
    done
  }

  variant ifparity_t = 
    | ifblock of int
    | elseblock of int
    | whileblock
  ;

  chip stmt
    connector io
      pin inp : %< string
      pin out : %> string
  {
    open symbol;
    proc pr(s:string) { write (io.out, s); }
    proc prln(s:string) { write (io.out, s + "\n"); }

    var counter = 0;
    var ifelsestack = Empty[ifparity_t];
    var label_counter = 2; // the first user label must be 2
    var max_lab = (0,0); // error tracking: label index, line used

    // SWITCH nesting depth control
    var pc_base_address = 1000;
    var pc_nest = 0;
    var pc_address : int;

    var h: string;
    var t: lexer::toks_t;
    proc advance() {
      match t with 
      | Cons(h1,t1) => h=h1; t = t1; 
      | _ => h = "";
      endmatch;
    }
    fun lookahead () =>
      match t with 
      | Cons(h1,t1) => h1
      | _ => ""
    ;

    var symtab = symbol_table_t(0, strdict[syminfo_t]());

    var switch_counter = 1;
    while true do
      ++counter;
      var line = read(io.inp);
      //prln$ counter.str + ": " + line;
      var tokens = line.lexer::lex;
      match tokens with
      | Cons (head, tail) => 
        h = head;
        t = tail;
        
        if h == "SWITCH" do
          ++pc_nest;
          prln$ "push.1 # begin switch  with PC = 1";
          pc_address = pc_nest + pc_base_address;
          prln$ "pop.mem."+ pc_address.str + " # PC"+pc_nest.str +" is memory location "+pc_address.str;
          prln$ "push.1 # make loop start";
          prln$ "while.true # begin the SWITCH";
          prln$ "push.mem."+pc_address.str + " # load PC"+pc_nest.str;
          prln$ "u32unchecked_add.1      # increment by 1";
          prln$ "pop.mem."+pc_address.str + " # save PC"+pc_nest.str;
        elif h == "GOTO" do
          advance;
          checkint(h); // check the next token is an integer
          var labval = int h;
          if labval > max_lab.0 perform
            max_lab = labval, counter;
          prln$ "# GOTO " + h;
          prln$ "push."+h+" # jump address"; 
          prln$ "pop.mem." + pc_address.str + " # set PC"+pc_nest.str + " to " + h;
          prln$ "# -------";
        elif h == "LABEL" do
          advance;
          checkint(h); // check the next token is an integer
          labval = int h;
          if labval != label_counter 
            perform fail ("Invalid label counter " + h ", should be " + label_counter.str);
          ++label_counter; 
          prln$ "# LABEL " + h;
          if switch_counter > 2 perform
            prln$ "else # end case " + (switch_counter - 1).str;
          prln$ "u32checked_eq."+h+ " # check if PC is for this case";
          prln$ "if.true # start code for this case";
          ++switch_counter; // count the number of 'end' we need at the switch end
        elif h == "BREAK" do
          prln$ "push.0 # 0";
          prln$ "pop.mem."+pc_address.str + "# ->PC"+pc_nest.str;

        elif h == "ENDSWITCH" do
          if max_lab.0 > switch_counter perform
            fail("Jump to non existent label " + max_lab.0.str + " line " + max_lab.1.str);
          var end_case = switch_counter;
          while switch_counter > 1 do
            prln$ "end # switch case "+switch_counter.str;
            --switch_counter;
          done
          prln$ "push.mem."+pc_address.str + " #load PC"+pc_nest.str;
          prln$ "dup";
          prln$ "u32checked_eq.0"; // test for break
          prln$ "swap";
          prln$ "u32checked_eq." + end_case.str; // test for fall through
          prln$ "u32checked_and";
          prln$ "end #while loop";
          --pc_nest;
          pc_address = pc_base_address + pc_nest;
          prln$ "# SWITCH EXIT";
        // eval
        elif h == "eval" do
          var e,rest = expr_parser::parse_expr t;
          prln$ "# " + line;
          //prln$ "# eval[parsed] "  e.str;
          pr$ symtab&.expr_emit::postfix e;

        // let
        elif h == "let" do
          prln$  "# " + line;
          advance;
          var mut = false;
          if h == "mut" do
            mut = true;
            advance;
          done
          var name = h; // check it's an identifier!
          advance;
          if h != "=" do
            fail("Variable decl requires = symbol");
          done
          symtab&.add name mut "u32";
          //prln$ "# Added variable '" + name +"' to symbol table";
          var e2,rest2 = expr_parser::parse_expr t;
          //prln$ "# eval[inp] " + cat " " tokens;
          //prln$ "# eval[parsed] " +  e2.str;
          pr$ symtab&.expr_emit::postfix e2 ;
          prln$ "pop.local." + symtab&.get_address name +"# init " + name;

          // assignment (requires "assign" binder)

        elif #lookahead == "=" do
          prln$ " # " + line;
          name = h;
          advance;
          e,rest = expr_parser::parse_expr t;
          pr$ symtab&.expr_emit::postfix e ;
          var sym = symtab&.get_info name;
          if not sym.mut do
            fail("Write to immutable variable " + name);
          done
          prln$ "pop.local." + sym.loc.str + "# " + name + "<-";

        elif h == "while" do
          chainmatch t with
          | [".","true"] => 
            prln$ "while.true # Miden"; // miden while.true
          ormatch unbox t.rev with
          | Cons ("{", tail) => 
            t = tail.rev;
            // evaluate condition
            e,rest = expr_parser::parse_expr t;
            pr$ symtab&.expr_emit::postfix e ;
            prln("while.true # Rust while");
            ifelsestack = Cons(whileblock,ifelsestack);
          | _ => fail ("while requires trailing {");
          endmatch;
        

  /* NOTE on if/else stuff

     There is a problem maintaining the state as follows:

     In the "Rust" input we have the syntax

     } else if expr {

    which leaves the input in "if" mode, which can be
    terminated by a single "}", a "} else {" or another "} else if expr {"

    The action is to pop, swap from "if" to "else" of do nothing, respectively
    So } else if { allows chaining tests like "elif" would.

    However the output syntax has no elif equivalent. So we have to do
    an else, start a new block, evaluate the condition, and then do an if.true.

    So a chain "walks to the right" indentwise with every elif chain step.
    When we finally get a plain else, and it is terminated, we have tgo
    dedent to line up with the opening "if" and emit enough "end" to do that.

    So the stack entry for "if" needs a count >= 1 to keep track of how
    many "end" have to be emitted and, the count needs to be transfered
    to the else constuctor too, when the if is terminated by an else.
    An "elif" just increments the count.
  */
        // begin an Rust if block
        elif h == "if" do
          chainmatch t with
          | [".","true"] => 
            prln$ "if.true # Miden"; // miden if.true
          ormatch unbox t.rev with
          | Cons ("{", tail) => 
            t = tail.rev;
            // evaluate condition
            e,rest = expr_parser::parse_expr t;
            pr$ symtab&.expr_emit::postfix e ;
            prln("if.true # Rust if");
            ifelsestack = Cons(ifblock 1,ifelsestack);
          | _ => fail ("if requires trailing {");
          endmatch;
        // end an if or else block and maybe start a new if
        elif h == "}" do
          advance;
          match h with
          | "" => // terminate ifelse block
            match ifelsestack with
            | Empty => fail("Unmatched }");
            | Cons(ifblock n,stk) =>
              ifelsestack = stk; // terminate ifelse block (no matching else)
              var nest = n; 
              while nest > 0 do
                prln$ "end # Rust endif";
                --nest;
              done 
            | Cons(elseblock n,stk) =>
              ifelsestack = stk; // terminate ifelse block else
              nest = n;
              while nest > 0 do
                prln$ "end # Rust endif";
                --nest;
              done 
            | Cons(whileblock,stk) =>
              ifelsestack = stk; // terminate while block (no matching else)
              prln$ "end # Rust endwhile";
            endmatch;

          | "else" => // switch nearest enclosing if to else
            advance;
            match h with
            | "{" => // final else block
              match ifelsestack with
              | Empty => fail("Unmatched else ");
              | Cons(elseblock n,stk) => fail("Unmatched else");
              | Cons(ifblock n,stk) =>
                ifelsestack = Cons (elseblock n, stk);
                prln$ "else # Rust else";
              endmatch;
   
            | "if" => // chained if
              match ifelsestack with
              | Empty => fail("Unmatched else ");
              | Cons(elseblock n,stk) => fail("Unmatched else if");
              | Cons(ifblock n,stk) =>
                ifelsestack = Cons (ifblock (n+1), stk);
                prln$ "else # Rust else if";
                // evaluate condition
                e,rest = expr_parser::parse_expr t;
                pr$ symtab&.expr_emit::postfix e ;
                prln("if.true # Rust else if");
              endmatch; // ifelse
            endmatch; // else 
          endmatch; // leading } symbol
        else
          prln$ cat "" tokens; 
        done
       
      | _ => ;
      endmatch;
    done
  }
}

// NOTE: tabs comments to column 35
chip printer  
  connector io
    pin inp : %< string
{
  fun align_comments(line:string):string {
    match find(line, char "#") with
    | None => var out = line;
    | Some k =>
      var l = line.[to k];
      var r = line.[k to];
      if l.len.int > 32 do
        l= l+ " ";
      else
        l = (l.rstrip + " " * 35).[0 to 35];
      done
      if r.len.int > 0 do
        out = l + r;
      else
        out = l;
      done
    endmatch;
    return out;
  }

  var x = "";
  var indent = 0;

  while true do
    var s = read io.inp;
    x += s;
    var xs = split(x,"\n");
    var n = xs.len.int - 1;
    for(var i = 0; i<n; ++i;) do
      var line = head xs;
      xs = tail xs;
      if startswith line "end" or startswith line "else" perform --indent;
      var indented_line = "  " * indent + line;
      var outline = align_comments indented_line;
      if startswith line "while.true" or startswith line "if.true" or startswith line "else" perform ++indent; 
      println$ outline;
    done
    x = head xs;
  done
}


proc run(filename:string) {
  device source = loader (filename);
  device stmt = stmt_parser::stmt;
  circuit 
    connect source.out, comment_stripper.inp
    connect comment_stripper.out, stmt.inp
    connect stmt.out, printer.inp
  endcircuit
}

run(System::argv 1);
