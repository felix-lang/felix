//$ libflx.flx
//$ Author Mike Maul
//$ See README.md for more details
//$ Object wrapper of functionality in flx user frontend
//$ for the purpose of creating application interface

include "plat/config";
include "PKGTOOL/libflx_interface";
fun setup(config_data:string) = {
  eprintln$ "flx:" + config_data;
  return 0;
}
open Process;
object libflx() implements libflx_interface = {

  //proc throwint : int = "throw $1;";

  // Felix version of THIS program (NOT the one being installed
  // if you're using flx to install Felix)

  var config = #Config::config;
  var VERSION=config.VERSION;
  method fun get_version() => VERSION; 
  // Options
  var ECHO=0;
  method proc set_echo(v:bool) { ECHO = if v then 1 else 0 endif; }
  method fun get_echo() => ECHO == 1;
  var dbug = false; // switch off for production
  method proc set_dbug(v:bool) {  dbug = v; }
  method fun get_dbug() => dbug;
  // --------------------------------------------------
  // Other Configuration Data
  // --------------------------------------------------

  //  C compiler kind
  var HAVE_GNU=config.HAVE_GNU;
  var HAVE_MSVC=config.HAVE_MSVC;

  // compilation and linkage command heads
  var CCOBJ_DLLIB=config.CCOBJ_DLLIB;
  var CCLINK_DLLIB=config.CCLINK_DLLIB;
  var CCOBJ_STATIC_LIB=config.CCOBJ_STATIC_LIB;
  var CCLINK_STATIC=config.CCLINK_STATIC;

  // extensions of various file kinds
  var EXT_LIB=config.EXT_LIB;
  var EXT_STATIC_OBJ=config.EXT_STATIC_OBJ;
  var EXT_SHARED_OBJ=config.EXT_SHARED_OBJ;
  var EXT_EXE=config.EXT_EXE;
  var EXT_SHLIB=config.EXT_SHLIB;
  var SPEC_OBJ_FILENAME=config.SPEC_OBJ_FILENAME;
  var SPEC_EXE_FILENAME=config.SPEC_EXE_FILENAME;
  var EXT_OBJ = 0;
  // compilation switches
  var OPTIMISE=config.OPTIMISE;
  method proc set_optimise(v:int) { OPTIMISE = "-O"+v; }
  method fun get_optimise() => match OPTIMISE with
    |?v when v == "-O1" => 1
    |?v when v == "-O2" => 2
    |?v when v == "-O3" => 3 
    |_ => 0
  endmatch;

  var DEBUG_FLAGS=config.DEBUG_FLAGS;
  var DEFAULT_LINK_STATIC=config.DEFAULT_LINK_STATIC;


  // Props
  var INSTALL_ROOT_TOPDIR=config.INSTALL_ROOT_TOPDIR;
  var INSTALL_ROOT=config.INSTALL_ROOT;
  var FLX_INSTALL_DIR=config.FLX_INSTALL_DIR;
  method proc set_flx_install_dir(v:string) { FLX_INSTALL_DIR = v; }
  method fun  get_flx_install_dir() => FLX_INSTALL_DIR;
  // --------------------------------------------------
  // OS kind
  // --------------------------------------------------
  var HAVE_CYGWIN=config.HAVE_CYGWIN;
  var HAVE_WIN32=config.HAVE_WIN32;
  var HAVE_MACOSX=config.HAVE_MACOSX;

  // --------------------------------------------------
  // Control Values
  // --------------------------------------------------

  var RECOMPILE=0;
  method proc set_recompile(v:bool) { RECOMPILE = if v then 1 else 0 endif; }
  method fun get_recompile() => if RECOMPILE == 1 then true else false;
  
  var RUNIT=1;
  method proc set_runit(v:bool) { RUNIT = if v then 1 else 0 endif; }
  method fun get_runit() => if RUNIT == 1 then true else false;

  var CCOMPILEIT=1;
  method proc set_ccompileit(v:bool) { CCOMPILEIT = if v then 1 else 0 endif; }
  method fun get_ccompileit() => if CCOMPILEIT == 1 then true else false;

  var LINKIT=1;
  method proc set_linkit(v:bool) { LINKIT = if v then 1 else 0 endif; }
  method fun get_linkit() => if LINKIT == 1 then true else false;

  var FELIX=1;
  method proc set_felix(v:bool) { FELIX = if v then 1 else 0 endif; }
  method fun get_felix() => if FELIX == 1 then true else false;

  var rel_filebase = "";
  var filebase = "";
  var cpp_filebase = "";
  // --------------------------------------------------
  // processing options
  // --------------------------------------------------

  var HOME= 
    let ?h = Env::getenv "HOME" in
      if h!="" then h 
      elif PLAT_WIN32 then Env::getenv "USERPROFILE"
      else ""
      endif
    ;
//  if HOME == "" do
//      eprintln$ "HOME environment variable is not set.  Please set HOME before building."; 
//	System::exit 1;
//  done 
  var DIST_ROOT="";
  var DEBUG=0;
  method proc set_debug(v:bool) { DEBUG = if v then 1 else 0 endif; }
  method fun get_debug() => if DEBUG == 1 then true else false;

  var DEBUG_COMPILER=0;
  method proc set_debug_compiler(v:bool) { DEBUG_COMPILER = if v then 1 else 0 endif; }
  method fun get_debug_compiler() => DEBUG_COMPILER == 1;

  var COMPILER_PHASE="";
  var INLINE=100;
  method proc set_inline(v:int) { INLINE = v; }
  method fun get_inline() => INLINE;

  var TIME=0;
  method proc set_time(v:bool) { TIME = if v then 1 else 0 endif; }
  method fun get_time() => TIME == 1;

  var NOOPTIMISE=0;
  method proc set_nooptimise(v:bool) { NOOPTIMISE = if v then 1 else 0 endif; }
  method fun get_nooptimise() => NOOPTIMISE == 1;

  var TIMECMD="time -p";
  var STATIC=DEFAULT_LINK_STATIC;
  method proc set_static(v:bool) { STATIC = if v then 1 else 0 endif ; }
  method fun get_static() => STATIC == 1;

  var SHOWCODE=0;
  method proc set_showcode(v:bool) { SHOWCODE = if v then 1 else 0 endif; }
  method fun get_showcode() => SHOWCODE == 1;

  var CCFLAGS="";
  method proc set_ccflags(v:string) { CCFLAGS = v; }
  method fun get_ccflags() => CCFLAGS;

  var EXTRA_CCFLAGS="";
  method proc set_extra_ccflags(v:string) { EXTRA_CCFLAGS = v; }
  method fun get_extra_ccflags() => EXTRA_CCFLAGS;
  
  var LINKER_SWITCHES="";
  method proc set_linker_switches(v:string) { LINKER_SWITCHES = v; }
  method fun get_linker_switcher() => LINKER_SWITCHES;

  var MACROS="";
  method proc set_macros(v:string) { MACROS = v; }
  method fun get_macros() => MACROS;

  var cpps="";
  var cppos="";
  var INCLUDE_DIRS="";
  method proc set_include_dirs(v:string) { INCLUDE_DIRS = v; }
  method fun get_include_dirs() => INCLUDE_DIRS;
  var INCLUDE_FILES="";
  method proc set_include_files(v:string) { INCLUDE_FILES = v; }
  method fun get_include_files() => INCLUDE_FILES;

  var NOSTDLIB=0;
  method proc set_nostdlib(v:bool) { NOSTDLIB = if v then 1 else 0 endif; }
  method fun get_nostdlib() => NOSTDLIB == 1;

  var STDOUT="";
  method proc set_stdout(v:string) { STDOUT = v; }
  method fun get_stdout() => STDOUT;

  var SNORT = false; // take stdout if RUNNIT
  method proc set_snort(v:bool) { SNORT = v; }
  method fun get_snort() => SNORT;

  var STDGRAMMAR="@grammar/grammar.files";
  var STDIMPORT="--import=plat/flx.flxh";
  var IMPORTS="";
  method proc set_imports(v:string) { IMPORTS = v; }
  method fun get_imports() => IMPORTS;

  var USAGE = "production";
  // production , prototyping, debugging, hyperlight
  method proc set_usage(v:string) { USAGE = v; }
  method fun get_usage() => USAGE;

  var CLEAR_CACHE=0;
  method proc set_clear_cache(v:bool) { CLEAR_CACHE = if v then 1 else 0 endif; }
  method fun get_clear_cache() => CLEAR_CACHE == 1;

  var DEFAULT_CACHE_DIR = 
    Filename::join (list(HOME,".felix","cache","binary")) 
  ;

  var CACHE_DIR=
    let ?x = Env::getenv "FLX_CACHE_DIR" in 
    if x != "" then x else DEFAULT_CACHE_DIR
  ;
  method proc set_cache_dir(v:string) { CACHE_DIR = v; }
  method fun get_cache_dir() => CACHE_DIR;

  var DEFAULT_OUTPUT_DIR = 
      Filename::join (list (HOME,".felix","cache","text"));

  var OUTPUT_DIR=
    let ?x = Env::getenv "FLX_OUTPUT_DIR" in 
    if x != "" then x else DEFAULT_OUTPUT_DIR
  ;
  method proc set_output_dir(v:string) { OUTPUT_DIR = v; }
  method fun get_output_dir() => OUTPUT_DIR;

  var BUNDLE_DIR = match Env::getenv("FLX_BUNDLE_DIR") with | "" => None[string] | ?dir => Some dir endmatch;
  method proc set_bundle_dir(v:opt[string]) { BUNDLE_DIR = v; }
  method fun get_bundle_dir() => BUNDLE_DIR;

  var DRIVER_PKG = "";
  var DRIVER_EXE = ""; // dynamic linkage only 
  var DRIVER_OBJS = Empty[string]; // static linkage only
  var LINK_STRING = "";

  var pkgs="";
  method proc set_pkgs(v:string) { pkgs = v; }
  method fun get_pkgs() => pkgs;

  var VERBOSE = "";
  
  var CONFIG_DIR = "";
  var FLXG = "";
  var QUOTE_FLXG = "";
  var FLXRUN = "";

  var DLINK_STRING:string;
  var SLINK_STRING:string;

  var compile_exts = List::list ('cpp','cxx','c','cc');
  var linkexts =  List::list ('o','obj','lib','dll','a','so');
  var result = 0;
  var SET_LINKER_OUTPUT = false;
  var LINKER_OUTPUT_FILENAME = "";
  method proc set_linker_output(v:string) { LINKER_OUTPUT_FILENAME = v; SET_LINKER_OUTPUT = not (v == ""); }
  method fun get_linker_output() => LINKER_OUTPUT_FILENAME;

  var USER_ARGS = ""; 
  method proc set_user_args(v:string) { USER_ARGS = v; }
  method fun get_user_args() => USER_ARGS;

  var PKGCONFIG=quote(Filename::join$ List::list(FLX_INSTALL_DIR,"bin","flx_pkgconfig"));
  debugln$ "Felix package manager program is "+PKGCONFIG;

  var flxg_time = 0.0;
  var flxg_stamp = "";
  var cache_time = 0.0;
  var flxg_stamp_data = "";
  var flxg_stamp_time = 0.0;

  if PLAT_WIN32 do
    fun quote(s:string)=>'"' + s + '"'; // windows filename quoting
  else
    fun quote(s:string)=>"'" + s + "'"; // unix prefers ' to stop expansion
  done

  if PLAT_WIN32 do
    fun pexit(e:int) =
    {
      if e != 0 do
        if e == -1 do
          err :=  errno;
          eprintln$ "Error "+err.str+" in flx: " + strerror err;
          System::exit err.int;
        else
          eprintln$ "Unknown error in shell " + str e;
          System::exit 3;
        done
      done
      System::exit e;
    }
    fun perr(e:int) =
    {
      if e != 0 do
        if e == -1 do
          err :=  errno;
          return ERR[string] (err.int,"Error "+err.str+" in flx: " + strerror err);
           
        else
           return ERR[string] (3,"Unknown error in shell " + str e);
        done
      else
        return OK[string]();
      done
      return ERR[string] (e,"");
    }

  else
    fun pexit(e:int) =
    {
      if e != 0 do
        if WIFEXITED e.process_status_t do
          err :=  WEXITSTATUS e.process_status_t;
          eprintln$ "Error "+err.str+" in flx: " + strerror err.errno_t;
          System::exit err;
        elif WIFSIGNALED e.process_status_t do
          sig := WTERMSIG e.process_status_t;
          eprintln$ "Shell terminated by signal " + str sig;
          System::exit 2;
        else
          eprintln$ "Unknown error in shell " + str e;
          System::exit 3;
        done
      done
      System::exit e;
    }
    fun perr(e:int) =
    {
      if e != 0 do
        if WIFEXITED e.process_status_t do
          err :=  WEXITSTATUS e.process_status_t;
          return ERR[string] (err,"Error "+err.str+" in flx: " + strerror err.errno_t);
     
        elif WIFSIGNALED e.process_status_t do
          sig := WTERMSIG e.process_status_t;
          return ERR[string] (2,"Shell terminated by signal " + str sig);
          
        else
          return ERR[string](3, "Unknown error in shell " + str e);
          
        done
      else
        return OK[string]("");
      done
      return ERR[string](e,"");
    }
  done




// --------------------------------------------------
// Optionally print a debug line.
// --------------------------------------------------
  proc debugln[T with Str[T]] (x:T) {
    dbug ?? fprintln (cerr, "[flx] " + str x);
  }

// --------------------------------------------------
// Invoke the shell
// --------------------------------------------------


  gen system(cmd:string):int= {
    var now = #Time::time;
    if ECHO==1 do fprintln$ cerr, cmd; done
    if PLAT_WIN32 do
      var result = System::system('"'+cmd+'"');
    else
      var result = System::system(cmd);
    done
    var elapsed = #Time::time - now;
    if ECHO==1 do fprintln$ cerr, "System:Elapsed: " + fmt (elapsed, fixed (8,3)) + ", Result code " + str(result); done
      return result;
  }

  gen get_stdout_from(x:string) = {
    // We're screwed if popen doesn't work ..
    if PLAT_WIN32 do
      var fout = Process::popen_in('"'+x+'"');
    else
      var fout = Process::popen_in(x+" ");
    done
    if valid fout do
      var output = load fout;
      debugln$ "[popen command returns data]" + output + "[end popen data]";

      var result = Process::pclose fout; 
      if PLAT_WIN32 do
        return result.int, output;
      else
        return (Process::WEXITSTATUS result), output;
      done
    else
      println$ "Unable to run command '" + x "'";
      return -1,"";
    done
  }

  gen xqt(cmd:string):compiler_result_code_t[string] = {
    ECHO == 1 or dbug ?? fprintln (cerr, "cmd="+cmd);
    var now = #Time::time;
    var result,output = get_stdout_from(cmd);
    if result == 0 do
      n := 
        match find_first_of (output, char "\n") with
        | Some ?n => n 
        | None => output.len.int 
        endmatch
      ; 
      output = output.[to n]; // first line excluding newline
      var elapsed = #Time::time - now;
      ECHO==1 or dbug ?? fprintln (cerr, "Popen:Elapsed: " + fmt (elapsed, fixed(9,3)) + ", output='"+output+"'");
    else
      debugln "COMMAND FAILED";
      var msg = "Error "+repr(result)+" executing command " + cmd;
      fprint$ cerr, (msg + "\n");
      return (ERR[string] (result,msg));//pexit result;
    done
    return OK(output);
  }

  // --------------------------------------------------
  // File time stamp processing
  // --------------------------------------------------


  val past_time = -1.0;
  val future_time = double(ulong(-1)); // a hacky way to get a big number

  fun strfiletime0 (x:double) =>
      if x == past_time then "BIG BANG"
        elif x == future_time then "BIG CRUNCH"
      else fmt (x, fixed (0,3))
      endif;

  fun strfiletime (x:double) = {
    assert x != 0.0;
    return strfiletime0 x;
  }

  fun dfiletime(var f:string, dflt:double)=
  {
    var x = FileStat::filetime (f);
    x = if x == 0.0 then dflt else x endif;
    debugln$ "Time of file '" + f + "' is " + strfiletime x; 
    return x;
  }

  fun cache_join (c:string, var f:string) = 
  {
    debugln$ "[cache_join] " + c + " with  " + f;
    if PLAT_WIN32 do
      if f.[1 to 3] == ":\\" do f = f.[0 to 1]+f.[2 to]; 
      elif f.[1] == char ":" do f = f.[0 to 1]+"\\"+f.[2 to]; 
      done
      if f.[0] == char "\\" do f = f.[1 to]; done
    else
      if f.[0] == char "/" do f = f.[1 to]; done
    done
    var k = Filename::join(c,f);
    debugln$ "[cache_join] result = " + k;
    return k;
  }

  fun cal_dep_time(f:string)= {
    fun maxf (x: double) (f:string) =>
      if f == "" then x else max (x, dfiletime (f,past_time))
    ;

    fun cal_files_time (fs: list[string])=> fold_left maxf past_time fs;

    fun cal_time_from_dep (df: string):double=
    {
      val deptext = load df;
      val lines = split (deptext, "\n"); 
      debugln$ "Deps=" + str(lines);
      val deptime = cal_files_time lines;
      debugln$ "Deptime=" + strfiletime(deptime);
      return deptime;
    }

    val fdoctime = dfiletime(f+".fdoc",past_time);
    val flxtime = dfiletime(f+".flx",past_time);
    val depfilename = cache_join (OUTPUT_DIR, f+".dep");
    debugln$ "Dependency file name = " + depfilename;
    val deptime = cal_time_from_dep (depfilename);
    debugln$ "fdoc time = " + strfiletime fdoctime;
    debugln$ "flx time = " + strfiletime flxtime;
    debugln$ "dep time = " + strfiletime deptime;
    val srctime =  max( fdoctime, max (flxtime, deptime));
    debugln$ "Source time = " + strfiletime srctime;
    return srctime;
  }

  fun splitext(p:string)=>
    if p.[-4 to] == ".flx" then p.[to -4],"flx"
    elif p.[-4 to] == ".cpp" then p.[to -4],"cpp"
    elif p.[-5 to] == ".fdoc" then p.[to -5],"fdoc"
    else p,""
    endif
  ;

  fun prefix(arg:string,key:string)=>
    arg.[to len key]==key
  ;


  proc print_config() {
    println$ "VERSION            = "+VERSION;
    println$ "INSTALL_ROOT_TOPDIR= "+INSTALL_ROOT_TOPDIR;
    println$ "INSTALL_ROOT       = "+INSTALL_ROOT;
    println$ "FLX_INSTALL_DIR    = "+FLX_INSTALL_DIR;
    println$ "";
    println$ "HAVE_CYGWIN             = "+str HAVE_CYGWIN;
    println$ "HAVE_WIN32              = "+str HAVE_WIN32;
    println$ "HAVE_MACOSX             = "+str HAVE_MACOSX;

    println$ "";
    println$ "HAVE_GNU           = "+str HAVE_GNU;
    println$ "HAVE_MSVC          = "+str HAVE_MSVC;

    println$ "";
    println$ "CCOBJ_DLLIB        = "+CCOBJ_DLLIB;
    println$ "CCLINK_DLLIB       = "+CCLINK_DLLIB;
    println$ "CCOBJ_STATIC_LIB   = "+CCOBJ_STATIC_LIB;
    println$ "CCLINK_STATIC      = "+CCLINK_STATIC;

    println$ "";
    println$ "EXT_LIB            = "+EXT_LIB;
    println$ "EXT_STATIC_OBJ     = "+EXT_STATIC_OBJ;
    println$ "EXT_SHARED_OBJ     = "+EXT_SHARED_OBJ;
    println$ "EXT_EXE            = "+EXT_EXE;
    println$ "EXT_SHLIB          = "+EXT_SHLIB;
    println$ "SPEC_OBJ_FILENAME  = "+SPEC_OBJ_FILENAME;
    println$ "SPEC_EXE_FILENAME  = "+SPEC_EXE_FILENAME;

    println$ "";
    println$ "OPTIMISE           = "+str OPTIMISE;
    println$ "DEBUG_FLAGS        = "+str DEBUG_FLAGS;
  }

  proc print_options() {
    println$ "NOOPTIMISE         = "+str NOOPTIMISE;
    println$ "STATIC             = "+str STATIC;
    println$ "ECHO               = "+str ECHO;
    println$ "NOSTDLIB           = "+str NOSTDLIB;
    println$ "DEBUG              = "+str DEBUG;
    println$ "DEBUG_COMPILER     = "+str DEBUG_COMPILER;
    println$ "STDIMPORT          = "+str STDIMPORT;
    println$ "STDGRAMMAR         = "+str STDGRAMMAR;
    println$ "IMPORTS            = "+str IMPORTS;
    println$ "RECOMPILE          = "+str RECOMPILE;
    println$ "cpps               = "+str cpps;
    println$ "cppos              = "+str cppos;
    println$ "TIME               = "+str TIME;
    println$ "OUTPUT_DIR         = "+str OUTPUT_DIR;
    println$ "BUNDLE_DIR         = "+str BUNDLE_DIR;
    println$ "CACHE_DIR          = "+str CACHE_DIR;
    println$ "RUNIT              = "+str RUNIT;
    println$ "CCOMPILEIT         = "+str CCOMPILEIT;
    println$ "LINKIT             = "+str LINKIT;
    println$ "INCLUDE_DIRS       = "+str INCLUDE_DIRS;
    println$ "FELIX              = "+str FELIX;
    println$ "LINKER_SWITCHES    = "+str LINKER_SWITCHES;
    println$ "LINKER_OUTPUT_FILENAME = "+str LINKER_OUTPUT_FILENAME;
    println$ "MACROS             = "+str MACROS;
    println$ "SHOWCODE           = "+str SHOWCODE;
    println$ "USAGE              = "+USAGE;
  }

  fun gramtime(path:string, s:string) : double = {
    //println$ "Path=" + path + " file = " + s;
    fun maxtime (x:double) (s:string) => max (x, gramtime (path, s));
    if s.[0]=="@".char do
      var file = Filename::join$ path, s.[1 to].strip;
      var filetime = dfiletime(file,0.0);
      if filetime == 0.0 do
        println$ "Grammar include file " + file " doesn't exist, exiting";
        System::exit 1;
      done
      debugln$ "Grammar include file " + file + " time=" + strfiletime(filetime);
      var filetext = load file;
      var files = split (filetext, "\n");
      files = map strip of (string) files;
      files = filter (fun (s:string) => s != "") files;
      files = map (fun (s:string) => Filename::join (split(s,"/"))) files;
      //println$ "Files=" + files;
      return fold_left maxtime filetime files;
    else
      file = Filename::join$ path, s;
      filetime = dfiletime(file,0.0);
      if filetime == 0.0 do
        println$ "Grammar file " + file " doesn't exist, exiting";
        System::exit 1;
      done
        debugln$ "Grammar file " + file + " time=" + strfiletime(filetime);
      return filetime;
    done
  }


  fun calpackages () =  {

    // find external header files
    var PKGCONFIG_CFLAGS=PKGCONFIG+ " --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=cflags ";

    // external header files
    var PKGCONFIG_INCLUDES=PKGCONFIG+ " --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=includes ";

    // find external dynload libraries
    var PKGCONFIG_DLIBS=PKGCONFIG+" -r --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=provides_dlib --field=requires_dlibs ";

    // find external static libraries
    var PKGCONFIG_SLIBS=PKGCONFIG+" -r --keeprightmost --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=provides_slib --field=requires_slibs ";

    //find driver package required
    var PKGCONFIG_DRIVER=PKGCONFIG+" --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=flx_requires_driver ";


    // find all include directories
    match xqt(PKGCONFIG_CFLAGS+ " " + quote("@"+cpp_filebase+".resh")) with
    |OK ?x =>  INCLUDE_DIRS = INCLUDE_DIRS +" " + x; 
    |ERR[string] (?e,?m) =>  return ERR[string] (e,m); 
    endmatch;

    // find all include files
    match xqt(PKGCONFIG_INCLUDES+ " "+quote("@"+cpp_filebase+".resh")) with
    |OK ?x => INCLUDE_FILES=INCLUDE_FILES +" " + x;
    |ERR[string] (?e,?m) => return ERR[string] (e,m);
    endmatch;

    // find the driver package
    match xqt(PKGCONFIG_DRIVER+" "+ quote("@"+cpp_filebase+".resh")) with
    |OK ?x => DRIVER_PKG = if x == "" then "flx_run" else x endif;
    |ERR[string] (?e,?m) => return ERR[string] (e,m);
    endmatch;

    // find the driver entity
    if STATIC == 0 do
      // dynamic linkage: the driver executable
      DRIVER_EXE= Filename::join$ List::list (FLX_INSTALL_DIR,"bin",DRIVER_PKG+EXT_EXE);
    else
      // static linkage: the driver object files
      DRIVER_OBJS =list(
        Filename::join (List::list (FLX_INSTALL_DIR,"lib","rtl",DRIVER_PKG+"_lib"+EXT_STATIC_OBJ)),
        Filename::join (List::list (FLX_INSTALL_DIR,"lib","rtl",DRIVER_PKG+"_main"+EXT_STATIC_OBJ))
      );
    done

    if STATIC == 0 do
     // dynamic linkage: all the libraries required by the application 
      match xqt( PKGCONFIG_DLIBS+" "+DRIVER_PKG+" "+quote("@"+cpp_filebase+".resh")) with
      |OK ?v => LINK_STRING=DLINK_STRING+LINKER_SWITCHES+" "+ v; 
      |ERR[string] (?e,?m) =>  return ERR[string] (e,m);
      endmatch;
    else
      // static linkage: all the libraries required by the application and driver
      match xqt(PKGCONFIG_SLIBS+" "+DRIVER_PKG+" "+quote("@"+cpp_filebase+".resh")) with
      |OK ?v => LINK_STRING=SLINK_STRING+LINKER_SWITCHES+" "+v;
      |ERR[string] (?e,?m) => return ERR[string] (e,m); 
      endmatch;
    done

    if ECHO == 1 do
      fprintln (cerr, "//RESOURCE FILE="+cpp_filebase+".resh");
      fprintln (cerr, "//INCLUDE_DIRS="+INCLUDE_DIRS);
      fprintln (cerr, "//INCLUDE_FILES="+INCLUDE_FILES);
    if STATIC == 0 do
      fprintln (cerr, "//DYNAMIC DRIVER EXE ="+str DRIVER_EXE);
    else
      fprintln (cerr, "//STATIC DRIVER OBJS ="+str DRIVER_OBJS);
    done
      fprintln (cerr, "//LINK_STRING="+LINK_STRING);
    done
    if DEBUG_COMPILER == 1 do
      VERBOSE="-v";
      debugln "Compiler debugging on";
    else
      VERBOSE="-q";
      debugln "Compiler debugging off";
    done

    if DEBUG==1 do
      CCFLAGS=CCFLAGS+DEBUG_FLAGS;
    done
    return OK("");
  }

  proc write_include_file(path:string) {
    includes := split (strip INCLUDE_FILES,char " ");
    var f = fopen_output(path+".includes");
    List::iter  
      (proc (i:string) { writeln$ f, "#include " + i; })
      includes
    ;
    fclose f;
  }


  method fun init_compiler() =  {
    if HAVE_WIN32 do
      FLXG=Filename::join(FLX_INSTALL_DIR, 'bin', 'flxg.exe');
      QUOTE_FLXG=quote(FLXG);
      FLXRUN="set PATH="+(Directory::mk_absolute_filename FLX_INSTALL_DIR)+"\\lib\\rtl;"+"%PATH%&&";
      //println$ "FLXRUN=" + FLXRUN;
    else
      FLXG=FLX_INSTALL_DIR+"/bin/flxg";
      QUOTE_FLXG=quote(FLXG);
      // the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
      if HAVE_MACOSX do
        FLXRUN="env DYLD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$DYLD_LIBRARY_PATH ";
      else
        FLXRUN="env LD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$LD_LIBRARY_PATH ";
      done
    done

    Directory::mkdirs(CACHE_DIR);

    flxg_time = dfiletime(FLXG, future_time);
    debugln$ "Flxg_time=" + strfiletime(flxg_time);

    flxg_stamp = Filename::join CACHE_DIR "flxg_time.stamp";
     cache_time = dfiletime(flxg_stamp,future_time);
    debugln$ "cache_time=" + strfiletime(cache_time);

    flxg_stamp_data = load flxg_stamp;
    //println$ "Flxg_stamp_data=" + flxg_stamp_data; 

    flxg_stamp_time = match flxg_stamp_data.atof with | 0.0 => past_time | ?x => x;

    debugln$ "Flxg_stamp_data : " + strfiletime(flxg_stamp_time);
    var grammar_time = gramtime(Filename::join (FLX_INSTALL_DIR,"lib"), STDGRAMMAR);
    debugln$ "Grammar text time=" + strfiletime (grammar_time);
    var automaton_name = 
    cache_join(CACHE_DIR, 
    Directory::mk_absolute_filename (Filename::join (list( 
      FLX_INSTALL_DIR,
      "lib",
      "grammar",
      "syntax.automaton"
    ))))
    ;

    var automaton_time = dfiletime(automaton_name,future_time);
    debugln$ "Automaton " + automaton_name + " time=" + strfiletime(automaton_time);

    // Still if this fails,  the compiler is new and 
    // the cache should be deleted.
    if cache_time != future_time and flxg_stamp_time != flxg_time do
      println$ "Cache may be out of date due to compiler upgrade!";
      println$ "Flxg compiler time stamp=" + strfiletime(flxg_time);
      println$ "Cache time stamp        =" + strfiletime(cache_time);
      if not (
        (OUTPUT_DIR == "/" or OUTPUT_DIR == "" or OUTPUT_DIR == ".") or
        (CACHE_DIR == "/" or CACHE_DIR == "" or CACHE_DIR == ".")
      )
      do 
        CLEAR_CACHE = 1;
      done
    elif automaton_time != future_time and grammar_time > automaton_time do
      println$ "Cache may be out of date due to grammar upgrade!";
      println$ "Grammar time stamp          =" + strfiletime(grammar_time);
      println$ "Automaton.syntax time stamp =" + strfiletime(automaton_time);
      if not (
        (OUTPUT_DIR == "/" or OUTPUT_DIR == "" or OUTPUT_DIR == ".") or
        (CACHE_DIR == "/" or CACHE_DIR == "" or CACHE_DIR == ".")
      )
      do 
        CLEAR_CACHE = 1;
      done
    done

    // FFF BE CAREFUL! The value "/" for these caches is perfectly good
    if CLEAR_CACHE != 0 do
      // refuse to delete "" or "/" or ".", basic safety check
      if 
        (OUTPUT_DIR == "/" or OUTPUT_DIR == "" or OUTPUT_DIR == ".") or
        (CACHE_DIR == "/" or CACHE_DIR == "" or CACHE_DIR == ".")
      do
        println "WILL NOT DELETE CACHES";
        println$ "output cache " + OUTPUT_DIR;
        println$ "binary cache " + CACHE_DIR;
        System::exit(1);
      done

      // if the cache is default $HOME one, which cannot be ""
      // due to previous check, then delete without question
      if 
        OUTPUT_DIR == DEFAULT_OUTPUT_DIR and 
        CACHE_DIR == DEFAULT_CACHE_DIR 
      do 
        var answer = "Y\n";
      else
        // otherwise prompt for confirmation
        println$ "Would delete cache " + OUTPUT_DIR;
        println$ "Would delete cache " + CACHE_DIR;
        print "Are you SURE? (Y/n) "; fflush stdout;
        answer = readln stdin;
      done
      if answer == "Y\n" or answer == "y\n" do
        // delete the caches loudly
        println$ "Delete cache " + OUTPUT_DIR;
        if PLAT_WIN32 do
          C_hack::ignore$ xqt("rd /Q /S " + quote(OUTPUT_DIR));
        else
          C_hack::ignore$ xqt("rm -rf " + quote(OUTPUT_DIR));
        done
        println$ "Delete cache " + CACHE_DIR;
    
        if PLAT_WIN32 do
          C_hack::ignore$ xqt("rd /Q /S " + quote(CACHE_DIR));
        else
          C_hack::ignore$ xqt("rm -rf " + quote(CACHE_DIR));
        done

        Directory::mkdirs(CACHE_DIR);
        var f = fopen_output flxg_stamp;
        write(f, fmt(flxg_time, fixed (0,3)));
        f.fclose;
      else
        // otherwise exit with an error
        println "Not deleting cache, exiting with error 1";
        System::exit(1);
      done
    done
    if NOOPTIMISE == 0 do
      debugln "Set C++ compiler optimisation switches";
      CCFLAGS=CCFLAGS+" " + OPTIMISE;
    else
      debugln "What, no optimisation?";
    done
    // Note we have to do it this way so the -f switches turn
    // off optimisations previously introduced (order matters)
    CCFLAGS += EXTRA_CCFLAGS;
    PKGCONFIG=quote(Filename::join$ List::list(FLX_INSTALL_DIR,"bin","flx_pkgconfig"));
    debugln$ "Felix package manager program is "+PKGCONFIG;

    return OK[string]("");
  }
 
  method fun flx_compile(fn:string) = {
    var path,ext = splitext(fn);
    var dir,base = Filename::split1(path);
    debugln$ "path="+path+", ext="+ext+",dir="+dir+",base="+base;
    if ext != "flx" and ext != "fdoc" and ext != "" do
      // add to list of things to link, and also things to compile
      // if the extension is appropriate
      if List::mem eq of (string * string) compile_exts ext do
        cpps = cpps + " " + fn;
        cppos = cppos + " " + path + "." + EXT_OBJ;
      else
       cppos = cppos + " " + fn;
      done
    done

    debugln "#--------";
    //debugln$ "DONE, option index = "+str(argno);
    debugln$ "path="+path+": dir="+dir+",base="+base+", ext="+ext;
    debugln$ "cpps="+cpps;
    debugln$ "cppos="+cppos;

    if ECHO == 1 do
      fprintln (cerr, "#FLX_INSTALL_DIR="+FLX_INSTALL_DIR);
      fprintln (cerr, "#PKGCONFIG="+PKGCONFIG);
    done

    DLINK_STRING, SLINK_STRING = Config::link_strings(FLX_INSTALL_DIR);

    CONFIG_DIR = Filename::join(FLX_INSTALL_DIR,'config');
    debugln$ "Felix package manager config directory is "+CONFIG_DIR;
    // make a list of any *.cpp files (or other g++ options ..)

    var EXT_OBJ = 
      if STATIC == 0 then EXT_SHARED_OBJ
      else EXT_STATIC_OBJ
      endif
    ;

    // this hack forces a directory name, because executing "prog"
    // can fail if the currect directory is not on the PATH, 
    // or worse, the wrong program can execute. The PATH is not
    // searched if the filename includes a / somewhere so force one in.
    // similarly for dynamic loaders looking for shared libraries
    //
    // It would probably be better to convert any relative filename
    // to an absolute one, however this only makes sense on Unix 
    // since Windows has multiple "drives" it is much harder to
    // do the conversion.
    dir = 
      if dir != "" then dir 
      else "."
      endif
      ;


    debugln$ "FileDir= " + dir;
    rel_filebase = if dir == "." then base else Filename::join(dir,base);
    debugln$ "Rel_filebase= " + rel_filebase;
    debugln$ "Given Extension=" + ext;
    // this is a hack! We should resolve the filename first.
    var use_ext = if ext != "" then "."+ext else
      #{ 
       var flxt = dfiletime (rel_filebase+".flx",past_time);
       var fdoct = dfiletime (rel_filebase+".fdoc",past_time);
       return 
         if flxt > fdoct then ".flx"
         elif fdoct > flxt then ".fdoc"
         else ""
       ;
    }
    ;
    debugln$ "Computed Extension=" + use_ext;
    filebase = Directory::mk_absolute_filename$ rel_filebase;
    debugln$ "User program base is " + filebase;
    cpp_filebase =
      match BUNDLE_DIR with
      | Some ?dir => Filename::join(dir,Filename::basename filebase)
      | None =>if OUTPUT_DIR=="" then filebase 
           else cache_join(OUTPUT_DIR,filebase) 
           endif
      endmatch;         
    debugln$ "C++ file base is " + cpp_filebase;

    // Find absolute pathname

    if path == "" do
      fprint$ cerr, ("No such felix program: "+path+"\n");
      System::exit(1);
    done


    if LINKER_OUTPUT_FILENAME == "" do
      if STATIC == 0 do // dynamic
        LINKER_OUTPUT_FILENAME = filebase+EXT_SHLIB;
      else
        LINKER_OUTPUT_FILENAME = filebase+EXT_EXE;
      done
    done
    LINKER_OUTPUT_FILENAME =  Directory::mk_absolute_filename LINKER_OUTPUT_FILENAME; 

    val args = USER_ARGS;
    debugln$ "Target program args = "+args;

    var INCLUDE_DIR=quote("-I"+Filename::join(FLX_INSTALL_DIR,"lib","rtl")) + 
      " "+quote("-I"+Filename::join(FLX_INSTALL_DIR,"config","target"));
    debugln$ "C++ Include directory for Felix library " + INCLUDE_DIR;

    var FLXLIB=quote("-I"+Filename::join(FLX_INSTALL_DIR,"lib"));
    var STDLIB=list("std","web");
    if NOSTDLIB == 1 do
      FLXLIB="";
      STDLIB=Empty[string];
    done

    var DEBUGSWITCH="";
    DEBUG_COMPILER == 1?? DEBUGSWITCH=" --debug";

    var STATIC_ENV="";
    DEBUG_COMPILER == 1?? STATIC_ENV="env FLX_DEBUG=1 ";

    var cmd = "";
    debugln$ "RECOMPILE="+str RECOMPILE;
    debugln$ "RUNIT="+str RUNIT;
    if SHOWCODE == 1 do {
      var prg = 
        if use_ext == "" then "// No file "+filebase+".(flx|fdoc) found"
        else load(filebase+"."+use_ext)
      ;
      print prg;
    }; done

    if RECOMPILE == 0 and RUNIT == 1 and CLEAR_CACHE == 0 do
      // not (--force or -c)
      debugln "Checking to see if the binary is uptodate";
      var xtime = dfiletime(LINKER_OUTPUT_FILENAME,past_time);
      var srctime = cal_dep_time (filebase);

      debugln$ "Filebase = " + filebase; 
      debugln$ "Binary time = " + strfiletime (xtime);
      debugln$ "src time = " + strfiletime (srctime);
debugln$ (">>"+str(cache_time));
      debugln$ "cache time = " + strfiletime (cache_time);
      if STATIC == 0 do
        if xtime > srctime and xtime > cache_time do
          debugln$ "Running dynamically linked binary";
          match calpackages() with
          |ERR[string] (?e,?m) => return ERR[string](e,m);
          |_ => {}();
          endmatch;
          cmd=FLXRUN+DRIVER_EXE+DEBUGSWITCH+" "+ quote(LINKER_OUTPUT_FILENAME)+" "+args;
          if STDOUT != "" do cmd=cmd + " > "+STDOUT; done
          debugln$ "Uptodate shared lib: Running command " + cmd;
          match perr(system(cmd)) with
          |ERR[string] (?e,?m)=> return ERR[string](e,m);
          |_ => {}();
          endmatch;
        else
          debugln$ "Dynamically linked binary out of date or non-existant";
        done
      else
        if xtime > srctime and xtime > cache_time do
          debugln$ "Running statically linked binary";
          cmd=STATIC_ENV+" "+quote(LINKER_OUTPUT_FILENAME)+" "+args;
          if STDOUT != "" do cmd=cmd + " > "+STDOUT; done
          debugln$ "Uptodate executable: Running command " + cmd;
          match perr(system(cmd)) with
          |ERR[string] (?e,?m)=> return ERR[string](e,m);
          |_ => {}();
          endmatch;
        else
          debugln$ "Statically linked binary out of date or non-existant";
        done
      done
    done

    // Need Felix and c++ compile, then run it
    dbug??println$ "RECOMPILING!!";

    var FLXFLAGS="--inline="+str(INLINE);
    if OUTPUT_DIR != "" do FLXFLAGS += ' '+quote('--output_dir=' + str(OUTPUT_DIR)); done;
    for dir in BUNDLE_DIR do FLXFLAGS += ' ' + quote('--bundle_dir=' + dir); done;
    if CACHE_DIR != "" do FLXFLAGS += " "+quote("--cache_dir=" + CACHE_DIR); done
    if COMPILER_PHASE != "" do FLXFLAGS += ' --compiler-phase=' + COMPILER_PHASE; done;

    var FCMD="";

    if FELIX == 1 do
      var stdlibs = cat ' ' STDLIB;
      FCMD=List::cat ' ' (List::list (
        QUOTE_FLXG,
        VERBOSE, FLXFLAGS, FLXLIB,
        INCLUDE_DIRS, "--syntax="+STDGRAMMAR, STDIMPORT, IMPORTS)) + 
        ' ' + stdlibs + 
        ' ' + quote(filebase+use_ext)
      ;
      debugln$ "Felix command="+FCMD;
  
      result=system(FCMD);
      if result != 0 do 
        debugln "Felix compilation failed";
          match perr(system(cmd)) with
          |ERR[string] (?e,?m)=> return ERR[string](e,m);
          |_ => {}();
          endmatch;
      done
      debugln "Felix compilation succeeded";
      match calpackages() with |OK[string] => {}(); |ERR[string](?e,?m) => return ERR[string](e,m);endmatch;
      write_include_file(cpp_filebase);
    else
      debugln "Felix compilation skipped by switch";
      match calpackages() with |OK[string] => {}(); |ERR[string](?e,?m) => return ERR[string](e,m);endmatch;
       // need to do this here to set linker switches
    done 
    return OK[string]("");
  }

  method fun c_compile() = {
    var CCMD="";
    var LCMD="";
    var cmd = "";
    var DEBUGSWITCH="";
    DEBUG_COMPILER == 1?? DEBUGSWITCH=" --debug";
    val args = USER_ARGS;
    debugln$ "Target program args = "+args;
    var INCLUDE_DIR=quote("-I"+Filename::join(FLX_INSTALL_DIR,"lib","rtl")) + 
      " "+quote("-I"+Filename::join(FLX_INSTALL_DIR,"config","target"));
    debugln$ "C++ Include directory for Felix library " + INCLUDE_DIR;
    var STATIC_ENV="";
    DEBUG_COMPILER == 1?? STATIC_ENV="env FLX_DEBUG=1 ";
    if CCOMPILEIT == 0 do
      debugln "C++ compilation skipped by switch";
    elif STATIC == 0 do
      debugln "Dynamic linkage";
      CCMD=List::cat ' ' (List::list (
      CCOBJ_DLLIB, CCFLAGS, "-DTARGET_BUILD",
        INCLUDE_DIR, INCLUDE_DIRS, MACROS,
        cpps, quote(cpp_filebase+".cpp"),
        SPEC_OBJ_FILENAME+quote(cpp_filebase+EXT_OBJ)));
      LCMD=List::cat ' ' (List::list (
        CCLINK_DLLIB, CCFLAGS,
        cppos, quote(cpp_filebase+EXT_OBJ),
        SPEC_EXE_FILENAME+quote(LINKER_OUTPUT_FILENAME),
        LINK_STRING));
      debugln$ "C++ command="+CCMD;
      result = system(CCMD);
      if LINKIT == 0 do
        debugln "Not linking program selected by switch";
      elif result == 0 do
        debugln$ "Link command="+LCMD;
        result = system(LCMD);
        if result == 0 do
          if RUNIT == 1 do
            if TIME == 1 do
              cmd=List::cat ' ' (List::list (
                TIMECMD,
                FLXRUN+DRIVER_EXE+DEBUGSWITCH,
                quote(LINKER_OUTPUT_FILENAME), args));
            else
              cmd=List::cat ' ' (List::list (
                FLXRUN+DRIVER_EXE+DEBUGSWITCH,
                quote(LINKER_OUTPUT_FILENAME), args));
            done
            if STDOUT != "" do cmd=cmd+" > " +quote(STDOUT); done
            debugln$ "Run command="+cmd;
            if SNORT do
              match get_stdout_from(cmd) with
              |?e,?m when e == 0 => return OK[string](m);
              |?e,?m => return ERR[string](e,m);
              endmatch;
            else
              match perr(system(cmd)) with
              |ERR[string] (?e,?m)=> return ERR[string](e,m);
              |_ => {}();
              endmatch;
            done
            //pexit(system(cmd));
          else
            debugln "Not running program selected by switch";
          done
        else
          debugln "Dynamic linkage failed";
        done
      else
        debugln "C++ compilation failed";
      done
    else
      debugln "Static linkage";
      var CCMD1=List::cat ' ' (List::list (
        CCOBJ_STATIC_LIB,
        CCFLAGS, "-DTARGET_BUILD",
        "-DFLX_STATIC_LINK", INCLUDE_DIR, INCLUDE_DIRS,
        MACROS, cpps, 
        quote(cpp_filebase+"_static_link_thunk.cpp"),
        SPEC_OBJ_FILENAME+quote(cpp_filebase+"_static_link_thunk"+EXT_OBJ)));

      var CCMD2=List::cat ' ' (List::list (
        CCOBJ_STATIC_LIB,
        CCFLAGS, "-DTARGET_BUILD",
        "-DFLX_STATIC_LINK", INCLUDE_DIR, INCLUDE_DIRS,
        MACROS, cpps, 
        quote(cpp_filebase+".cpp"),
        SPEC_OBJ_FILENAME+quote(cpp_filebase+EXT_OBJ)));


      LCMD=List::cat ' ' (List::list 
        (
        CCLINK_STATIC, SPEC_EXE_FILENAME+quote(LINKER_OUTPUT_FILENAME),
        quote(cpp_filebase+"_static_link_thunk"+EXT_OBJ),
        quote(cpp_filebase+EXT_OBJ)
        ) + 
        DRIVER_OBJS + 
        list( cppos, LINK_STRING))
      ;
      debugln$ "C++ command="+CCMD1;
      result=system(CCMD1);
      if result != 0 do
        debugln$ "C++ compilation failed";
      else
        result=system(CCMD2);
        debugln$ "C++ command="+CCMD2;
        if result != 0 do
          debugln$ "C++ compilation failed";
        done
      done

      if LINKIT == 0 do
        debugln "Not linking based on switch";
      elif result == 0 do
        debugln$ "Link command="+LCMD;
        result=system(LCMD);
        if result == 0 do
          // rm -f "$base.cpp"
          if RUNIT == 1 do
            if TIME == 1 do
              cmd= List::cat ' ' (List::list (
                TIMECMD, STATIC_ENV, quote(LINKER_OUTPUT_FILENAME), args));
            else
              cmd=List::cat ' ' (List::list (
                STATIC_ENV, quote(LINKER_OUTPUT_FILENAME),args));
            done
            if STDOUT != "" do cmd=cmd + " > "+STDOUT; done
            debugln$ "Run command="+cmd;
            match perr(system(cmd)) with
            |ERR[string] (?e,?m)=> return ERR[string](e,m);
            |_ => {}();
            endmatch;
            //pexit(system(cmd));
          else
            debugln "Not running program selected by switch";
          done
        else
          debugln "Static Linkage failed";
        done
      else
        debugln "C++ compilation failed";
      done
    done
    return perr(result);
    //pexit(result); 
  }

  method gen flx_and_c_compile(src:string) =>
    match flx_compile(src) with
      |OK[string] => c_compile()
      |?e => e
      endmatch;

  method gen init_and_flx_and_c_compile(src:string) =>
    match init_compiler() with
    |OK[string] => 
      match flx_compile(src) with
      |OK[string] => c_compile()
      |?e => e
      endmatch
    |?e =>  e
    endmatch;
 
}


export fun setup of (string) as "setup";
export fun libflx of () as "libflx";
