@import config

@head(1,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID

@def make_executable(path):
   import stat
   try:
     mode = os.stat(path).st_mode
     os.chmod(path, mode | stat.S_IXUSR)
   except OSError, e:
     print e

@h = tangler('script/bin2hex.py')
@select(h)
# convert a binary file to hex
import sys
fn = sys.argv[1]
f = open(fn)
data = f.read()
f.close()
counter = 0
for ch in data:
  print ("%02x" % ord(ch)),
  counter = counter + 1
  if counter == 8:
    print
    counter = 0
print

@h = tangler('script/fcount.py','python')
@select(h)
import glob
import os
import sys
if '' not in sys.path: sys.path = ['']+sys.path
from flxbuild.flxutil import xqt

try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

try:
  key = sys.argv[2]
except:
  key = "std"

try:
  globspec = sys.argv[3]
except:
  globspec = "tut/examples/*.hpp"

print "function counter: STATS FILE",filename, "KEY", key, "GLOB",globspec
dict = {}
try:
  execfile (filename)
except:pass

files = glob.glob(globspec)

for file in files:
  cmd = 'egrep "//PROC|//FUNCTION" ' + file + ' | wc -l'
  output = xqt(cmd)[0][:-1]
  x = int(output)
  try:
    d= dict[file]
  except:
    dict[file]={}
    d = dict[file]
  d[key]=x

f = open(filename,"w")
f.write("dict="+repr(dict))
f.close()

@h = tangler('script/pfcount.py','python')
@select(h)
import glob
import os
import sys
try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

only_nonopt = 0
try:
  x = sys.argv[2]
except:
  only_nonopt = 1

dict = {}
try:
  execfile (filename)
except:pass

keys = {}
i = 0
for k in dict.keys():
  i = max(i,len(k))
  d = dict[k]
  for key in d.keys():
    keys[key]=None

keys = keys.keys()
j=0
for k in keys:
  j = max(j,len(k))

print "Function counts for test programs"
print "================================="
print
print ("%-"+str(i+2)+"s") % "File" + "    ",
for t in keys:
  print ("%"+str(j+2)+"s") % t,
print
print "--------"

skeys = dict.keys()
skeys.sort()

for k in skeys:
  d = dict[k]
  x= ("%-"+str(i+2)+"s") % k + "..  "
  discard = 0
  for t in keys:
    v = pkgdict.get(t,-1)
    if v == -1:
      v = ""
    elif (v == 1 or v == 0) and t == "inline" and only_nonopt:
      discard = 1
      break
    else:
      v = str(v)
    v = ("%"+str(j+2)+"s") % v
    x = x+v
  if not discard: print x

@h = tangler('script/mk_expect','python')
@select(h)
import glob
import sys
for k in sys.argv[1:]:
  files = glob.glob(k+'/*.output')
  print '@head(1,"Expected outputs for '+k+'")'
  for i in files:
    j = i[:-7]+'.expect'
    print '@head(2,"'+j+'")'
    print '@select(tangler("'+j+'","data"))'
    f = open(i,"r")
    for l in f: print l,
    f.close()


@h = tangler('spkgs/tutorial.py')
@select(h)
pkg_requires = [
  'flx_tutorial',
  'flx_tut_macro',
  'flx_tut_bind',
  'flx_tut_migrate'
  ]

iscr_source = [
  'lpsrc/flx_tutorial',
  'lpsrc/flx_tut_macro',
  'lpsrc/flx_tut_bind',
  'lpsrc/flx_tut_migrate',
  ]

@h = tangler('spkgs/flx_maker.py')
@select(h)
iscr_source = ['lpsrc/flx_maker.pak']

weaver_directory = 'doc/flx/flx_maker/'

@h = tangler('umk','python')
@select(h)
#!/usr/bin/env python
import os
import sys

os.execl(
    sys.executable,
    sys.executable,
    os.path.join('script', 'maker'),
    *sys.argv[1:])
@make_executable('umk')

@select(tangler('mk','python'))
#!/usr/bin/env python
import os
import sys
import time

from flxbuild.flxutil import Tee, tee_cmd

def main():
    cmd = [sys.executable, 'umk'] + sys.argv[1:]
    stdout = Tee()
    try:
        return tee_cmd(cmd, stdout)
    finally:
        f = open('mk_' + time.strftime('%Y-%m-%d-%H%M') + '.log', 'w')
        print >> f, stdout.getvalue()

if __name__ == '__main__':
    sys.exit(main())
@make_executable('mk')

@select(tangler('spkgs/__init__.py'))
@select(tangler('mkplugins/__init__.py'))
@doc()

@select(tangler('mkplugins/man.py'))
import os
import glob

from flxbuild.process import Process

class man(Process):
  help = 'make the man pages'

  def runme(self, *args):
    print "GENERATING MAN PAGES"
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("doc/htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = os.path.splitext(file)[0]
        self.shell(
          "man2html man/man1/" + file +
          '| sed -e "s%<A HREF=\\"[^<]*cgi-bin/man/man2html?1+\(.*\)\\">%<A HREF=\\"\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "doc/htmlman/" + basename+'_1.html',
        )
    except:pass

@select(tangler('mkplugins/impldoc.py'))
import os

from flxbuild.process import Process
from flxbuild.flxutil import erasedir

class impldoc(Process):
  help = 'make the ocaml compiler documentation'

  def __init__(self, *args, **kwds):
    super(impldoc, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict, *args):
    if self.ran:
      return
    self.ran = True

    print "GENERATING OCAMLDOCS"
    erasedir(os.path.join('doc', 'impldoc'))
    os.mkdir(os.path.join('doc', 'impldoc'))
    try:
      self.shell('ocamldoc', '-html',
        '-I', 'src',
        '-d', os.path.join('doc', 'impldoc'),
        os.path.join('src', '*.mli'),
      )
      self.shell('ocamldoc', '-latex',
        '-I', 'src',
        '-d', os.path.join('doc', 'impldoc', 'flx_impl.tex'),
        os.path.join('src', '*.mli'),
      )
      self.shell('(cd doc/impldoc; latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex)')
    except:
     pass # well ocamldoc is full of bugs ..

@select(tangler('mkplugins/rtldoc.py'))
import os

from flxbuild.process import Process

class rtldoc(Process):
  help = 'make the runtime language documentation'

  def __init__(self, *args, **kwds):
    super(rtldoc, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict, *args):
    if self.ran:
      return
    self.ran = True

    print "GENERATING RTLDOCS"
    try:
      self.shell('doxygen', os.path.join('misc', 'doxconf.dox'))
    except:
      pass

@select(tangler('mkplugins/gramdoc.py'))
import os

from flxbuild.process import Process
from flxbuild.flxutil import ExecutionError

class gramdoc(Process):
  help = 'make the syntax documentation'

  def __init__(self, *args, **kwds):
    super(gramdoc, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict, *args):
    if self.ran:
      return
    self.ran = True

    print "GENERATING SYNTAX DOCUMENTATION"
    f = open(os.path.join('tmp', 'xx.flx'), 'w')
    f.write("#import <nugram.flxh>\n")
    f.write("open syntax felix\n")
    f.close()

    try:
      self.shell(os.path.join('bin', 'flxp'),
        '-Ilib',
        '--document-grammar',
        os.path.join('tmp', 'xx'),
      )
    except ExecutionError:
      pass

@select(tangler('mkplugins/typeclassdoc.py'))
import os
import shutil

from flxbuild.process import Process
from flxbuild.flxutil import mkdirs, ExecutionError

class typeclassdoc(Process):
  help = 'make the typeclass documentation'

  def __init__(self, *args, **kwds):
    super(typeclassdoc, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict, *args):
    if self.ran:
      return
    self.ran = True

    print "GENERATING TYPECLASS and MODULE DOCUMENTATION"
    mkdirs(os.path.join('doc', 'moduledoc'))
    shutil.copy(os.path.join('misc', 'plus.gif'),  os.path.join("doc", "moduledoc"))
    shutil.copy(os.path.join('misc', 'minus.gif'), os.path.join("doc", "moduledoc"))
    shutil.copy(os.path.join('misc', 'dot.gif'),   os.path.join("doc", "moduledoc"))

    try:
      self.shell(os.path.join('bin', 'flxd'),
        '-Ilib',
        '--import=flx.flxh',
        '--document-typeclass',
        os.path.join('misc', 'ldoc'),
      )
    except ExecutionError:
      pass


@select(tangler('misc/ldoc.flx'))
#import <flx.flxh>
include "std";
include "judy";
include "pthread";
include "flx_demux";
include "flx_faio";
include "flx_stream";
include "tre";

include "mmap";

include "glob";
include "flx_gmp";

include "mpi/mpi";

include "SDL/SDL_active";
include "SDL/SDL_audio";
include "SDL/SDL_cdrom";
include "SDL/SDL_endian";
include "SDL/SDL_error";
include "SDL/SDL_events";
include "SDL/SDL";
include "SDL/SDL_framerate";
include "SDL/SDL_gfxPrimitives";
include "SDL/SDL_gfxPrimitives_font";
include "SDL/SDL_imageFilter";
include "SDL/SDL_image";
include "SDL/SDL_joystick";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_mixer";
include "SDL/SDL_mouse";
include "SDL/SDL_mutex";
include "SDL/SDL_net";
include "SDL/SDL_opengl";
include "SDL/SDL_rotozoom";
include "SDL/SDL_rwops";
include "SDL/SDL_sound";
include "SDL/SDL_timer";
include "SDL/SDL_ttf";
include "SDL/SDL_types";
include "SDL/SDL_version";
include "SDL/SDL_video";

@select(tangler('mkplugins/build_ocaml_grammar.py'))
from flxbuild.process import Process

import config

class build_ocaml_grammar(Process):
  def runme(self, pkg, LEXS, PARSES, PGENPARSES,DYPARSES):
    if not (LEXS or PARSES or PGENPARSES or DYPARSES):
      return

    print "CAML BUILDING GRAMMAR", pkg

    if LEXS:
      config.HOST_OCAML.gen_lexer(LEXS,
          outdir='build')

    if PARSES:
      config.HOST_OCAML.gen_parser(PARSES,
          outdir='build')

    if PGENPARSES:
      config.HOST_OCAML.gen_pgen_parser(PGENPARSES,
          outdir='build')

    if DYPARSES:
      config.HOST_OCAML.gen_dypgen_parser(DYPARSES,
          FLAGS=['--prio-pt', '--pv-obj', '--noemit-token-type'],
          outdir='build')
@doc()

@select(tangler('mkplugins/build_ocaml_modules.py'))
import os

from flxbuild.process import Process

import config

#ocaml compilation
class build_ocaml_modules(Process):
  def runme(self, pkg, INTERFACES, IMPLEMENTATIONS, PACKS, INCLUDES):
    if not (INTERFACES or IMPLEMENTATIONS):
      return []

    print "CAML COMPILING", pkg

    kwds = dict(
      outdir='build',
      include_paths=[os.path.join('build', i) for i in INCLUDES],
      packs=PACKS,
      debug=self.debug,
      profile='profile' in self.options,
      optimise='optimise_felix' in self.options,
    )

    config.HOST_OCAML.compile_interface(INTERFACES, **kwds)

    return config.HOST_OCAML.compile_module(IMPLEMENTATIONS,
      bytecode='bytecode' in self.options,
      **kwds)
@doc()

@select(tangler('mkplugins/build_ocaml_libraries.py'))
from flxbuild.process import Process

import config

#ocaml compilation
class build_ocaml_libraries(Process):
  def runme(self, IMPLEMENTATIONS, lib):
    if not IMPLEMENTATIONS:
      return

    print "CAML CREATING LIBRARY", lib
    return config.HOST_OCAML.link_lib(IMPLEMENTATIONS, lib,
      bytecode='bytecode' in self.options,
      outdir='build',
    )
@doc()

@select(tangler('mkplugins/build_ocaml_exes.py'))
import os

from flxbuild.process import Process

import config

#ocaml compilation
class build_ocaml_exes(Process):
  def runme(self, EXES, OLIBRARIES, INCLUDES):
    # finally, mainline *.cmx or cma files to link to executables
    if not EXES:
      return

    print "CAML LINKING EXECUTABLES"
    output_exes = []
    for exe in EXES:
      dst = os.path.join('bin', os.path.basename(exe))
      output_exe = config.HOST_OCAML.link_exe(
        [exe + '.ml'],
        dst + config.HOST_OCAML.options.EXT_EXE,
        bytecode='bytecode' in self.options,
        include_paths=[os.path.join('build', os.path.dirname(exe))] + \
          [os.path.join('build', i) for i in INCLUDES],
        libs=OLIBRARIES,
      )

      output_exes.append(output_exe)

    return output_exes
@doc()

@select(tangler('mkplugins/build_host_ocaml.py'))
import os
import shutil

from flxbuild.process import Process, processes
from flxbuild.flxutil import unix2native

import config

class build_host_ocaml(Process):
  def copy_mli2ml(self, MLIS):
    for f in MLIS:
      f = unix2native(f)
      src = f+'.mli'
      dst = f+'.ml'
      if not self.quiet: print 'copying file', src, '->', dst
      shutil.copyfile(src, dst)


  def runme(self, pkg, pkgdict, *args):
    RAW_INTERFACES = pkgdict.get('caml_raw_interfaces', [])
    self.copy_mli2ml(RAW_INTERFACES)

    if config.HOST_OCAML.options.HAVE_OCAMLBUILD:
      return processes['build_ocamlbuild'].runme(pkg, pkgdict)

    LEXS = pkgdict.get("caml_lexes", [])
    PARSES = pkgdict.get("caml_parses", [])
    PGENPARSES = pkgdict.get("caml_pgenparses", [])
    DYPARSES = pkgdict.get("caml_dyparses", [])

    processes['build_ocaml_grammar'].runme(pkg, LEXS, PARSES, PGENPARSES, DYPARSES)

    INTERFACES = pkgdict.get("caml_interfaces", [])
    IMPLEMENTATIONS = pkgdict.get("caml_implementations", [])
    PACKS = pkgdict.get("caml_pack", [])
    EXES = pkgdict.get("caml_exes", [])
    INCLUDES = pkgdict.get("caml_include_paths", [])


    objects = processes['build_ocaml_modules'].runme(pkg, INTERFACES, IMPLEMENTATIONS, PACKS, INCLUDES)

    lib = pkgdict.get('caml_provide_lib', os.path.join('src', pkg + 'lib'))
    processes['build_ocaml_libraries'].runme(objects, lib)
    OLIBRARIES = pkgdict.get("caml_require_libs", [])

    processes['build_ocaml_exes'].runme(EXES, OLIBRARIES, INCLUDES)
@doc()

@select(tangler('mkplugins/build_ocamlbuild.py'))
import os
import shutil

from flxbuild.process import Process
from flxbuild.flxutil import mkdirs

import config

class build_ocamlbuild(Process):
  def runme(self, pkg, pkgdict, *args):
    EXES = pkgdict.get('caml_exes', [])

    for exe in EXES:
      if BYTECODE:
        bin = exe + '.byte'
      else:
        bin = exe + '.native'

      self.shell(config.OCAMLBUILD, bin)

      mkdirs('bin')
      shutil.copy(os.path.join('_build', bin), 'bin')
@doc()

@select(tangler('mkplugins/build_host_tools.py'))
import os
import shutil

from flxbuild.process import Process
from flxbuild.flxutil import unix2native, mkdirs

import config

class build_host_tools(Process):
  def copy_hpp2rtl(self, HPPS):
    for path in HPPS:
      f = os.path.join(config.FLX_DIR, path)
      if os.path.exists(f):
        src = f
      else:
        src = path
      src = unix2native(src)
      dst = os.path.join(config.FLX_RTL_DIR, os.path.basename(path))

      if not self.quiet: print 'copying file', src, '->', dst
      mkdirs(os.path.dirname(dst))
      shutil.copyfile(src, dst)


  def runme(self, pkg, pkgdict, *args):
    HPPS = pkgdict.get("rtl_interfaces",[])
    self.copy_hpp2rtl(HPPS)

    CCS = pkgdict.get("host_cc_ccs",[])
    CPPS = pkgdict.get("host_cpp_cpps",[])
    EXES = pkgdict.get("host_exes",[])
    LIBS = pkgdict.get("host_exes_require_libs",[])
    MACROS =pkgdict.get("host_macros",[])
    INCLUDES=pkgdict.get("host_include_path",[])
    INCLUDE_PATH=[os.path.join(config.FLX_DIR, i) for i in INCLUDES]

    if len(CCS)+len(CPPS)+len(EXES)+len(LIBS) == 0:
      return

    print "BUILDING HOST TOOLS"
    pkglib = None

    if CCS:
      print "HOST C COMPILING", pkg
      pkglib = "lib"+pkg+"_host_static"

      config.HOST_C.build_static_rtl(CCS, 'hostlib' + os.sep + pkglib,
        outdir='build',
        include_paths=INCLUDE_PATH+[config.FLX_RTL_DIR, config.FLX_HOST_CONFIG_DIR, "elk"],
        macros=MACROS+["FLX_STATIC_LINK"],
      )

    if CPPS:
      print "HOST C++ COMPILING", pkg
      pkglib = "lib"+pkg+"_host_static"

      config.HOST_CXX.build_static_rtl(CPPS, 'hostlib' + os.sep + pkglib,
        outdir='build',
        include_paths=INCLUDE_PATH+[config.FLX_RTL_DIR, config.FLX_HOST_CONFIG_DIR, "elk"],
        macros=MACROS+["FLX_STATIC_LINK"],
      )

    for x in CCS+CPPS:
      f = x + config.HOST_CXX.options.EXT_STATIC_OBJ

    kwds = {\
      'include_paths': INCLUDE_PATH+[config.FLX_RTL_DIR, config.FLX_HOST_CONFIG_DIR, "elk"],
      'macros': MACROS+["FLX_STATIC_LINK"],
    }

    if pkglib:
      kwds['lib_paths'] = ['hostlib']
      kwds['libs'] = [pkglib]

    for src, bin in EXES:
      config.HOST_CXX.build_static_program(src, bin, **kwds)
@doc()

@select(tangler('mkplugins/build_testfile.py'))
import os

from flxbuild.process import Process
from flxbuild.flxutil import mkdirs, Tee, ExecutionError

import config

class build_testfile(Process):
  def runme(self, root, localpath, log):
    testfile = os.path.join(root, localpath)

    optimise_c = self.optimise or "optimise_c" in options
    mode = "std"
    if optimise_c: mode = "Optimised"

    log.write('TRANSLATING %s\n' % testfile)

    buildpath = os.path.join('build', localpath)
    outbase = os.path.splitext(buildpath)[0]
    resfilename = outbase + ".resh"
    incfilename = outbase + ".includes"

    builddir = os.path.dirname(buildpath)
    mkdirs(builddir)

    try:
      self.shell(os.path.join('bin', 'flxg'),
        '-Ilib',
        '-I' + os.path.dirname(testfile),
        '--cache_dir=' + builddir,
        '--output_dir=' + builddir,
        '--elkhound=' + os.path.join('bin', 'flx_elkhound'),
        '--import=flx.flxh',
        'std',
        os.path.splitext(os.path.basename(testfile))[0],
        log=log,
      )
    except ExecutionError, e:
      log.write('TESTFILE -- ERROR! %s\n' % testfile)
      raise e

    cflags = self.shell(os.path.join('bin', 'flx_pkgconfig'),
      '--path=config',
      '--field=cflags',
      '@' + resfilename,
      log=log,
    )
    cflags = cflags[0].strip() + " "

    includes = self.shell(os.path.join('bin', 'flx_pkgconfig'),
      '--path=config',
      '--field=includes',
      '@' + resfilename,
      log=log,
    )
    includes = includes[0].strip().split()
    f = open(incfilename,"w")
    for i in includes:
        f.write("#include " + i + "\n")
    f.close()


    #log.write('Compiling generated code of %s\n' % testfile)
    try:
      if config.SUPPORT_DYNAMIC_LOADING:
        log.write("COMPILING GENERATED C++ TEST CODE: %s (dynamic)\n" % mode)
        log.flush()

        dlibs = self.shell(os.path.join('bin', 'flx_pkgconfig'),
          '-r',
          '--path=config',
          '--field=provides_dlib',
          '--field=requires_dlibs',
          '@' + resfilename,
          log=log,
        )
        dlibs = dlibs[0].strip() + " "

        config.TARGET_CXX.build_shared_dll(outbase,
            #outdir='build',
            include_paths=[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
            optimise=optimise_c,
            debug=self.debug,
            CFLAGS=cflags,
            lib_paths=[config.TARGET_CXX.options.SHLIB_DIR],
            LDFLAGS=dlibs,
            log=log)

      if config.SUPPORT_STATIC_LINKAGE:
        log.write("COMPILING GENERATED C++ TEST CODE: %s (static)\n" % mode)
        log.flush()

        driver = self.shell(os.path.join('bin', 'flx_pkgconfig'),
          '-r',
          '--keeprightmost',
          '--path=config',
          '--field=flx_requires_driver',
          '@' + resfilename,
          log=log,
        )
        driver = driver[0].strip()
        if driver == '': driver = 'flx_run'

        slibs = self.shell(os.path.join('bin', 'flx_pkgconfig'),
          '-r',
          '--keeprightmost',
          '--path=config',
          '--field=provides_slib',
          '--field=requires_slibs',
          driver,
          '@' + resfilename,
          log=log,
        )
        slibs = slibs[0].strip()
        #log.write("slibs=%s\n" % slibs)

        driver = os.path.join(
          config.FLX_RTL_DIR,
          driver + config.TARGET_CXX.options.EXT_STATIC_OBJ,
        )
        #log.write('static driver =%s\n' % driver)

        config.TARGET_CXX.build_felix_static(outbase,
          #outdir='build',
          objects=[driver],
          include_paths=[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
          optimise=optimise_c,
          debug=self.debug,
          macros=["FLX_STATIC_LINK"],
          CFLAGS=cflags,
          lib_paths=[config.FLX_RTL_DIR],
          libs=[],
          LDFLAGS=slibs,
          log=log)

      #log.write('TESTFILE -- OK! %s\n' % testfile)
    except ExecutionError, e:
      log.write('TESTFILE -- ERROR! %s\n' % testfile)
      raise e

    return outbase

@select(tangler('mkplugins/virgin.py'))
import os
import sys
import glob

from flxbuild.process import Process
from flxbuild.flxutil import erasefile

import config

#cleans everything
class virgin(Process):
  help = 'clean and remove all the sources'

  def runme(self, *args):
    for d in [ \
        os.path.join("judy", "JudyCommon"),
        os.path.join("judy", "Judy1"),
        os.path.join("judy", "JudyL"),
        os.path.join("judy", "JudySL"),
        os.path.join("judy", "JudyHS"),
        "judy",
        os.path.join("bagley", "data"),
        os.path.join("bagley", "felix"),
        "bagley",
        "bin",
        os.path.join("cpkgs", "build"),
        os.path.join("cpkgs", "host"),
        os.path.join("cpkgs", "target"),
        "cpkgs",
        os.path.join("demos", "faio"),
        os.path.join("demos", "sdl"),
        "demos",
        "demux",
        os.path.join("doc", "elkhound"),
        os.path.join("doc", "flx"),
        os.path.join("doc", "flxcc"),
        os.path.join("doc", "gmp"),
        os.path.join("doc", "grammar"),
        os.path.join("doc", "gsl"),
        os.path.join("doc", "htmlman"),
        os.path.join("doc", "impldoc"),
        os.path.join("doc", "mmap"),
        os.path.join("doc", "opengl"),
        os.path.join("doc", "refman"),
        os.path.join("doc", "rtl"),
        os.path.join("doc", "sdl"),
        os.path.join("doc", "test"),
        os.path.join("doc", "tutorial"),
        "doc",
        os.path.join("dypgen", "generators", "dypgen"),
        os.path.join("dypgen", "generators", "pgen"),
        os.path.join("dypgen", "generators"),
        os.path.join("dypgen", "dyplib"),
        "dypgen",
        "elk",
        "faio",
        "flxbuild",
        "hostlib",
        "impldoc",
        os.path.join("lib", "gsl"),
        os.path.join("lib", "mpi"),
        os.path.join("lib", "pari"),
        os.path.join("lib", "GL"),
        os.path.join("lib", "SDL"),
        "lib",
        os.path.join("man", "man1"),
        "man",
        "manifests",
        os.path.join("meta", "godi"),
        os.path.join("meta", "godiva"),
        "meta",
        os.path.join("misc", "vim"),
        os.path.join("misc", "lua"),
        os.path.join("misc", "jedit"),
        "misc",
        "lpsrc-cache",
        "mkplugin",
        "oldebian",
        "pkg",
        os.path.join("pkg-stamps", "test", "regress"),
        os.path.join("pkg-stamps", "test"),
        os.path.join("pkg-stamps", "tut", "embedding"),
        os.path.join("pkg-stamps", "tut", "macros"),
        os.path.join("pkg-stamps", "tut", "migration"),
        os.path.join("pkg-stamps", "tut", "tutorial"),
        os.path.join("pkg-stamps", "tut"),
        "pkg-stamps",
        "pthread",
        "rtl",
        "script",
        os.path.join("speed", "specs"),
        os.path.join("speed", "src", "ada"),
        os.path.join("speed", "src", "c"),
        os.path.join("speed", "src", "felix"),
        os.path.join("speed", "src", "haskell"),
        os.path.join("speed", "src", "java"),
        os.path.join("speed", "src", "ocaml"),
        os.path.join("speed", "src", "pascal"),
        os.path.join("speed", "src"),
        os.path.join("speed", "xlators"),
        "speed",
        "spkgs",
        "src",
        os.path.join("src", "cil"),
        os.path.join("test", "drivers"),
        os.path.join("test", "faio"),
        os.path.join("test", "glob"),
        os.path.join("test", "gmp"),
        os.path.join("test", "mmap"),
        os.path.join("test", "pthread"),
        os.path.join("test", "regress"),
        os.path.join("test", "stdlib"),
        os.path.join("test", "tre"),
        "test",
        "tmp",
        os.path.join("tools", "lua"),
        "tools",
        "tre",
        os.path.join("tut", "embedding"),
        os.path.join("tut", "examples"),
        os.path.join("tut", "macros"),
        os.path.join("tut", "migration"),
        os.path.join("tut", "sdl"),
        os.path.join("tut", "tutorial"),
        "tut",
        "unixem",
        "www",
        ]:
      for f in glob.glob(os.path.join(d, "*")):
        print "Del",f
        erasefile(f)
      try:
        if os.path.exists(d):
          os.rmdir(d)
          print "Rmdir",d
      except:
        print "FAILED Rmdir",d
    for f in glob.glob(os.path.join(config.FLX_LPARCHIVE, "lpsrc", "*.cache")):
      erasefile(f)

    self.shell(
      config.ICSR,
      '--force',
      '--break-on-error',
      '"%s"' % os.path.join(config.FLX_LPARCHIVE, 'lpsrc', 'flx_config.pak'),
    )
    sys.exit(0)

@select(tangler('mkplugins/clean.py'))
import os
import glob

from flxbuild.process import Process
from flxbuild.flxutil import erasefile

import config

# cleans products, but not extracted sources
class clean(Process):
  help = 'remove generated C++ and binaries from test locations'

  def runme(self, *args):
    for d in glob.glob(os.path.join("pkg-stamps", "*")):
      erasefile(d)

    for d in [
      os.path.join("tut", "examples"),
      os.path.join("bagley", "felix"),
      "src","elk","demux","faio","lib","lpsrc","rtl","bin","test",
      ]:
      for e in ["*.hpp","*.so","*.dll","*.cpp","*.hpp",
        "*.par","*.output","*.o","*.obj",
        "*.exp","*.lib",'*.resh','*.par',
        "*.cache","*.a","*.exp","*.exe",
        "*.cmo","*.cma","*.cmi","*.cmx","*.cmxa",
        ]:
        for f in glob.glob(os.path.join(d, e)):
          erasefile(f)

    for f in glob.glob(os.path.join("lib", "*.par")):
      erasefile(f)

    for f in glob.glob(os.path.join(config.FLX_LPARCHIVE, "lpsrc", "*.cache")):
      erasefile(f)

@select(tangler('mkplugins/mkdoc.py'))
import os
import shutil

from flxbuild.process import Process
from flxbuild.flxutil import mkdirs

import config

class mkdoc(Process):
  def __init__(self, *args, **kwds):
    super(mkdoc, self).__init__(*args, **kwds)

    self.already_generated = {}

  def runme(self, pkg, pkgdict, *args):
    mkdirs("pkg-stamps")

    weaver_directory = pkgdict.get("weaver_directory","")
    iscr_source = pkgdict.get("iscr_source",[])
    if iscr_source and weaver_directory:
      print "GENERATING DOCUMENTATION",weaver_directory

      iscr_source = filter(lambda x: x not in self.already_generated, iscr_source)

      mkdirs(weaver_directory)
      shutil.copy(os.path.join('misc', 'plus.gif'),        weaver_directory)
      shutil.copy(os.path.join('misc', 'minus.gif'),       weaver_directory)
      shutil.copy(os.path.join('misc', 'dot.gif'),         weaver_directory)
      shutil.copy(os.path.join('misc', 'interscript.css'), weaver_directory)
      shutil.copy(os.path.join('misc', 'user.css'),        weaver_directory)

      for src in iscr_source:
        self.shell(config.ISCR,
          '--language=en',
          '--weaver=web',
          '--weaver=latex',
          '--passes=2',
          '--weaver-directory=' + weaver_directory,
          os.path.join(config.FLX_LPARCHIVE, src),
        )

        self.already_generated[src] = 1

@select(tangler('mkplugins/build_target_rtl_dynamic.py'))
import os
from flxbuild.process import Process

import config

class build_target_rtl_dynamic(Process):
  def runme(self, pkg, pkgdict, *args):
    if not config.SUPPORT_DYNAMIC_LOADING:
      return

    CCS = pkgdict.get("cc_ccs",[])
    CPPS = pkgdict.get("cpp_cpps",[])

    if not CCS and not CPPS:
      return

    BUILD_MACRO = pkgdict.get("build_macro","ERROR!")
    EXTRA_CFLAGS = pkgdict.get("cflags","")
    EXTRA_DFLAGS = pkgdict.get("dflags","")
    INCLUDES=pkgdict.get("include_path",[])
    INCLUDE_PATH=[os.path.join(config.FLX_DIR, i) for i in INCLUDES]
    MACROS =pkgdict.get("macros",[])

    flibs = pkgdict.get("lib_requires",[])
    needs_libs = []
    for i in flibs:
      needs_libs.append(i+"_dynamic")

    lib = pkgdict.get("provides_lib","lib"+pkg)

    print " ++ "+pkg+" RTL (dynamic)"

    compile_kwds = {
        'outdir': 'build',
        'include_paths': INCLUDE_PATH+[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
        'optimise': self.optimise,
        'debug': self.debug,
        'macros': MACROS+["BUILD_"+BUILD_MACRO],
        'CFLAGS': EXTRA_CFLAGS,
        }

    link_kwds = {
        'lib_paths': [config.TARGET_CXX.options.SHLIB_DIR],
        'libs': needs_libs,
        'LDFLAGS': EXTRA_DFLAGS,
        }

    if CCS:
      # RF: THIS SHOULD BE TARGET_CC AND THE OUTPUT DIR SHOULD BE THAT OF
      # THE TARGET.
      objects = config.TARGET_CC.compile_shared_rtl(CCS, **compile_kwds)
      library = config.TARGET_CC.options.SHLIB_DIR+os.sep+lib+'_dynamic'

      config.TARGET_CC.link_shared_rtl(objects, library, **link_kwds)

      if config.TARGET_CC.options.EXT_DYLIB != config.TARGET_CC.options.EXT_SHLIB:
        config.TARGET_CC.link_shared_dll(objects, library,
          **link_kwds)

    if CPPS:
      # RF: THIS SHOULD BE TARGET_CXX AND THE OUTPUT DIR SHOULD BE THAT OF
      # THE TARGET.
      objects = config.TARGET_CXX.compile_shared_rtl(CPPS, **compile_kwds)
      library = config.TARGET_CXX.options.SHLIB_DIR+os.sep+lib+'_dynamic'

      config.TARGET_CXX.link_shared_rtl(objects, library, **link_kwds)

      if config.TARGET_CXX.options.EXT_DYLIB != config.TARGET_CXX.options.EXT_SHLIB:
        config.TARGET_CXX.link_shared_dll(objects, library, **link_kwds)

      for x in CCS + CPPS:
        f = x + config.TARGET_CXX.options.EXT_SHARED_OBJ

@select(tangler('mkplugins/build_target_rtl_static.py'))
import os

from flxbuild.process import Process

import config

class build_target_rtl_static(Process):
  def runme(self, pkg, pkgdict, *args):
    if not config.SUPPORT_STATIC_LINKAGE:
      return

    CCS = pkgdict.get("cc_ccs",[])
    CPPS = pkgdict.get("cpp_cpps",[])

    if not CCS and not CPPS:
      return

    EXTRA_CFLAGS = pkgdict.get("cflags","")
    lib = pkgdict.get("provides_lib","lib"+pkg)
    INCLUDES=pkgdict.get("include_path",[])
    INCLUDE_PATH=[os.path.join(config.FLX_DIR, i) for i in INCLUDES]
    MACROS =pkgdict.get("macros",[])

    print " ++ "+pkg+" RTL (static)"

    kwds = {
        'outfile': os.path.join(config.FLX_RTL_DIR, lib + "_static"),
        'outdir': 'build',
        'include_paths': INCLUDE_PATH+[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
        'macros': MACROS+["FLX_STATIC_LINK"],
        'optimise': self.optimise,
        'debug': self.debug,
        'CFLAGS': EXTRA_CFLAGS,
        }

    if CCS:
      config.TARGET_CC.build_static_rtl(CCS, **kwds)

    if CPPS:
      config.TARGET_CXX.build_static_rtl(CPPS, **kwds)

    for x in CCS + CPPS:
      f = x + config.TARGET_CXX.options.EXT_STATIC_OBJ


@select(tangler('mkplugins/build_felix_static_drivers.py'))
import shutil

from flxbuild.process import Process
from flxbuild.flxutil import mkdirs

import config

class build_felix_static_drivers(Process):
  def runme(self, pkg, pkgdict, *args):
    if not config.SUPPORT_STATIC_LINKAGE:
      return

    DRIVERS = pkgdict.get("static_drivers",[])
    if not DRIVERS:
      return

    print "COMPILING DRIVERS (static)"
    cflags = pkgdict.get("cflags","")

    for src, outdir in DRIVERS:
      if self.verbose: print 'static Compiling driver object', src
      dst = config.TARGET_CXX.compile_static_main([src],
        outdir='build',
        include_paths=[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
        macros=["FLX_STATIC_LINK"],
        optimise=self.optimise,
        debug=self.debug,
        CFLAGS=cflags)

      if outdir:
        print 'copying file', dst[0], '->', outdir
        mkdirs(outdir)
        shutil.copy(dst[0], outdir)


@select(tangler('mkplugins/build_felix_dynamic_drivers.py'))
from flxbuild.process import Process

import config

class build_felix_dynamic_drivers(Process):
  def runme(self, pkg, pkgdict, *args):
    if not config.SUPPORT_DYNAMIC_LOADING:
      return

    DRIVERS = pkgdict.get("dynamic_drivers",[])

    if not DRIVERS:
      return

    print "COMPILING DRIVERS (dynamic)"
    cflags = pkgdict.get("cflags","")
    dflags = pkgdict.get("dflags","")
    LIBS = pkgdict.get("drivers_require_libs",[])
    libs = []
    for lib in LIBS:
      libs.append(lib+"_dynamic")

    for src, bin in DRIVERS:
      # this is a gross HACK! Don't make dynamic versions
      # of drivers with extra macros, they're for static
      # link of driver without async support
      if self.verbose: print 'dynamic Compiling driver object', src

      config.TARGET_CXX.build_shared_program(src, bin,
          include_paths=[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
          optimise=self.optimise,
          debug=self.debug,
          CFLAGS=cflags,
          lib_paths=[config.TARGET_CXX.options.SHLIB_DIR],
          libs=libs,
          LDFLAGS=dflags)


@select(tangler('mkplugins/build_target_cpp_tools.py'))
import os

from flxbuild.process import Process

import config

class build_target_cpp_tools(Process):
  def runme(self, pkg, pkgdict, *args):
    EXES = pkgdict.get("exes",[])
    esflags = pkgdict.get("exes_require_linkflags","")
    if len(EXES)>0:
      print "BUILDING C++ TARGET TOOLS"
      LIBS = pkgdict.get("exes_require_libs",[])
      libs = []
      for lib in LIBS: libs.append(lib+"_static")
      for src,bin in EXES:
        dir = os.path.dirname(src)
        config.TARGET_CXX.build_static_main(src, dir, bin,
          outdir='build',
          include_paths=[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
          macros=["FLX_STATIC_LINK"],
          lib_paths=[dir],
          libs=libs,
          LDFLAGS=esflags)

@select(tangler('mkplugins/build_target_felix_rtl.py'))
import os
import shutil

from flxbuild.process import Process
from flxbuild.flxutil import unix2native

import config

class build_target_felix_rtl(Process):
  def runme(self, pkg, pkgdict, *args):
    flxs = pkgdict.get('felix_rtl', [])
    if not flxs:
      return

    for path in flxs:
      f = os.path.join(config.FLX_DIR, path)
      if os.path.exists(f):
        src = f
      else:
        src = path
      src = unix2native(src)
      dst = os.path.join('lib', os.path.basename(path))

      if not self.quiet: print 'copying file', src, '->', dst
      shutil.copyfile(src, dst)

@select(tangler('mkplugins/build_target_felix_tools.py'))
import os

from flxbuild.process import Process

import config

class build_target_felix_tools(Process):
  def runme(self, pkg, pkgdict, *args):
    flxs = pkgdict.get("felix_tools",[])
    if not flxs:
      return

    print "BUILDING FELIX TARGET TOOLS"
    libs = [l+'_static' for l in pkgdict.get("exes_require_libs",[])]
    fsflags = pkgdict.get("felix_requires_linkflags","")
    for src,exe in flxs:
      # added 'std' here so flx_pkgconfig builds
      self.shell(os.path.join('bin', 'flxg'),
        '-Ilib',
        '--elkhound=' + os.path.join('bin', 'flx_elkhound'),
        '--import=flx.flxh',
        'std',
        src,
      )
      config.TARGET_CXX.build_felix_static(src, exe,
        objects=[os.path.join(config.FLX_RTL_DIR, 'flx_run' + config.TARGET_CXX.options.EXT_STATIC_OBJ)],
        include_paths=[config.FLX_RTL_DIR, config.FLX_TARGET_CONFIG_DIR],
        macros=["FLX_STATIC_LINK"],
        lib_paths=[config.FLX_RTL_DIR],
        libs=libs,
        LDFLAGS=fsflags
      )

@select(tangler('mkplugins/performance.py'))
import os

from flxbuild.process import Process

import config

class performance(Process):
  help = 'make performance tests'

  SPECIAL_TESTS = [
    (os.path.join('bin', 'drivers', 'flx_run'), os.path.join('test', 'drivers', 'flx_run_lib1.flx'),''),
    (os.path.join('test', 'drivers', 'flx_perf_drv1'), os.path.join('test', 'drivers', 'flx_perf_lib1.flx'),'1000'),
  ]

  def performance(self):
    for driver,testfile,moreargs in self.SPECIAL_TESTS:
      test_basename = os.path.splitext(testfile)[0]
      drv_basename = os.path.splitext(driver)[0]
      if config.SUPPORT_DYNAMIC_LOADING:
        testscript = "time "+drv_basename+ " "+test_basename+config.TARGET_CXX.options.EXT_SHLIB+" " + moreargs
        print '(dynamic link) Executing ',testscript
        try:
          self.shell(testscript)
          #print 'TESTFILE -- OK!',testscript
        except ExecutionError, e:
          print 'TESTFILE -- ERROR!',testscript
          raise e

      if config.SUPPORT_STATIC_LINKAGE:
        testscript = "time "+test_basename+config.TARGET_CXX.options.EXT_EXE+" " + moreargs
        print '(static link) Executing ',testscript
        try:
          self.shell(testscript)
          #print 'TESTFILE -- OK!',testscript
        except ExecutionError, e:
          print 'TESTFILE -- ERROR!',testscript
          raise e

@select(tangler('mkplugins/run_failure_tests.py'))
import os

from flxbuild.process import Process
from flxbuild.flxutil import Tee
from flxbuild.path import relativepath, glob_paths

class run_failure_tests(Process):
  help = 'run tests meant to fail'

  def runme(self, pkg, pkgdict, pkgsummary):
    #bad_tests = pkgdict.get("failure_tests",[])
    bad_tests=[]
    bad_tests.sort()

    failed = 0

    root = pkgdict.get('root', '.')
    for testfile in glob_paths(bad_tests):
      log = Tee()
      log.write("**** FAILURE TESTING PACKAGE %s : %s ****\n" % (pkg, testfile))

      #log.write('Running Felix code generator on %s\n' % testfile)
      localpath = relativepath(root, testfile)
      builddir = os.path.join('build', os.path.dirname(localpath))

      try:
        self.shell(os.path.join('bin', 'flxg'),
          '-e',
          '-Ilib',
          '-I' + os.path.dirname(testfile),
          '--cache_dir=' + builddir,
          '--output_dir=' + builddir,
          '--elkhound=' + os.path.join('bin', 'flx_elkhound'),
          '--import=flx.flxh',
          'std',
          os.path.splitext(os.path.basename(testfile))[0],
          log=log,
        )

        #log.write('TESTFILE -- failed as expected %s\n' % testfile)
        self.successes.append((pkg, testfile, log.getvalue()))
      except ExecutionError, e:
        failed = 1

        log.write('TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED! %s\n' % testfile)

        self.failures.append((pkg, testfile, log.getvalue()))

    return not failed


@select(tangler('mkplugins/run_static_unit_tests.py'))
from flxbuild.testprocess import TestProcess

class run_static_unit_tests(TestProcess):
  help = 'run static unit tests'

  def runme(self, pkg, pkgdict, pkgsummary):
    static_unit_tests = pkgdict.get("static_unit_tests",[])
    static_unit_tests.sort()

    return self.run_tests(pkg, pkgdict, pkgsummary, static_unit_tests, 1, 1, 0,
      "*** STATIC UNIT TESTING %s : %%s ****\n" % pkg)


@select(tangler('mkplugins/run_dynamic_unit_tests.py'))
from flxbuild.testprocess import TestProcess

class run_dynamic_unit_tests(TestProcess):
  help = 'run dynamic unit tests'

  def runme(self, pkg, pkgdict, pkgsummary):
    dynamic_unit_tests = pkgdict.get("dynamic_unit_tests",[])
    dynamic_unit_tests.sort()

    return self.run_tests(pkg, pkgdict, pkgsummary, dynamic_unit_tests, 1, 0, 1,
      "*** DYNAMIC UNIT TESTING %s : %%s ****\n" % pkg)


@select(tangler('mkplugins/run_unit_tests.py'))
from flxbuild.testprocess import TestProcess

class run_unit_tests(TestProcess):
  help = 'run unit tests'

  def runme(self, pkg, pkgdict, pkgsummary):
    unit_tests = pkgdict.get("unit_tests",[])
    unit_tests.sort()

    return self.run_tests(pkg, pkgdict, pkgsummary, unit_tests, 1, 1, 1,
      "*** UNIT TESTING %s : %%s ****\n" % pkg)


@select(tangler('mkplugins/run_completion_tests.py'))
from flxbuild.testprocess import TestProcess

# these tests are units tests with non-deterministic results
class run_completion_tests(TestProcess):
  help = 'run tests that just need to finish'

  def runme(self, pkg, pkgdict, pkgsummary):
    completion_tests = pkgdict.get("completion_tests",[])
    completion_tests.sort()

    return self.run_tests(pkg, pkgdict, pkgsummary, completion_tests, 0, 1, 1,
      "*** COMPLETION (nondet) TESTING %s : %%s ****\n" % pkg)


@select(tangler('mkplugins/run_known_failed_tests.py'))
from flxbuild.process import Process
from flxbuild.flxutil import Tee

class run_known_failed_tests(Process):
  help = 'mark tests failed that are known to fail without running'

  def __init__(self, *args, **kwds):
    super(run_known_failed_tests, self).__init__(*args, **kwds)
    self.dummy = 1

  def runme(self, pkg, pkgdict,pkgsummary):
    bad_tests = pkgdict.get("known_failed_tests",[])
    bad_tests.sort()

    for testfile in bad_tests:
      log = Tee()
      log.write("**** KNOWN FAILED TESTING PACKAGE %s : %s ****\n" % (pkg, testfile))

      # don't even bother to compile
      self.failures.append((pkg, testfile, ""))

    return 1 # don't report any failure!

@select(tangler('mkplugins/run_demos.py'))
from flxbuild.testprocess import TestProcess

class run_demos(TestProcess):
  help = 'run demonstrations'

  def runme(self, pkg, pkgdict, pkgsummary):
    demos = pkgdict.get("demos",[])
    demos.sort()

    if not demos:
      return

    print "***** DEMO PACKAGE", pkg, "************"

    return self.run_tests(pkg, pkgdict, pkgsummary, demos, 0, 1, 1,
      "*** DEMO PACKAGE %s : %%s ****\n" % pkg)


@select(tangler('mkplugins/manifest.py'))
import os
import glob
import re

from flxbuild.process import Process
from flxbuild.flxutil import filetime, newest_filetime, mkdirs

import config

class manifest(Process):
  def make_manifest(self, pkg, deps_filename):
    regex = re.compile(r"CREATING .* NAMED FILE SOURCE (.*) \[")

    mkdirs("manifests")
    f = open(deps_filename, "w")
    try:
      for line in self.shell(config.ISCR, '--trace=sources', '--trace=changes', pkg):
        m = regex.match(line)
        if m:
          dep = m.group(1)
          print "Source File:", dep
          print >> f, os.path.join(config.FLX_LPARCHIVE, 'lpsrc', dep)
    finally:
      f.close()

  def preprocess(self):
    paks = glob.glob(os.path.join(config.FLX_LPARCHIVE, "lpsrc", "*.pak"))
    for pak in paks:
      base = os.path.basename(os.path.splitext(pak)[0])
      deps_filename = os.path.join("manifests", base + '.deps')

      if not os.path.exists(deps_filename):
        print "New pak", pak, "BUILDING MANIFEST"
        self.make_manifest(pak, deps_filename)
      else:
        manifest_time = filetime(deps_filename)

        f = open(deps_filename)
        try:
          src_time = newest_filetime([line.strip() for line in f] + [pak])
          if src_time > manifest_time:
            print "Changed pak", pak, "REBUILDING MANIFEST"
            self.make_manifest(pak, deps_filename)
        finally:
          f.close()

@select(tangler('mkplugins/extract_iscr.py'))
import os

from flxbuild.process import Process
from flxbuild.flxutil import unix2native

import config

class extract_iscr(Process):
  def runme(self, pkg, pkgdict, *args):
    srcs = pkgdict.get("iscr_source",[])
    for src in srcs:
      src = unix2native(src)
      if not self.quiet: print "REExtracting", pkg, "from", src
      self.shell(config.ISCR,
        '--break-on-error',
        os.path.join(config.FLX_LPARCHIVE, src),
      )

@select(tangler('flxbuild/package.py'))
# global package registry
pkgd = {}
pkgreqs = {}
pkgdeps = {}

@select(tangler('flxbuild/process.py'))
import os
import glob
import time

# forward import of set
try:
  set
except NameError:
  from sets import Set as set

from flxbuild.flxutil import xqt, newest_filetime, filetime, fmtime, mkdirs
import config

# global process registry
processes = {}

class Process(object):
  help = ''

  def __init__(self,
      verbose=False,
      quiet=False,
      optimise=False,
      debug=False,
      force=False,
      options=[]):
    self.failures = []
    self.successes = []
    self.dummy = 0
    self.used = False
    self.verbose = verbose
    self.quiet = quiet
    self.optimise = optimise
    self.debug = debug
    self.force = force
    self.options = options

  #def __call__(self, *args, **kwds):
  #  self.used = True
  #  return self.runme(*args, **kwds)

  def shell(self, *args, **kwds):
    kwds.setdefault('verbose', self.verbose)
    kwds.setdefault('quiet', self.quiet)

    return xqt(*args, **kwds)

  def __str__(self):
    return self.__class__.__name


def get_latest_src_time(pkgdict):
  filenames = set()

  # check out iscr files
  for iscr in pkgdict.get("iscr_source",[]):
    base = os.path.basename(os.path.splitext(iscr)[0])
    f = open(os.path.join('manifests', base + '.deps'))
    try:
      filenames.update([line.strip() for line in f])
    finally:
      f.close()

  # check out xfiles
  for xfile in pkgdict.get('xfiles', []):
    xfile = os.path.join(config.FLX_DIR, xfile)
    filenames.update(glob.glob(xfile))

  return newest_filetime(filenames)


def enstamp(stamp, quiet):
  mkdirs(os.path.split(stamp)[0])
  f = open(stamp,"w")
  try:
    print >> f, fmtime(time.time())
  finally:
    f.close()

  if not quiet:
    print 'Writing Stamp File:', stamp


@select(tangler('flxbuild/testprocess.py'))
import os
import glob

from flxbuild.process import Process, processes, get_latest_src_time, enstamp
from flxbuild.package import pkgd, pkgreqs
from flxbuild.flxutil import Tee, ExecutionError, filetime, fmtime
from flxbuild.path import relativepath, glob_paths

import config

class TestProcess(Process):
  def find_test(self, tl, a, b):
    for x, y, z in tl:
      if x == a and y == b: return True
    return False

  def run_tests(self, pkg, pkgdict, pkgsummary, testfiles, deterministic, static, dynamic, title):
    pkgsummary[(pkg, self.__class__.__name__)] = "started"
    if not testfiles:
      pkgsummary[(pkg, self.__class__.__name__)] = "no tests"
      return 1

    tests_ran = 0
    tests_failed = 0

    # determine the latest time that this package, and all the recurcively dependent
    # packages where last built
    latest_src_time = get_latest_src_time(pkgdict)

    for p in pkgreqs.get(pkg, []):
      latest_src_time = max(latest_src_time, get_latest_src_time(pkgd[p]))

    root = pkgdict.get('root', '.')
    for testfile in glob_paths(testfiles, root):
      localpath = relativepath(root, testfile)

      failed = 0

      if self.find_test(self.successes, pkg, testfile): continue
      if self.find_test(self.failures, pkg, testfile): continue

      stamp = os.path.join("pkg-stamps", localpath + '.test')

      # run the tests
      stamptime = filetime(stamp)
      if not self.force and latest_src_time < stamptime:
        self.successes.append((pkg, testfile, "Stamped ok previously on "+fmtime(stamptime)))
      else:
        tests_ran += 1

        log = Tee()
        log.write(title % testfile)
        if not self.quiet:
          if stamptime == 0:
            log.write("+++UNTRIED or FAILED\n")
          elif self.force:
            log.write("+++FORCED\n")
          else:
            log.write("+++OUT OF DATE, source changed since "+fmtime(stamptime)+"\n")

        # build the felix code
        try:
          outbase = processes['build_testfile'].runme(root, localpath, log)
        except ExecutionError, e:
          failed = 1
          log.write('TESTFILE -- ERROR! %s (compiler)\n' % testfile)
        else:
          # run the dynamic tests
          if dynamic and config.SUPPORT_DYNAMIC_LOADING:
            resfilename = outbase + ".resh"

            try:
              driver = self.shell(
                os.path.join('bin', 'flx_pkgconfig'),
                '--path=config',
                '--field=flx_requires_driver',
                '--rec',
                '@' + resfilename,
                log=log,
              )

              driver = driver[0].strip()
              if driver =='': driver = "flx_run"
              driver = os.path.join("bin", driver)
              #log.write("Driver: %s\n" % driver)
              testscript = driver + ' ' + outbase + config.TARGET_CXX.options.EXT_SHLIB

              self.run_test(log, testscript, os.path.splitext(testfile)[0], outbase, deterministic)
            except ExecutionError, e:
              failed = 1
              log.write('TESTFILE -- ERROR! %s (dynamic)\n' % testscript)

          # run the static tests
          if static and config.SUPPORT_STATIC_LINKAGE:
            testscript = outbase + config.TARGET_CXX.options.EXT_EXE

            try:
              self.run_test(log, testscript, os.path.splitext(testfile)[0], outbase, deterministic)
            except ExecutionError, e:
              failed = 1
              log.write('TESTFILE -- ERROR! %s (static)\n' % testscript)

        if not failed:
          enstamp(stamp, self.quiet)
          self.successes.append((pkg, testfile, log.getvalue()))

      ####

      if failed:
        tests_failed += 1
        self.failures.append((pkg, testfile, log.getvalue()))

      pkgsummary[(pkg, self.__class__.__name__)] = \
        "Passed %d/%d" % (tests_ran - tests_failed, tests_ran)

    return tests_failed == 0


  def run_test(self, log, testscript, inbase, outbase, deterministic):
    log.write('EXECUTING TEST CODE %s\n' % testscript)
    log.flush()

    # FIXME
    argfiles = glob.glob(inbase + '*.args')

    if not argfiles:
      output = self.shell(testscript, verbose=True, log=log)

      f = open(outbase+ '.output', 'w')
      try:
        f.write(''.join(output))
      finally:
        f.close()

      if deterministic:
        output = self.shell(config.DIFF,
          inbase + '.expect',
          outbase + '.output',
          verbose=True,
          log=log)

    else:
      for argcount, argfile in zip(range(len(argfiles)), argfiles):
        # read the arguments fromm the file
        f = open(argfile)
        try:
          args = f.read().strip()
        finally:
          f.close()

        output = self.shell(testscript, args, verbose=True, log=log)

        f = open('%s-%s.argoutput' % (outbase, argcount), 'w')
        try:
          f.write(''.join(output))
        finally:
          f.close()

        if deterministic:
           output = self.shell(config.DIFF,
            '%s-%s.argexpect' % (inbase, argcount),
            '%s-%s.argoutput' % (outbase, argcount),
            quiet=True,
            log=log,
          )

@select(tangler('mkplugins/help.py'))
import sys
from flxbuild.process import Process, processes
from flxbuild.package import pkgreqs, pkgdeps

class help(Process):
  help = 'print this help message'

  def preprocess(self):
    # PRINT PACKAGE DEPENDENCY INFORMATION
    print "REQS: "
    ks=pkgreqs.keys()
    ks.sort()
    length = 0
    for k in ks:
      length = max(len(k), length)
    for k in ks:
      print "  ", k.ljust(length), pkgreqs[k]

    print
    print "DEPS: "
    ks = pkgdeps.keys()
    ks.sort()
    length = 0
    for k in ks:
      length = max(len(k), length)
    for k in ks:
      print "  ", k.ljust(length), pkgdeps[k]

    items = []
    max_len = 0
    for name, process in processes.items():
      if process.help:
        max_len = max(max_len, len(name))
        items.append((name, process.help))

    items.sort()

    for name, help in items:
      print '%s %s' % (name.ljust(max_len), help)

    sys.exit(0)

@select(tangler('mkplugins/fcount.py'))
import os
import sys
from flxbuild.process import Process

class fcount(Process):
  def __init__(self, *args, **kwds):
    super(fcount, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict,*args):
    if self.ran:
      return
    self.ran = True

    # requires posix
    if os.name == 'nt':
      return

    if "inline" in self.options:
      tkind = "inline"
    elif "noinline" in self.options:
      tkind = "noinline"
    else:
      tkind = "std"

    self.shell(sys.executable,
      os.path.join('script', 'fcount.py'),
      os.path.join('misc', 'fcounts.stats'),
      tkind,
      '"' + os.path.join('tut', 'examples', '*.hpp') + '"',
    )

    self.shell(sys.executable,
      os.path.join('script', 'fcount.py'),
      os.path.join('misc', 'fcounts.stats'),
      tkind,
      '"' + os.path.join('test', '*.hpp') + '"',
    )


@select(tangler('mkplugins/pfcount.py'))
import os
import sys
from flxbuild.process import Process

class pfcount(Process):
  def __init__(self, *args, **kwds):
    super(pfcount, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict,*args):
    if self.ran:
      return
    self.ran = True

    # requires posix
    if os.name == 'nt':
      return

    self.shell(sys.executable,
      os.path.join('script', 'pfcount.py'),
      os.path.join('misc', 'fcounts.stats'),
    )

@select(tangler('mkplugins/pfcount_all.py'))
import os
import sys
from flxbuild.process import Process

class pfcount_all(Process):
  def __init__(self, *args, **kwds):
    super(pfcount_all, self).__init__(*args, **kwds)
    self.ran = False

  def runme(self, pkg, pkgdict,*args):
    if self.ran:
      return
    self.ran = True

    # requires posix
    if os.name == 'nt':
      return

    self.shell(sys.executable,
      os.path.join('script', 'pfcount.py'),
      os.path.join('misc', 'fcounts.stats'),
      'all',
    )

@select(tangler('fbuildroot.py'))
import os
import config

# make sure we have the runtime library in our search path
if config.CYGWIN or config.WIN32:
  pass
elif config.MACOSX:
  os.environ['DYLD_LIBRARY_PATH'] = \
      os.environ.get('DYLD_LIBRARY_PATH', '') + os.pathsep + \
      config.FLX_RTL_DIR
else:
  os.environ['LD_LIBRARY_PATH'] = \
      os.environ.get('LD_LIBRARY_PATH', '') + os.pathsep + \
      config.FLX_RTL_DIR

# -----------------------------------------------------------------------------

from optparse import make_option

options = [
  make_option('-O', '--optimise',
    action='store_true',
    default=True,
    help='generate optimised code'),
  make_option('--no-optimise', dest='optimise',
    action='store_false',
    help='turn off optimised code generation'),
  make_option('-g', '--debug',
    action='store_true',
    default=True,
    help='generate debugging information'),
  make_option('--no-debug', dest='debug',
    action='store_false',
    help='turn off debugging information generation'),
  make_option('-D', dest='macros', metavar='MACRO',
    action='append',
    default=[],
    help='define a macro'),
]

default_fbuild_processs = 'run'

fbuild_preprocesses = [
  'manifest',
]

fbuild_processes = {
  'build': [
    'extract_iscr',
  ],
  'host': [
    'build',
    'build_host_ocaml',
    'build_host_tools',
    'extract_grammar',
  ],
  'target': [
    'host',
    'build_target_rtl_dynamic',
    'build_target_rtl_static',
    'build_felix_dynamic_drivers',
    'build_felix_static_drivers',
    'build_target_cpp_tools',
    'build_target_felix_rtl',
    'build_target_felix_tools',
  ],
  'run': [
    'target',
    'run_failure_tests',
    'run_unit_tests',
    'run_static_unit_tests',
    'run_dynamic_unit_tests',
    'run_completion_tests',
    'run_known_failed_tests',
  ],
  'test': [
    'run',
    'fcount',
  ],
  'tutorial': [
    'target',
    'fcount',
  ],
  'doc': [
    'mkdoc',
    'impldoc',
    'rtldoc',
    'gramdoc',
    'typeclassdoc',
  ],
  'demo': [
    'target',
    'run_demos',
  ],
  'speed': [
    'target',
    'speed_tests',
  ],
}

@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
@tangle("FLX_MAKER_CVS_ID='"+FLX_MAKER_CVS_ID+"'")
import os
import sys
import glob

# forward import of set
try:
  set
except NameError:
  from sets import Set as set

if '' not in sys.path: sys.path.insert(0, '')


# ------------------------------------------------
# Load the initial config
# ------------------------------------------------

try:
  import config
except Exception:
  import traceback
  xt,xv,tb = sys.exc_info()
  print "ERROR IN config/__init__.py"
  traceback.print_exception(xt,xv,tb)
  print "You must either"
  print "(a) edit config/__init__.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

import fbuildroot

def load_options():
  from optparse import OptionParser, make_option

  parser = OptionParser()
  parser.add_options([
    make_option('-v', '--verbose',
      action='count',
      default=1,
      help='print out extra debugging info'),
    make_option('-q', '--quiet',
      action='count',
      default=0,
      help='do not print out extra debugging info'),
    make_option('--force',
      action='store_true',
      default=False,
      help='force running a process'),
    make_option('--phase', dest='selected_phases', metavar='PHASE',
      action='append',
      default=[],
      help='run only this phase of the build'),
    make_option('--pkg', dest='selected_packages', metavar='PKG',
      action='append',
      default=[],
      help='build only these packages'),
    make_option('--model', dest='selected_models', metavar='MODEL',
      action='append',
      default=[],
      help='build only these models'),
    make_option('--lparchive',
      metavar='PATH',
      help='use an alternative lpsrc directory'),
  ])

  try:
    extra_options = fbuildroot.options
  except AttributeError:
    pass
  else:
    option_group = parser.add_option_group('project options')
    option_group.add_options(extra_options)

  options, args = parser.parse_args()

  ####

  # temporary hack to set up the shell
  config.HOST_OCAML.verbose = options.verbose
  config.HOST_CC.verbose = options.verbose
  config.HOST_CXX.verbose = options.verbose
  config.TARGET_CC.verbose = options.verbose
  config.TARGET_CXX.verbose = options.verbose

  config.HOST_OCAML.quiet = options.quiet
  config.HOST_CC.quiet = options.quiet
  config.HOST_CXX.quiet = options.quiet
  config.TARGET_CC.quiet = options.quiet
  config.TARGET_CXX.quiet = options.quiet

  ####

  # use the default option if not specified
  if not options.selected_phases:
    options.selected_phases = [fbuildroot.default_fbuild_processs]

  ####

  # if the user didn't say which phases to run
  # then run all the phases that use the host model
  # On building on Linux for MinGW, the build model
  # is linux, and the host model is mingw, the target
  # is win32. We'd be running all MinGW phases.
  # note a phase is named for the targetted product
  # NOT the machine that generates it. Thus host
  # phase mingw means 'compile on Linux for MingW'

  if not options.selected_phases and not options.selected_models:
    options.selected_models = [config.host_model]

  for model in options.selected_models:
    if model == config.build_model and 'build' not in options.selected_phases:
      options.selected_phases.append('build')

    if model == config.host_model and 'host' not in options.selected_phases:
      options.selected_phases.append('host')

    if model == config.target_model and 'target' not in options.selected_phases:
      options.selected_phases.append('target')

    if model == config.run_model and 'run' not in options.selected_phases:
      options.selected_phases.append('run')

  ####

  if options.lparchive:
    config.FLX_LPARCHIVE = options.lparchive

  return options, args


def initial_extraction(options, args):
  import shutil
  from flxbuild.flxutil import xqt, mkdirs

  paks = glob.glob(os.path.join(config.FLX_LPARCHIVE, "lpsrc", "*.pak"))
  if "extract" in args or "force_extract" in args:
    for p in paks:
      print "EXTRACTING", p, "from", config.FLX_LPARCHIVE
      if "force_extract" in args:
        xqt(config.ISCR, '--force', '--break-on-error', p, verbose=options.verbose, quiet=options.quiet)
      else:
        xqt(config.ISCR, '--break-on-error', p, verbose=options.verbose, quiet=options.quiet)
    # this is a hack
    mkdirs('speed')
    shutil.copy(os.path.join('misc', 'interscript.css'), 'speed')

    print "EXTRACTION COMPLETE"
    sys.exit(0)

# ----------------------------------------------------------------------------

def load_packages():
  from flxbuild.package import pkgdeps, pkgreqs, pkgd

  pkgs = []
  unsorted_pkgs = []

  for i in glob.glob(os.path.join("spkgs", "*.py")):
    pkg = os.path.basename(os.path.splitext(i)[0])
    if pkg == '__init__':
      continue

    unsorted_pkgs.append(pkg)
    module = getattr(__import__('spkgs.' + pkg), pkg)
    d = {}
    for k, v in module.__dict__.iteritems():
      if k[0] != '_':
        d[k] = v
    pkgd[pkg] = d

  def addpkg_r(pkg):
    if pkg not in pkgs:
      if pkg not in pkgd.keys():
        print "Unknown package", pkg
        print "Please extract!"
        sys.exit(1)
      else:
        reqs = pkgd[pkg].get('pkg_requires',[])
        pkgreqs[pkg]=reqs
        for i in reqs:
          addpkg_r(i)
        pkgs.append(pkg)

  for pkg in unsorted_pkgs:
    addpkg_r(pkg)

  # invert the requirements in order to determine the dependencies
  from flxbuild.flxutil import invert
  pkgdeps.update(invert(pkgreqs))

  return pkgs

# -------------------------------------------------
# LOAD PROCESSES

import flxbuild.process

def load_processes(options, args):

  for f in glob.glob(os.path.join("mkplugins", "*.py")):
    name = os.path.basename(os.path.splitext(f)[0])
    if name == '__init__':
      continue

    module = getattr(__import__('mkplugins.' + name), name)
    try:
      process_class = getattr(module, name)
    except AttributeError:
      pass
    else:
      process = process_class(
        verbose=options.verbose,
        quiet=options.quiet,
        optimise=options.optimise,
        debug=options.debug,
        force=options.force or 'force' in args,
        options=args,
      )
      flxbuild.process.processes[name] = process

# -----------------------------------------------------------------------------

from flxbuild.process import get_latest_src_time, enstamp
from flxbuild.flxutil import newest_filetime, filetime, fmtime


def calculate_packages(options, phase, packages):
  if options.selected_packages:
    selected_pkgs = options.selected_packages
  else:
    selected_pkgs = []
    max_len = max([len(s) for s in flxbuild.package.pkgd])

    for pkg, pkgdict in flxbuild.package.pkgd.iteritems():
      latest_src_time = get_latest_src_time(pkgdict)

      stamp = os.path.join('pkg-stamps', '%s.%s' % (pkg, phase))
      latest_build_time = filetime(stamp)

      if latest_build_time == 0:
        print "Pak %s (virtual)" % pkg.ljust(max_len), 'UNBUILT'
        selected_pkgs.append(pkg)
      elif latest_build_time < latest_src_time:
        print "Pak %s changed: %s" % (pkg.ljust(max_len),fmtime(latest_src_time))
        selected_pkgs.append(pkg)

  return [pkg for pkg in packages if pkg in selected_pkgs]

####

from flxbuild.flxutil import erasefile

ran_phases = set()

def run_phase(options, phase, packages):
  if phase in ran_phases:
    return
  else:
    ran_phases.add(phase)

  processes = []
  for process in fbuildroot.fbuild_processes.get(phase, []):
    # make sure we run any dependent phase first
    if process in fbuildroot.fbuild_processes:
      run_phase(options, process, packages)
    else:
      processes.append(process)

  print '-' * 78
  print '***** MAKING PHASE', phase
  pkgsummary = {}
  for pkg in calculate_packages(options, phase, packages):
    pkgdict = flxbuild.package.pkgd[pkg]

    print "*****", phase, "MAKING PACKAGE", pkg, "************"

    stamp = os.path.join("pkg-stamps", "%s.%s" % (pkg, phase))
    erasefile(stamp)

    for process in processes:
      print "*****", phase, "RUNNING PROCESS", process, "************"
      result = flxbuild.process.processes[process].runme(pkg, pkgdict, pkgsummary)
      if not result and result is not None:
        break
    else:
      enstamp(stamp, options.quiet)

  if pkgsummary:
    pkgsummary = pkgsummary.items()
    pkgsummary.sort()
    print phase, "PHASE SUMMARY"
    for (package, process), summary in pkgsummary:
      print '  ', process.ljust(30), ':', package.ljust(30), ':', summary

# -----------------------------------------------------------------------------

def print_failures():
  import flxbuild.process
  from flxbuild.flxutil import Tee

  # print out all the failed processes
  failure_log = Tee()

  failure_log.write("----- PROCESS STATUS -----\n")
  failed = 0
  fatal = 0
  for name, process in flxbuild.process.processes.iteritems():
    nfail = len(process.failures)
    npass = len(process.successes)
    failed = failed or nfail>0
    fatal = fatal or (nfail>0 and not process.dummy)

    if nfail:
      print >> failure_log, 'PROCESS **FAILED**:', name,  nfail, '/', npass + nfail, 'failures'
      if process.dummy:
        print >> failure_log, "  [Expected failure, doesn't break build]"
    else:
      if process.used:
        print >> failure_log, 'PROCESS PASSED    :', name, npass, 'passed'
      else:
        print >> failure_log, 'PROCESS UNUSED    :', name

  if not failed:
    return False

  print '^^^^^^^^^^ FAILURES by group ^^^^^^^^^^^^^'

  kats = {}
  for name, process in flxbuild.process.processes.iteritems():
    if not process.failures:
      continue

    print '- %s: %s' % (len(process.failures), name)

    lookup = {}

    for pkg, file, failure in process.failures:
      files = lookup.get(pkg, [])
      files.append(file)
      lookup[pkg] = files

    lookup = lookup.items()
    lookup.sort()

    for pkg, files in lookup:
      files.sort()

      print '  - %s: %s' % (len(files), pkg)
      lastfile = ""
      for file in files:
        if file == lastfile: continue
        lastfile = file
        # grab the first line of the file to see if it
        # has a #line number to print out as well, so we can
        # localize the error to the interscript file location

        emitted = 0
        f = open(file)
        eat = 1
        while eat == 1:
          try:
            line = f.readline()
          except:
            eat = 0
          if emitted == 0: fstring = file
          else: fstring = ""
          if emitted == 0 and line[0:5] == '#line':
            comment = line
          elif line [0:8] == "//Check ":
            kat = line[8:].strip()
            l = kats.get(kat,[])
            l.append(file)
            kats[kat]=l
            comment = kat
          else:
            if emitted == 0:
              comment = line
            else:
              comment = ""
            eat = 0
          if line != "":
            print '      %-35s %s' % (fstring, comment.strip())
            emitted = 1
        if emitted == 0:
          print '      %s' % file
        f.close()

  print '^^^^^^^^^^ FAILURES by category ^^^^^^^^^^'
  keys = kats.keys()
  keys.sort()
  for kat in keys:
    print kat+":"
    files = kats[kat]
    for file in files:
      print "  ",file

  f = open('errors.log', 'w')
  try:
    f.write(failure_log.getvalue())
  finally:
    f.close()

  return fatal

# -----------------------------------------------------------------------------

def main():
  # add the felix directory to the search paths
  sys.path.append(config.FLX_DIR)
  os.environ['PYTHONPATH'] = \
    config.FLX_DIR + os.pathsep + os.environ.get('PYTHONPATH', '')

  options, args = load_options()
  initial_extraction(options, args)
  packages = load_packages()
  load_processes(options, args)

  ####

  import flxbuild.process
  for process in fbuildroot.fbuild_preprocesses:
    flxbuild.process.processes[process].preprocess()

  # execute user selected processes in command line order
  for arg in args:
    if arg in flxbuild.process.processes:
      flxbuild.process.processes[arg].runme()
    elif arg in fbuildroot.fbuild_processes:
      run_phase(options, arg, packages)

  for phase in options.selected_phases:
    run_phase(options, phase, packages)

  ####

  if print_failures():
    print "********* BUILD FAILED ********************"
    return 1
  else:
    print "*********** RUN COMPLETE: NO UNEXPECTED FAILURES DETECTED *******"

  return 0

if __name__ == '__main__':
  sys.exit(main())

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('CONFIG_ARGS=')
@tangle('PREFIX=' + config.PREFIX)
@tangle('INSTALL_DIR=${PREFIX}/lib/felix/felix-' + config.flx_version)
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('DOC_DIR=${INSTALL_DIR}')
@tangle('BUILTIN_ISCR=%s -O interscript/bin/iscr.py --nocache' % sys.executable)
@tangle('')
@tangle('all: config/__init__.py script/maker')
@tangle('\t./mk extract ')
@tangle('\t./mk --phase=build')
@tangle('\t./mk --phase=host')
@tangle('\t./mk --phase=target')
@tangle('\t./mk test ')
@tangle('')

@tangle('# ============== SYSTEM BOOTSTRAP ==============')
@tangle('.svn:')
@tangle('\tsvn co https://felix.svn.sourceforge.net:/svnroot/felix/felix/trunk . ')
@tangle('')

@tangle('config: config/init__.py')
@tangle('')
@tangle('config/__init__.py: lpsrc/flx_config.pak')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_config.pak')
@tangle('\tenv PYTHONPATH=. %s -O script/make_config.py --quiet --prefix=${PREFIX} ${CONFIG_ARGS}' % sys.executable)
@tangle('')
@tangle('script/maker: config/__init__.py lpsrc/flx_maker.pak')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_maker.pak')
@tangle('')
@tangle('make: script/maker')
@tangle('')
@tangle('boot: script/maker')
@tangle('')

@tangle('undead:')
@tangle('\tcp Makefile .Makefile')
@tangle('\trm -rf *')
@tangle('\trm -rf .svn')
@tangle('\tcp .Makefile Makefile')
@tangle('')
@tangle('checkout:')
@tangle('\tcp Makefile .Makefile')
@tangle('\trm -rf *')
@tangle('\trm -rf .svn')
@tangle('\tcp .Makefile Makefile')
@tangle('\tsvn co https://felix.svn.sourceforge.net:/svnroot/felix/felix/trunk . ')

@tangle('update: .svn')
@tangle('\tsvn update')
@tangle('')
@tangle('lpsrc/flx_config.pak: .svn')
@tangle('\tsvn update')
@tangle('')
@tangle('lpsrc/flx_maker.pak: .svn')
@tangle('\tsvn update')
@tangle('')

@tangle('virgin: distclean')
@tangle('')

@tangle('# ============== VARIOUS TARGETS ==============')
@tangle('profile: dummy')
@tangle('\t./mk --pkg=flx_compiler profile')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode')
@tangle('')
@tangle('bytecode.profile: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode profile')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode debug')
@tangle('')
@tangle('extract: dummy')
@tangle('\t./mk extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\t./mk extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\t./mk tutorial')
@tangle('')
@tangle('grammar: dummy')
@tangle('\tenv PYTHONPATH=. %s script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/get_grammar src/cil/flx_cil_cparser.mly >misc/flx_cil_cparser.grammar' % sys.executable)
#@tangle('\tenv PYTHONPATH=. %s script/elk_flx_grgen misc/flx_parse.grammar >misc/elk_flx_gr.gr' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/flx_flx_grgen misc/flx_parse.grammar >lib/flx_grammar.flx' % sys.executable)
#@tangle('\tenv PYTHONPATH=. %s script/elk_flx_lexgen misc/flx_parse.grammar >misc/elk_flx_lex.cc' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/flx_tokgen misc/flx_parse.grammar >lib/flx_token.flx' % sys.executable)
@tangle('')
@tangle('compiler: dummy')
@tangle('\t./mk --pkg=flx_compiler')
@tangle('')
@tangle('flx_tools:')
@tangle('\t./mk tools')
@tangle('')
@tangle('tools: flx_tools grammar')
@tangle('#tools: flx_tools grammar tools/lua_parser')
@tangle('')
@tangle('#tools: grammar bin/flx_doc tools/lua_parser')
@tangle('')
@tangle('tools/lua_parser: tools/lua_parser.flx')
@tangle('\tbin/flx --test --static -c tools/lua_parser')
@tangle('')
@tangle('bin/flx_doc: tools/flx_doc.flx')
@tangle('\tbin/flx --test --static -c tools/flx_doc && mv tools/flx_doc bin/flx_doc')
@tangle('')
@tangle('doc: grammar tools man impldoc rtldoc tutdoc')
@tangle('')
@tangle('#doc: grammar tools libdoc man impldoc tutdoc tutstyle')
@tangle('')
@tangle('impldoc: dummy')
@tangle('\t./mk doc impldoc')
@tangle('')
@tangle('rtldoc: dummy')
@tangle('\t./mk rtldoc')
@tangle('')
@tangle('tutdoc: dummy')
@tangle('\t./mk doc tutdoc')
@tangle('\t#cp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('doc.quiet: grammar tools libdoc')
@tangle('\t./mk quiet doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('libdoc: grammar tools')
@tangle('\tbin/flx_doc --outdir=libdoc \\')
@tangle('\tlib/std.flx lib/stl.flx lib/flx_lex.flx \\')
@tangle('\tlib/flx_token.flx lib/flx_grammar.flx lib/lua.flx lib/lua_parse.flx')
@tangle('\tcp misc/flxdoc_style.css libdoc')
@tangle('')
@tangle('man: dummy')
@tangle('\t./mk man')
@tangle('')
@tangle('test: dummy')
@tangle('\t./mk test ')
@tangle('')
@tangle('test.flx_ptf_static_pointer: dummy')
@tangle('\t./mk test -DFLX_PTF_STATIC_POINTER ')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\t./mk inline test ')
@tangle('')
@tangle('test.inline.static: dummy')
@tangle('\t./mk inline test static ')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\t./mk debug test ')
@tangle('')
@tangle('test.lua_parser: dummy')
@tangle('\tfor i in misc/lua/*.lua; do tools/lua_parser $$i; done;')
@tangle('')
@tangle('tests: dummy')
@tangle('\t./mk test check_output')
@tangle('\tmake tests.bagley')
@tangle('\tmake test.lua_parser')
@tangle('')
@tangle('tests.sdl: dummy')
@tangle('\t./mk sdl')
@tangle('\t./mk static sdl')
@tangle('')
@tangle('tests.verify: dummy')
@tangle('\t./mk test check_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\t./mk test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\t./mk inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\t./mk performance')
@tangle('')
@tangle('performance: tests.performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\t./mk regression')
@tangle('')
@tangle('tests.bagley: dummy')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('speed: dummy')
@tangle('\t./mk speed')
@tangle('')
@tangle('pfcount.all:')
@tangle('\t./mk pfcount_all')
@tangle('')
@tangle('pfcount:')
@tangle('\t./mk pfcount')
@tangle('')
@tangle('rtl.debug: dummy')
@tangle('\t./mk rtl debug')
@tangle('')
@tangle('rtl: dummy')
@tangle('\t./mk rtl')
@tangle('')
@tangle('rtl.optimise: dummy')
@tangle('\t./mk rtl optimise_c')
@tangle('')
@tangle('elkhound: dummy')
@tangle('\t./mk elkhound')
@tangle('')
@tangle('expect.bagley: clean')
@tangle('\t./mk bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tenv PYTHONPATH=. %s script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk' % sys.executable)
@tangle('')
@tangle('expect: clean')
@tangle('\t./mk bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\t./mk test log_output')
@tangle('\tenv PYTHONPATH=. %s script/mk_expect tut/examples > lpsrc/flx_tut_expect.ipk' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/mk_expect test > lpsrc/flx_test_expect.ipk' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk' % sys.executable)
@tangle('')
@tangle('drivers: dummy')
@tangle('\t./mk drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.08.1 or better')
@tangle('\t#REQUIRES g++ 3.xx or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required privileges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')
@tangle('')
@tangle('clean-src:')
@tangle('\trm -rf lpsrc')
@tangle('\trm -rf interscript')
@tangle('\trm -rf raw')
@tangle('\trm -rf gpl')
@tangle('\trm -rf lgpl')
@tangle('\trm -rf sandbox')
@tangle('\trm -rf boot.sh')
@tangle('\trm -rf boot.bat')
@tangle('')
@tangle('debian/rules: lpsrc/flx_debian.pak lpsrc/flx_maker.ipk')
@tangle('\trm -rf debian')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_debian.pak')
@tangle('\tchmod u+x debian/rules')
@tangle('')
@tangle('debian-package: debian/rules')
@tangle('\t(cd .. && make -f flx/Makefile.debian_package_creator package)')
@tangle('')
@tangle('www: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_sourceforge.pak')
@tangle('')
@tangle('distclean:')
@tangle('\trm -rf pkg tut rtl test www src misc man bin doc lib impldoc htmlman tmp tmp.tmp')
@tangle('\trm -rf elk tmp faio demux tmp.out demos judy ocs sex dypgen tre')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('\trm -rf bagley')
@tangle('\trm -rf doc_out libdoc tools doxydoc')
@tangle('\trm -rf meta licences')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf lpsrc-cache')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -rf interscript/*/*.pyo')
@tangle('\trm -rf interscript/*/*/*.pyo')
@tangle('\trm -rf interscript/*.pyc')
@tangle('\trm -rf interscript/*/*.pyc')
@tangle('\trm -rf interscript/*/*/*.pyc')
@tangle('\trm -rf speed')
@tangle('\trm -rf cpkgs')
@tangle('\trm -rf spkgs')
@tangle('\trm -rf pthread')
@tangle('\trm -rf mkplugins')
@tangle('\trm -rf olddebian')
@tangle('\trm -rf script')
@tangle('\trm -rf manifests')
@tangle('\trm -rf pkg-stamps')
@tangle('')
@tangle('backup: dummy')
@tangle('\t(DATE=`date +"%Y-%m-%d-%H%M"`;\\')
@tangle('\tmkdir -p ~/felix-backup/lpbackup/$${DATE};\\')
@tangle('\tcp lpsrc/*.ipk ~/felix-backup/lpbackup/$${DATE};\\')
@tangle('\tcp lpsrc/*.pak ~/felix-backup/lpbackup/$${DATE};\\')
@tangle('\t)')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tfor i in tmp/*.default; do cp $$i config/`basename $$i .default`; done')
@tangle('')
@tangle('wrappers.clean:')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('')
@tangle('config/cxx.flxcc: default_wrappers')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/c89.flxcc')
@tangle('\tbin/flxcc config/c99.flxcc')
@tangle('\tbin/flxcc config/gnu89.flxcc')
@tangle('\tbin/flxcc config/gnu99.flxcc')
@tangle('\tbin/flxcc config/cxx.flxcc')
@tangle('\tbin/flxcc config/cxx_sys.flxcc')
@tangle('\tbin/flxcc config/gnucxx.flxcc')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/bin')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/config')
@tangle('\tinstall -d ${DOC_DIR}/doc')
@tangle('\tinstall -d ${EXEC_DIR}')
@tangle('\tfor file in `ls config/*.py` `ls config/*.fpc` `ls config/*.flxcc`; do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/config; fi; done')
@tangle('\tinstall bin/flx ${EXEC_DIR}')
@tangle('\tfor file in `ls bin/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/bin; fi; done')
@tangle('\tfor file in `ls rtl/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/rtl; fi; done')
@tangle('\tfor file in `ls lib/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/lib; fi; done')
@tangle('\tfor file in `ls doc/*`;      do if [ -f $$file ]; then install $$file ${DOC_DIR}/doc; fi; done')
@tangle('\tfor file in `ls man/man1/*`; do if [ -f $$file ]; then install $$file ${MAN_DIR}/man1; fi; done')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = FLX_MAKER_CVS_ID.replace("$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle('.PHONY: dummy')
@tangle('')
@tangle('#')
@tangle('# ============== TARBALL MAKERS AND UPLOADERS ==============')
@tangle('#')
@tangle('# ------- TARBALL MAKERS --------------')
@tangle('#')
@tangle('')
@tangle('src_tarball: extract ')
@tangle('\trm -f felix-'+config.flx_version)
@tangle('\tln -s . felix-'+config.flx_version)
@tangle('\ttar -cvf flx_'+config.flx_version+'_src.tar\\')
@tangle('\t\tfelix-'+config.flx_version+'/configure \\')
@tangle('\t\tfelix-'+config.flx_version+'/mk \\')
@tangle('\t\tfelix-'+config.flx_version+'/autogen.sh \\')
@tangle('\t\tfelix-'+config.flx_version+'/*.bat \\')
@tangle('\t\tfelix-'+config.flx_version+'/Makefile \\')
@tangle('\t\tfelix-'+config.flx_version+'/README \\')
@tangle('\t\tfelix-'+config.flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+config.flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+config.flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+config.flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+config.flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+config.flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+config.flx_version+'/COPYING \\')
@tangle('\t\tfelix-'+config.flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+config.flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+config.flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/weavers/*.py ')
@# debian requires gzip -9
@tangle('\tgzip -9 flx_'+config.flx_version+'_src.tar')
@tangle('\tmv -f flx_'+config.flx_version+'_src.tar.gz flx_'+config.flx_version+'_src.tgz')
@tangle('')
@tangle('media_tarball:')
@tangle('\trm -f flx_media.tgz')
@tangle('\ttar -zcvf flx_media.tgz media')
@tangle('')
@tangle('doc_tarball:')
@tangle('\trm -f flx_doc.tgz')
@tangle('\ttar -zcvf flx_doc.tgz doc')
@tangle('')
@tangle('speed_tarball:')
@tangle('\trm -f flx_speed.tgz')
@tangle('\ttar -zcvf flx_speed.tgz speed/*.html speed/*.css speed/machine/*/images/*.jpg speed/machine/*/rankings/*.txt')
@tangle('')
@tangle('#')
@tangle('# ------- TARBALL FILES  --------------')
@tangle('#')
@tangle('flx_media.tgz: media_tarball')
@tangle('')
@tangle('flx_doc.tgz: doc_tarball')
@tangle('')
@tangle('flx_speed.tgz: speed_tarball')
@tangle('')
@tangle('flx_'+config.flx_version+'_src.tgz: src_tarball')
@tangle('')
@tangle('tarballs: flx_'+config.flx_version+'_src.tgz flx_speed.tgz flx_doc.tgz flx_media.tgz')
@tangle('')
@tangle('#')
@tangle('# ------- UPLOADERS --------------')
@tangle('#')
@tangle("#")
@tangle("# ******* WEB SITE MISC")
@tangle("#")
@tangle('upload_images:')
@tangle('\tscp homepage/images/*.jpg ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/images')
@tangle('')
@tangle('upload_homepage: dummy')
@tangle('\tscp homepage/*.html ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('upload_www: upload_homepage')
@tangle('\tscp www/*.html ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('')
@tangle("#")
@tangle("# ******* LP SOURCE TARBALL")
@tangle("#")
@tangle('upload_src: flx_'+config.flx_version+'_src.tgz')
@tangle('\tscp flx_'+config.flx_version+'_src.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle("#")
@tangle("# ******* MEDIA REQUIRED FOR TESTS")
@tangle("#")
@tangle('upload_media: flx_media.tgz')
@tangle('\tscp flx_media.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle("#")
@tangle("# ******* SPEED TEST TARBALL")
@tangle("#")
@tangle('upload_speed: flx_speed.tgz')
@tangle('\tscp -r flx_speed.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle("#")
@tangle("# ******* DOC TARBALL")
@tangle("#")
@tangle('upload_docs: flx_doc.tgz')
@tangle('\tscp -r flx_doc.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('# note: media is not uploaded here because it does not change much ')
@tangle('upload: upload_src upload_speed upload_docs')
@tangle('')
@tangle("#")
@tangle("# --------- UNPACKER -----------------------")
@tangle("#")
@tangle('unpack:')
@tangle('\tssh ${USER}@felix.sf.net "(cd /home/groups/f/fe/felix/htdocs/; tar -zxvf flx_doc.tgz; tar -zxvf flx_speed.tgz)"')
@tangle('')
@tangle('')
@tangle('')
@tangle('')
@tangle('')
@tangle('')

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues Cass

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors. The C parser is derived from
FrontC/CIL which is has BSD licence.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something ..

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something ..


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests,
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver.

Top level files:

@tangle('  VERSION   current version number, should be '+config.flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENCE   licence details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary

  Makefile   the makefile, mainly hooks into script/maker

  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  meta   -- contains various package manager meta-data files
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENCE')
@select(tangler('LICENCE'))
@tangle('Version ' + config.flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file


lpsrc/flx_frontc.ipk
lpsrc/flx_cil.ipk

are covered by a BSD Licence, here is the copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted,
 * provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 3. The name of the authors may not be used to endorse or promote products
 * derived from  this software without specific prior written permission.
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.08.1 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace

@tangle('   tar -zxvf flx_'+config.flx_version+'_src.tgz')
@tangle('   cd felix_'+config.flx_version)

4. Bootstrap the system.

  ./configure

OR type

   make config
   make boot
   make extract

EDIT THE FILES

  config/*.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make

6. Build the documentation and tutorial

   make doc

7. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak

                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  #import <flx.flxh>
  include "std";
  print "It works!"; endl;

and then run it:

  flx -Ilib mytest

@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.
Also some gif images.

@python("//")
def mkgif(fn,d):
  try:
    os.mkdir("misc")
  except:
    pass
  f = open("misc"+os.sep+fn+".gif","w")
  f.write(d)
  f.close()

plus=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\x91\x00\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\x00\x00"+
  "\x00\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x14\x8c\x8f\xa0"+
  "\x0b\xb6\xb2\x9c\x82\xca\x89\x7b"+
  "\x5b\x78\x71\xcf\xce\x74\x08\x52"+
  "\x00\x00\x3b")

minus=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\x91\x00\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\x00\x00"+
  "\x00\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x11\x8c\x8f\xa0"+
  "\x0b\xc6\xeb\x5e\x0b\x40\x58\x3b"+
  "\x65\x96\xf1\xa1\x1f\x14\x00\x3b")

dot=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\xa1\x03\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\xff\xff"+
  "\xff\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x0d\x84\x8f\xa9"+
  "\x20\x2b\x9f\x9e\x8c\x50\xb5\x85"+
  "\x55\x01\x00\x3b")

mkgif("plus",plus)
mkgif("minus",plus)
mkgif("dot",dot)

//

@select(tangler('misc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('misc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)


@head(1,"fishcc")
Script to compile a C program generated by FISh.
@select(tangler("bin/fishcc"))
grab=1
CCFLAGS=""
while (( "$grab" == "1" ));
do
  case x$1 in
  x-*)
    CCFLAGS="$CCFLAGS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done
@tangle('cmd="'+config.TARGET_CXX.options.CCLINK_STATIC+' $1 -O -o `basename $1 .c` `echo "$CCFLAGS"` -lflx_static"')
echo $cmd
`$cmd`

@head(1,'Run script')
@select(tangler('bin/flx.bat','data'))
@@echo off
SETLOCAL
SET RUNIT=1
SET DOFLXG=1
SET DOECHO=0
SET FID=%FLX_INSTALL_DIR%
SET STATIC=0

:DOARGS
IF "-c" EQU "%1" (
SET RUNIT=0
SHIFT
GOTO DOARGS
)

IF "--nofelix" EQU "%1" (
SET DOFLXG=0
SHIFT
GOTO DOARGS
)

IF "--echo" EQU "%1" (
echo on
SET DOECHO=1
SHIFT
GOTO DOARGS
)

IF "--test" EQU "%1" (
SET FID=.
SHIFT
GOTO DOARGS
)

IF "--static" EQU "%1" (
SET STATIC=1
SHIFT
GOTO DOARGS
)

"%FID%\BIN\FLXG" -I"%FID%\LIB" --import:flx.flxh std %1 >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
if %STATIC% EQU 0 (
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:cflags @%1.resh >%1_cflags.txt
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MD /c /EHs /w  /I"%FID%\LIB\RTL" /I"%FID%\config\target" @%1_cflags.txt %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:provides_dlib --field:requires_dlibs @%1.resh >%1_linkflags.txt
if ERRORLEVEL 1 GOTO ERROR
link /dll %1.obj /OUT:%1.dll @%1_linkflags.txt /LIBPATH:"%FID%\BIN" /DEFAULTLIB:libflx_dynamic >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1.exp
del %1.lib
del %1_cflags.txt
del %1_linkflags.txt
IF %RUNIT% EQU 1 (
"%FID%\bin\flx_arun" %1.dll %2 %3 %4 %5 %6 %7 %8 %9
)
) else (
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:cflags @%1.resh >%1_cflags.txt
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MT /c /EHs /w  /I"%FID%\LIB\RTL" /I"%FID%\config\target" /DFLX_STATIC_LINK @%1_cflags.txt %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:provides_slib --field:requires_slibs @%1.resh >%1_linkflags.txt
link "%FID%\rtl\flx_arun_static.obj" %1.obj /OUT:%1.exe @%1_linkflags.txt /LIBPATH:"%FID%\RTL" /DEFAULTLIB:libflx_async_static /DEFAULTLIB:libfaio_static /DEFAULTLIB:libdemux_static /DEFAULTLIB:libflx_pthread_static /DEFAULTLIB:libflx_static >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1_cflags.txt
del %1_linkflags.txt
%1 %2 %3 %4 %5 %6 %7 %8 %9
)
GOTO FINISHED
:ERROR
ECHO SOME KIND OF ERROR OCCURED, rerun with --echo
type %1.LOG
EXIT /B 1
:FINISHED
ENDLOCAL

@select(tangler('bin/flx.py','data'))
#!/usr/bin/env python
# flx.py - felix script harness (python version)
import os
import os.path
import sys
import stat
import string

@tangle("INSTALL_ROOT='%s/lib/felix/felix-%s'" % (config.PREFIX, config.flx_version))
FLX_INSTALL_DIR = os.getenv("FLX_INSTALL_DIR", INSTALL_ROOT)
@tangle("CYGWIN="+str(config.CYGWIN))
@tangle("WIN32="+str(config.WIN32))
@tangle("MACOSX="+str(config.MACOSX))
@tangle("HAVE_GNU="+str(config.HAVE_GNU))
@tangle("HAVE_MSVC="+str(config.HAVE_MSVC))
@tangle('CCOBJ_DLLIB="'+config.TARGET_CXX.options.CCOBJ_DYNAMIC_FLX+'"')
@tangle('CCLINK_DLLIB="'+config.TARGET_CXX.options.CCLINK_DYNAMIC_FLX+'"')
@tangle('CCOBJ_STATIC_LIB="'+config.TARGET_CXX.options.CCOBJ_STATIC_FLX+'"')
@tangle('CCLINK_STATIC="'+config.TARGET_CXX.options.CCLINK_STATIC+'"')
@tangle('VERSION="'+config.flx_version+'"')
@tangle('EXT_LIB="'+config.TARGET_CXX.options.EXT_LIB+'"')
@tangle('EXT_STATIC_OBJ="'+config.TARGET_CXX.options.EXT_STATIC_OBJ+'"')
@tangle('EXT_SHARED_OBJ="'+config.TARGET_CXX.options.EXT_SHARED_OBJ+'"')
@tangle('EXT_EXE="'+config.TARGET_CXX.options.EXT_EXE+'"')
@tangle('EXT_SHLIB="'+config.TARGET_CXX.options.EXT_SHLIB+'"')
@tangle('SPEC_OBJ_FILENAME="'+config.TARGET_CXX.options.SPEC_OBJ_FILENAME+'"')
@tangle('SPEC_EXE_FILENAME="'+config.TARGET_CXX.options.SPEC_EXE_FILENAME+'"')
@tangle('OPTIMISE="'+config.TARGET_CXX.options.OPTIMISE+'"')
@tangle('DEBUG_FLAGS="'+config.TARGET_CXX.options.DEBUG_FLAGS+'"')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=100
ECHO=0
TIME=0
NOOPTIMISE=0
TIMECMD="time -p"

@if config.DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""
FELIX=1
LINKER_SWITCHES=""
MACROS=""
grab=1
cpps=""
cppos=""
INCLUDE_DIRS=""
INCLUDE_FILES=""
NOSTDLIB=0
STDOUT=""
STDIMPORT="--import=flx.flxh"
IMPORTS=""

def splitext(p):
  if p[-5:-1] == ".flx":
    return p[:-5],".flx"
  elif p[-5:-1] == ".cpp":
    return p[:-5],".cpp"
  return p,""

def system(cmd):
  if ECHO==1: print cmd
  result = os.system(cmd)
  if ECHO==1: print "Result code " + str(result)
  return result

argno=1
def prefix(arg,key):
  return arg[:len(key)]==key

compile_exts = ['cpp','cxx']
linkexts = ['o','obj','lib','dll','a','so']

while grab == 1 and argno<len(sys.argv):
  arg = sys.argv[argno]
  #print "ARGNO="+str(argno)+", arg='"+arg+"'"
  path,ext = splitext(arg)
  dir,base = os.path.split(path)
  #print "path="+path+", ext="+ext+",dir="+dir+",base="+base
  #print "cpps="+cpps
  #print "cppos="+cppos
  #print "arg='"+arg+"'"
  if ext != "flx" and ext != "":
    if ext in compile_exts:
      cpps = cpps + " " + arg
      cppos = cppos + " " + path + "." + EXT_OBJ
    else:
     cppos = cppos + " " + arg

  elif arg == "--nostdimport":
    STDIMPORT=""

  elif prefix(arg,"--import="):
   IMPORTS=IMPORTS + " " + arg[9:]

  elif prefix(arg,"--test="):
    TESTMODE=1
    FLX_INSTALL_DIR=arg[7:]

  elif arg=="--test":
    TESTMODE=1
    FLX_INSTALL_DIR="."

  elif prefix(arg,"--stdout="):
    STDOUT=arg[9:]

  elif arg=="--force":
    RECOMPILE=1

  elif arg=="--debug":
    DEBUG=1
    ECHO=1
    NOOPTIMISE=1

  elif arg=="--nostdlib":
    NOSTDLIB=1

  elif arg == "--echo":
    ECHO=1

  elif arg == "--static":
    STATIC=1

  elif prefix(arg,"--inline="):
    INLINE=int(arg[:9])

  elif arg == "--inline":
    INLINE=100

  elif arg == "--noinline":
    INLINE=0

  elif arg == "--version":
    print "version .."
    print VERSION
    sys.exit(0)

  elif arg == "--where":
    print FLX_INSTALL_DIR
    sys.exit(0)

  elif arg == "--time":
    TIME=1

  elif arg == "--help":
    os.system("man flx")
    sys.exit(0)

  elif arg == "-c":
    RUNIT=0

  elif prefix(arg,"-I"):
    INCLUDE_DIRS=INCLUDE_DIRS + " " + arg

  elif arg== "--nofelix":
    FELIX=0

  elif prefix(arg,"-l") or prefix(arg,"-L"):
   LINKER_SWITCHES=LINKER_SWITCHES + " " + arg

  elif prefix(arg,"-D"):
   MACROS=MACROS + " " + arg

  elif prefix(arg,"--pkg="):
    pkgs= pkgs + " " + arg[6:]

  elif prefix(arg,"--"):
    print "Unknown option '"+ arg+"'"
    sys.exit(1)

# the main filename -- subsequent args are args to flx_run
  else:
    print "FILENAME="+ arg
    grab=0
  argno = argno + 1

#print grab,argno,len(sys.argv)
if grab == 1 and argno == len(sys.argv):
  print "usage: flx [options] filename"
  sys.exit(1)

#print "#--------"
#print "DONE, option index = "+str(argno)
#print "path="+path+", ext="+ext+",dir="+dir+",base="+base
#print "cpps="+cpps
#print "cppos="+cppos

if NOOPTIMISE == 0:
  CCFLAGS=CCFLAGS+" " + OPTIMISE

@if config.HAVE_MSVC:
  tangle('DLINK_STRING="/link /LIBPATH:"+FLX_INSTALL_DIR+"\\\\bin "')
  tangle('SLINK_STRING="/link /LIBPATH:"+FLX_INSTALL_DIR+"\\\\bin "')
 elif config.CYGWIN or config.WIN32:
  tangle('DLINK_STRING="-L"+{FLX_INSTALL_DIR+"/bin "')
  tangle('SLINK_STRING="-L"+FLX_INSTALL_DIR+"/lib/rtl "')
 else:
  tangle('DLINK_STRING="-L"+FLX_INSTALL_DIR+"/lib/rtl "')
  tangle('SLINK_STRING="-L"+FLX_INSTALL_DIR+"/lib/rtl "')


PKGCONFIG=os.path.join(FLX_INSTALL_DIR,"bin","flx_pkgconfig")

if ECHO == 1:
  print "#FLX_INSTALL_DIR="+FLX_INSTALL_DIR
  print "#PKGCONFIG="+PKGCONFIG

CONFIG_DIR = os.path.join(FLX_INSTALL_DIR,'config')

# find external header files
PKGCONFIG_CFLAGS=PKGCONFIG+ " --path+="+FLX_INSTALL_DIR+"/config --field=cflags "

# external header files
PKGCONFIG_INCLUDES=PKGCONFIG+ " --path+="+FLX_INSTALL_DIR+"/config --field=includes "

# find external dynload libraries
PKGCONFIG_DLIBS=PKGCONFIG+" -r --path+="+FLX_INSTALL_DIR+"/config --field=provides_dlib --field=requires_dlibs "

# find external static libraries
PKGCONFIG_SLIBS=PKGCONFIG+" -r --keeprightmost --path+="+FLX_INSTALL_DIR+"/config --field=provides_slib --field=requires_slibs "

#find driver package required
PKGCONFIG_DRIVER=PKGCONFIG+" --path+="+FLX_INSTALL_DIR+"/config --field=flx_requires_driver "

# make a list of any *.cpp files (or other g++ options ..)

if STATIC == 0:
  EXT_OBJ=EXT_SHARED_OBJ
else:
  EXT_OBJ=EXT_STATIC_OBJ

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

# Find absolute pathname

if path == "":
  sys.stderr.write("No such felix program: "+path+"\n")
  sys.exit(1)

def get_stdout(x,outit=None):
  # We're screwed if popen doesn't work ..

  if os.name == "nt": # popen doesn't work on Windows
    result = os.system(x + " >tmp.out")
    fout = open("tmp.out")
    output = fout.readlines()
    if outit:
      for line in output: outit(line)
    fout.close()
  else:
    fout = os.popen(x+" 2>&1 ","r")
    output = []
    try:
      for line in fout:
        output.append(line)
        if outit: outit(line)
    finally:
      result = fout.close()
  return result,output

def xqt(cmd,dflt=None):
  if ECHO == 1: print cmd
  result,output = get_stdout(cmd)
  if result == None:
     output=output[0][:-1] # first line excluding newline
     if ECHO==1:print "output="+output
     return output
  if dflt==None:
    sys.stderr.write("Error "+repr(result)+" executing command " + cmd+"\n")
    sys.exit(result)
  else: return dflt

def calpackages ():
  # find all include directories
  global INCLUDE_DIRS, INCLUDE_FILES, LINK_STRING, DRIVER

  x = xqt(PKGCONFIG_CFLAGS+ " @"+path+".resh")
  INCLUDE_DIRS=INCLUDE_DIRS +" " + x

  x = xqt(PKGCONFIG_INCLUDES+ " @"+path+".resh")
  INCLUDE_FILES=INCLUDE_FILES +" " + x


  # find the driver package
  DRIVER_PKG=xqt(PKGCONFIG_DRIVER+" @"+path+".resh")
  if DRIVER_PKG == "":
    DRIVER_PKG="flx_run"

  # find the driver entity
  if STATIC == 0:
    # dynamic linkage: the driver executable
    DRIVER=FLX_INSTALL_DIR+"/bin/"+DRIVER_PKG+EXT_EXE
  else:
    # static linkage: the driver object file
    DRIVER=FLX_INSTALL_DIR+"/lib/rtl/"+DRIVER_PKG+EXT_STATIC_OBJ

  if STATIC == 0:
    # dynamic linkage: all the libraries required by the application
    LINK_STRING=DLINK_STRING+LINKER_SWITCHES+xqt(
      PKGCONFIG_DLIBS+" @"+path+".resh")
  else:
    # static linkage: all the libraries required by the application and driver
    LINK_STRING=SLINK_STRING+LINKER_SWITCHES+xqt(
      PKGCONFIG_SLIBS+" "+DRIVER_PKG+" @"+path+".resh")

  if ECHO == 1:
    print "#RESOURCE FILE="+path+".resh"
    print "#INCLUDE_DIRS="+INCLUDE_DIRS
    print "#INCLUDE_FILES="+INCLUDE_FILES
    print "#DRIVER="+DRIVER
    print "#LINK_STRING="+LINK_STRING

def write_include_file(path):
  includes = INCLUDE_FILES.strip().split()
  f = open(path+".includes","w")
  for i in includes:
    f.write("#include " + i + "\n")
  f.close()

# grab program arguments
grab=1
args=' '.join(sys.argv[argno:])

INCLUDE_DIR="-I"+FLX_INSTALL_DIR+"/lib/rtl" + " -I"+FLX_INSTALL_DIR+"/config/target"
FLXLIB="-I"+FLX_INSTALL_DIR+"/lib"
STDLIB="std"
if NOSTDLIB == 1:
  FLXLIB=""
  STDLIB=""

FLXG="env PATH="+FLX_INSTALL_DIR+"/bin:$PATH "+FLX_INSTALL_DIR+"/bin/flxg"
# the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
if MACOSX == 1:
  FLXRUN="env DYLD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$DYLD_LIBRARY_PATH "
else:
  FLXRUN="env LD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$LD_LIBRARY_PATH "
ELKHOUND="--elkhound="+FLX_INSTALL_DIR+"/bin/flx_elkhound"

DEBUGSWITCH=""
if DEBUG == 1: DEBUGSWITCH=" --debug"

STATIC_ENV=""
if DEBUG == 1: STATIC_ENV="env FLX_DEBUG=1 "

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except EnvironmentError:
    t = 0
  return t

if RECOMPILE == 0 and RUNIT == 1:
  # not (--force or -c)
  if STATIC == 0:
    if (filetime(path+EXT_SHLIB) > filetime (path+".flx")):
      calpackages()
      cmd=FLXRUN+DRIVER+DEBUGSWITCH+" "+ path+EXT_SHLIB+" "+args
      sys.exit(system(cmd))
  else:
    if (filetime(path+EXT_EXE) > filetime(path+".flx")):
      cmd=STATIC_ENV+" "+path+" "+args
      sys.exit(system(cmd))

# Need Felix and c++ compile, then run it

if DEBUG == 1:
  VERBOSE="-v"
  CCFLAGS=CCFLAGS+DEBUG_FLAGS
else:
  VERBOSE="-q"

FLXFLAGS="--inline="+str(INLINE)

result = 0

if STATIC == 0:
  if FELIX == 1:
    FCMD=' '.join([
      FLXG,
      VERBOSE, FLXFLAGS, ELKHOUND, FLXLIB,
      INCLUDE_DIRS, STDIMPORT, IMPORTS,
      STDLIB, path])
    result=system(FCMD)
    if result != 0: sys.exit(0!=result)
    calpackages()
    write_include_file(path)
    CCMD=' '.join([
      CCOBJ_DLLIB, CCFLAGS, "-DTARGET_BUILD",
      INCLUDE_DIR, INCLUDE_DIRS, MACROS,
      cpps, path+".cpp",
      SPEC_OBJ_FILENAME+path+EXT_OBJ])
    LCMD=' '.join([
      CCLINK_DLLIB, CCFLAGS,
      cppos, path+EXT_OBJ,
      SPEC_EXE_FILENAME+path+EXT_SHLIB,
      LINK_STRING])
    result = system(CCMD)
    if result == 0:
      result = system(LCMD)
      if result == 0:
        if RUNIT == 1:
          if TIME == 1:
            cmd=' '.join([
              TIMECMD,
              FLXRUN+DRIVER+DEBUGSWITCH,
              path+EXT_SHLIB, args])
          else:
            cmd=' '.join([
              FLXRUN+DRIVER+DEBUGSWITCH,
              path+EXT_SHLIB, args])
          if STDOUT != "": cmd=cmd+" > " +STDOUT
          sys.exit(0!=system(cmd))
else:
  if FELIX == 1:
    FCMD=' '.join([
      FLXG, VERBOSE, FLXFLAGS, ELKHOUND,
      FLXLIB, INCLUDE_DIRS, STDIMPORT,
      IMPORTS, STDLIB, path])
    result=system(FCMD)
  if result == 0:
    calpackages()
    write_include_file(path)
    CCMD=' '.join([
      CCOBJ_STATIC_LIB,
      CCFLAGS, "-DTARGET_BUILD",
      "-DFLX_STATIC_LINK", INCLUDE_DIR, INCLUDE_DIRS,
      MACROS, cpps, path+".cpp",
      SPEC_OBJ_FILENAME+path+EXT_OBJ])
    LCMD=' '.join([
      CCLINK_STATIC, SPEC_EXE_FILENAME+path+EXT_EXE,
      path+EXT_OBJ, DRIVER, cppos, LINK_STRING])
    result=system(CCMD)
    if result == 0:
      result=system(LCMD)
      if result == 0:
        # rm -f "$base.cpp"
        if RUNIT == 1:
          if TIME == 1:
            cmd=' '.join([
              TIMECMD, STATIC_ENV, path, args])
          else:
            cmd=' '.join([
              STATIC_ENV, path,args])
          if STDOUT != "": cmd=cmd + " > "+STDOUT
          sys.exit(0!=system(cmd))
sys.exit(0!=result)

@select(tangler('bin/flx','data'))
#!/usr/bin/env bash
# flx - felix script harness
@tangle("INSTALL_ROOT="+config.PREFIX+"/lib/felix/felix-"+config.flx_version)
@tangle("FLX_INSTALL_DIR=${FLX_INSTALL_DIR:-$INSTALL_ROOT}")
@tangle("CYGWIN="+str(config.CYGWIN))
@tangle("WIN32="+str(config.WIN32))
@tangle("MACOSX="+str(config.MACOSX))
@tangle("HAVE_GNU="+str(config.HAVE_GNU))
@tangle("HAVE_MSVC="+str(config.HAVE_MSVC))
@if config.TARGET_CXX.options.HAVE_PIC:
  tangle('CCOBJ_DLLIB="'+config.TARGET_CXX.options.CCOBJ_DYNAMIC_FLX+' '+config.TARGET_CXX.options.PIC+'"')
 else:
  tangle('CCOBJ_DLLIB="'+config.TARGET_CXX.options.CCOBJ_DYNAMIC_FLX+'"')
@tangle('CCLINK_DLLIB="'+config.TARGET_CXX.options.CCLINK_DYNAMIC_FLX+'"')
@tangle('CCOBJ_STATIC_LIB="'+config.TARGET_CXX.options.CCOBJ_STATIC_FLX+'"')
@tangle('CCLINK_STATIC="'+config.TARGET_CXX.options.CCLINK_STATIC+'"')
@tangle('VERSION="'+config.flx_version+'"')
@tangle('EXT_LIB="'+config.TARGET_CXX.options.EXT_LIB+'"')
@tangle('EXT_STATIC_OBJ="'+config.TARGET_CXX.options.EXT_STATIC_OBJ+'"')
@tangle('EXT_SHARED_OBJ="'+config.TARGET_CXX.options.EXT_SHARED_OBJ+'"')
@tangle('EXT_EXE="'+config.TARGET_CXX.options.EXT_EXE+'"')
@tangle('EXT_SHLIB="'+config.TARGET_CXX.options.EXT_SHLIB+'"')
@tangle('SPEC_OBJ_FILENAME="'+config.TARGET_CXX.options.SPEC_OBJ_FILENAME+'"')
@tangle('SPEC_EXE_FILENAME="'+config.TARGET_CXX.options.SPEC_EXE_FILENAME+'"')
@tangle('OPTIMISE="'+config.TARGET_CXX.options.OPTIMISE+'"')
@tangle('DEBUG_FLAGS="'+config.TARGET_CXX.options.DEBUG_FLAGS+'"')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=100
ECHO=0
TIME=0
NOOPTIMISE=0

@if config.DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""
INCLUDE_FILES=""
FELIX=1
LINKER_SWITCHES=""
MACROS=""
grab=1
cpps=""
cppos=""
INCLUDE_DIRS=""
NOSTDLIB=0
STDOUT=""
STDIMPORT="--import=flx.flxh"
IMPORTS=""

while (( "$grab" == "1" ));
do
  case x$1 in

  x--nostdimport)
    STDIMPORT=""
    shift
  ;;

  x--import=*)
   IMPORTS="$IMPORTS --import=${1:9}"
   shift
 ;;

  x--test=*)
    TESTMODE=1
    FLX_INSTALL_DIR=${1:7}
    shift
  ;;

  x--test)
    TESTMODE=1
    FLX_INSTALL_DIR=.
    shift
  ;;

  x--stdout=*)
    STDOUT=${1:9}
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    ECHO=1
    NOOPTIMISE=1
    shift
  ;;

  x--time)
    TIME=1
    shift
  ;;

  x--nostdlib)
    NOSTDLIB=1
    shift
  ;;

  x--echo)
    ECHO=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline=*)
    INLINE=${1:9}
    shift
  ;;

  x--inline)
    INLINE=100
    shift
  ;;

  x--noinline)
    INLINE=0
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--help)
    man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x--nofelix)
    FELIX=0
    shift
  ;;

  x-[lL]*)
   LINKER_SWITCHES="$LINKER_SWITCHES $1"
   shift
  ;;

  x-D*)
   MACROS="$MACROS $1"
   shift
  ;;

  x*.cpp)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .cpp`$EXT_OBJ"
    shift
  ;;

  x*.cxx)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .cxx`$EXT_OBJ"
    shift
  ;;

  x*.c)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .c`$EXT_OBJ"
    shift
  ;;

  x*.o)
    cppos="$cppos `dirname $1`/`basename $1 .o`$EXT_OBJ"
    shift
  ;;

  x*.obj)
    cppos="$cppos `dirname $1`/`basename $1 .obj`$EXT_OBJ"
    shift
  ;;

  x*.a)
    cppos="$cppos $1"
    shift
  ;;

  x*.lib)
    cppos="$cppos $1"
    shift
  ;;

  x--pkg=*)
    pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
    shift
  ;;

# unknown flag .. pass to both compile and link
   x-*)
      cpps="$cpps $1"
      cppos="$cppos $1"
      shift
    ;;

# the main filename -- subsequent args are args to flx_run
  x*)
    grab=0
  ;;

  esac
done

if [ "$NOOPTIMISE" = "0" ]
then
  CCFLAGS=$CCFLAGS$OPTIMISE
fi

@if config.HAVE_MSVC:
  tangle('DLINK_STRING="/link /LIBPATH:${FLX_INSTALL_DIR}\\\\bin "')
  tangle('SLINK_STRING="/link /LIBPATH:${FLX_INSTALL_DIR}\\\\bin "')
 elif config.CYGWIN or config.WIN32:
  tangle('DLINK_STRING="-L${FLX_INSTALL_DIR}/bin "')
  tangle('SLINK_STRING="-L${FLX_INSTALL_DIR}/lib/rtl "')
 else:
  tangle('DLINK_STRING="-L${FLX_INSTALL_DIR}/lib/rtl "')
  tangle('SLINK_STRING="-L${FLX_INSTALL_DIR}/lib/rtl "')


PKGCONFIG="env FLX_DEBUG=0 FLX_ALLOW_COLLECTION_ANYWHERE=0 $FLX_INSTALL_DIR/bin/flx_pkgconfig"

if [ "$ECHO" = "1" ]
then
  echo "#FLX_INSTALL_DIR=$FLX_INSTALL_DIR"
  echo "#PKGCONFIG=$PKGCONFIG"
fi


# find external header files
PKGCONFIG_CFLAGS="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=cflags "

# external header files
PKGCONFIG_INCLUDES="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=includes "

# find external dynload libraries
PKGCONFIG_DLIBS="$PKGCONFIG -r --path+=$FLX_INSTALL_DIR/config --field=provides_dlib --field=requires_dlibs "

# find external static libraries
PKGCONFIG_SLIBS="$PKGCONFIG -r --keeprightmost --path+=$FLX_INSTALL_DIR/config --field=provides_slib --field=requires_slibs "

#find driver package required
PKGCONFIG_DRIVER="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=flx_requires_driver "

# make a list of any *.cpp files (or other g++ options ..)

if [ $STATIC = 0 ]
then
  EXT_OBJ=$EXT_SHARED_OBJ
else
  EXT_OBJ=$EXT_STATIC_OBJ
fi

if [ "x$1" = "x" ]
then
  echo "usage: flx [options] filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;

  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=$arg

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

function calpackages () {
  # find all include directories
  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_CFLAGS @$base.resh"
  fi

  INCLUDE_DIRS="$INCLUDE_DIRS $($(echo $PKGCONFIG_CFLAGS @$base.resh))"

  # find all include files
  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_INCLUDES @$base.resh"
  fi

  INCLUDE_FILES="$INCLUDE_FILES $($(echo $PKGCONFIG_INCLUDES @$base.resh))"


  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_DRIVER @$base.resh"
  fi

  # find the driver package
  DRIVER_PKG=$($(echo $PKGCONFIG_DRIVER @$base.resh))
  if [ x$DRIVER_PKG = x ]
  then
    # default to flx_run if none specified
    DRIVER_PKG=flx_run
  fi

  # find the driver entity
  if [ $STATIC = 0 ]
  then
    # dynamic linkage: the driver executable
    DRIVER=$FLX_INSTALL_DIR/bin/$DRIVER_PKG$EXT_EXE
  else
    # static linkage: the driver object file
    DRIVER=$FLX_INSTALL_DIR/lib/rtl/$DRIVER_PKG$EXT_STATIC_OBJ
  fi

  if [ $STATIC = 0 ]
  then
    if [ "$ECHO" = "1" ]
    then
     echo "$PKGCONFIG_DLIBS @$base.resh"
    fi

    # dynamic linkage: all the libraries required by the application
    LINK_STRING="$DLINK_STRING$LINKER_SWITCHES $($(echo $PKGCONFIG_DLIBS @$base.resh))"
  else
    if [ "$ECHO" = "1" ]
    then
     echo "$PKGCONFIG_SLIBS $DRIVER_PKG @$base.resh"
    fi

    # static linkage: all the libraries required by the application and driver
    LINK_STRING="$SLINK_STRING$LINKER_SWITCHES $($(echo $PKGCONFIG_SLIBS $DRIVER_PKG @$base.resh))"
  fi

  if [ $ECHO = 1 ]
  then
    echo "#RESOURCE FILE=$base.resh"
    echo "#INCLUDE_DIRS=$INCLUDE_DIRS"
    echo "#INCLUDE_FILES=$INCLUDE_FILES"
    echo "#DRIVER=$DRIVER"
    echo "#LINK_STRING=$LINK_STRING"
  fi

}

function write_include_file() {
  (for filename in ${INCLUDE_FILES:1}; do echo "#include $filename"; done) > $1.includes
}

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

INCLUDE_DIR="-I$FLX_INSTALL_DIR/lib/rtl -I$FLX_INSTALL_DIR/config/target"
FLXLIB="-I$FLX_INSTALL_DIR/lib"
STDLIB="std"
if [ "$NOSTDLIB" = "1" ]
then
  FLXLIB=""
  STDLIB=""
fi

if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
then
  # bash is a heap of crap! The escaped quotes here are
  # required in case the PATH has a filename with spaces
  # However this actually fails on Linux!
  FLXG="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" $FLX_INSTALL_DIR/bin/flxg"
  FLXRUN="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" "
else
  FLXG="env PATH=$FLX_INSTALL_DIR/bin:\$PATH $FLX_INSTALL_DIR/bin/flxg"
  # the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
  if [ "$MACOSX" = "1" ]
  then
    FLXRUN="env DYLD_LIBRARY_PATH=$FLX_INSTALL_DIR/lib/rtl:\$DYLD_LIBRARY_PATH "
  else
    FLXRUN="env LD_LIBRARY_PATH=$FLX_INSTALL_DIR/lib/rtl:\$LD_LIBRARY_PATH "
  fi
fi
ELKHOUND="--elkhound=$FLX_INSTALL_DIR/bin/flx_elkhound"

DEBUGSWITCH=""
if [ "$DEBUG" = "1" ]; then DEBUGSWITCH=" --debug"; fi
STATIC_ENV=""
if [ "$DEBUG" = "1" ]; then STATIC_ENV="env FLX_DEBUG=1 "; fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base$EXT_SHLIB" -a "(" ! -r "$base.flx" -o "$base$EXT_SHLIB" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      calpackages
      write_include_file $base
      cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
      exit $?
    fi
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base$EXT_EXE" -a "(" ! -r "$base.flx" -o "$base$EXT_EXE" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      cmd="$STATIC_ENV $base $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
      exit $?
    fi
  fi
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]
then
  VERBOSE="-v"
  CCFLAGS="$CCFLAGS$DEBUG_FLAGS"
else
  VERBOSE="-q"
fi

FLXFLAGS="--inline=$INLINE"

if [ $STATIC = 0 ]
then
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND $FLXLIB $INCLUDE_DIRS $STDIMPORT $IMPORTS $STDLIB $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    calpackages
    write_include_file $base
    CCMD="$CCOBJ_DLLIB $CCFLAGS -DTARGET_BUILD $INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_DLLIB $CCFLAGS $cppos $base$EXT_OBJ $SPEC_EXE_FILENAME$base$EXT_SHLIB $LINK_STRING "
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
          else
            cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
          fi
          if [ "$STDOUT" != "" ]; then cmd="$cmd > $STDOUT"; fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
      fi
    fi
  fi
else
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND $FLXLIB $INCLUDE_DIRS $STDIMPORT $IMPORTS $STDLIB $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    calpackages
    write_include_file $base
    CCMD="$CCOBJ_STATIC_LIB $CCFLAGS -DTARGET_BUILD -DFLX_STATIC_LINK $INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_STATIC $SPEC_EXE_FILENAME$base$EXT_EXE $base$EXT_OBJ ${DRIVER} $cppos $LINK_STRING"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        # rm -f "$base.cpp"
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $STATIC_ENV $base $args"
          else
            cmd="$STATIC_ENV $base $args"
          fi
          if [ "$STDOUT" != "" ]; then cmd="$cmd > $STDOUT"; fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
      fi
    fi
  fi
fi
exit $?

@select(tangler('bin/flx-postinstall-check','data'))
#!/usr/bin/env bash
FLX=flx
if [ "x$1" != x ]; then FLX="$1 $2 $3 $4 $5 $6 $7 $8"; fi

echo "Felix command is $FLX"
ok=0
bad=0
total=0
failed[0]=""

for i in test/*/*.flx tut/*/*.flx
do
  expect=`dirname $i`/`basename $i .flx`.expect
  if test -e $expect
  then
    total=$(($total+1))
    echo "$total -- check dynamic $i"
    rm -rf tmp.out
    $FLX --force --stdout=tmp.out $i
    diff -a -b -y --suppress-common-lines $expect tmp.out
    if [ "$?" != "0" ]
    then
      echo "*********ERROR"
      failed[$bad]="$total dynamic $i"
      bad=$(($bad+1))
    else
      ok=$(($ok+1))
    fi
    total=$(($total+1))
    echo "$total -- check static $i"
    rm -rf tmp.out
    $FLX --force --static --stdout=tmp.out $i
    diff -a -b -y --suppress-common-lines $expect tmp.out
    if [ "$?" != "0" ]
    then
      echo "*********ERROR"
      failed[$bad]="$total static $i"
      bad=$(($bad+1))
    else
      ok=$(($ok+1))
    fi
  fi
done

if [ $bad != 0 ]
then
  echo "============="
  echo "$bad FAILURES"
  echo "============="
  for ((i=0; i<$bad; i=$i+1)); do echo ${failed[$i]}; done
  echo $failed
  echo
fi
echo
echo "============"
echo "TEST SUMMARY"
echo "============"
echo "GOOD $ok"
echo "BAD  $bad"
echo "---------"
echo "TOTAL $total"
echo "---------"

exit $bad

@head(1,'Package Manager Meta Info')
@head(2,'GODI')
This is the Godiva file originally used to
create the GODI data. At the moment this is
the authoritative meta data. However,
godiva may not handle all the options
we need -- so the generated makefile
is included as well.

@select(tangler('meta/godiva/flx.godiva','data'))
Package: apps-felix
@tangle('Version: '+config.flx_version)
Revision: 0
Depends:
Build-Depends: godi-ocaml (> 3.08)
@tangle('Sources: http://felix.sf.net/flx_'+config.flx_version+'_src.tgz')
@tangle('Unpacks-To: flx_'+config.flx_version)
Bytecode-Target: all
Opt-Target: all
Homepage: http://felix.sf.net
Maintainer: John Skaller <skaller@users.sf.net>
Options: configure
Description: Felix Compiler
Felix Compiler
.

@select(tangler('meta/godiva/flx.godiva_camlsyntax','data'))
name = "felix";
@tangle('version = "'+config.flx_version+'";')
revision = 0;
category = `apps;
depends = [];
build_depends = [`godi,"ocaml", Some (`gt, "3.08")];
sources_site ="http://felix.sf.net/";
@tangle('sources_basename= "flx_'+config.flx_version+'_src";')
sources_extension = ".tgz";
@tangle('sources_unpacksto = "flx_'+config.flx_version+'";')
all_target= "all";
opt_target= "all";
homepage= "http://felix.sf.net";
maintainer = "John Skaller <skaller@users.sf.net>";
options= [`configure];
short_desc = "Felix Compiler";
long_desc = "Felix Compiler";
confopts = [
  {
    name = "SUPPORT_DYNAMIC_LOADING";
    default = "1";
    description = "Whether to support dlopen loading";
    implementation = `configarg "--SUPPORT_DYNAMIC_LOADING"
  }
];
specfile = "meta/godiva/flx.godiva_camlsyntax";
patches = [];
filesdir = None;

@select(tangler('meta/godi/DESCR','data'))
Felix Compiler and tools.

@doc()
This makefile only here for reference (don't use it,
it should be generated).

@select(tangler('meta/godi/Makefile','data'))
# This file was automatically generated by GODIVA
.include "../../mk/bsd.prefs.mk"
.include "../../mk/godi.pkg.mk"

@tangle('VERSION=        '+config.flx_version)
PKGNAME=        apps-felix-${VERSION}
@tangle('PKGREVISION=    '+config.godi_revision)
@tangle('DISTNAME=       flx_'+config.flx_version)
@tangle('DISTFILES=      flx_'+config.flx_version+'_src.tgz')
CATEGORIES=     apps
MASTER_SITES=   http://felix.sf.net/
MAINTAINER=     John Skaller <skaller@users.sf.net>
HOMEPAGE=       http://felix.sf.net
COMMENT=        Felix Compiler

# confopt defaults:


AUTOGENERATE_PLIST = yes
PKG  =          apps-felix
MAKE_FLAGS=     PREFIX=${PREFIX}



PATH:=          ${LOCALBASE}/bin:"${PATH}"
HAS_CONFIGURE = yes
CONFIGURE_ARGS+= --prefix ${PREFIX}
CONFIGURE_ENV+= ${BUILD_OCAMLFIND_ENV}
USE_GMAKE = yes

MAKE_ENV+=  ${BUILD_OCAMLFIND_ENV} PKGBASE=${PKGBASE:Q}

pre-configure-copy:
.	if exists(files)
	    cd files && ${PAX} -rw -pp . ${WRKSRC}
.	endif

pre-configure: pre-configure-copy

pre-install-mkdirs:
.	for d in bin lib/ocaml/pkg-lib doc share man etc info sbin include
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/${d}
.	endfor
.	for n in 1 2 3 4 5 6 7 8 9
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/man/man${n}
.	endfor

pre-install: pre-install-mkdirs

ALL_TARGET=     all
.if ${GODI_HAVE_OCAMLOPT} == "yes"
# ALL_TARGET+= all
.endif

post-install:
	mkdir -p ${PREFIX}/doc/${PKG}
.	for DOC in
	    install -m 0644 ${WRKSRC}/${DOC} ${PREFIX}/doc/${PKG}
.	endfor

.include "../../mk/bsd.pkg.mk"

@head(1,'Finish up')
Just cleaning up script now.
@make_executable(os.path.join('bin', 'flx'))
@make_executable(os.path.join('bin', 'flx.py'))
@make_executable(os.path.join('bin', 'fishcc'))


