@head(2,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID
@execfile('config'+os.sep+'flx_data.py')
@execfile('cpkgs'+os.sep+'interscript.py')

@head(2,'CVS LOG')
$Log$
Revision 1.22  2006/03/07 09:25:48  skaller
Fix bug in --lparchive feature

Revision 1.21  2006/03/07 09:07:17  skaller
Add --lparchive option to specify where LP source .paks
live

Revision 1.20  2006/03/07 06:19:52  idadesub
quicky hack to get things to configure on an intel mac. moved MakeError
into flxbuild/flxutil and imported it from there in flxbuild/make_config.py

Revision 1.19  2006/03/07 04:22:36  skaller
Termination in presence of spawned pthreads should now
be working, using new ts_locker class. Exception handling
on per thread basis not implemented yet.

Revision 1.18  2006/03/06 18:33:11  idadesub
I'm not positive I'm making the right assumptions here, but it looks
like this block of code with naked excepts can be turned into catching
MakeError as long as xqt reraises IOError and OSError as a MakeError.
However, if we can't assume that xqt will always be used as the shell in
autodetect, we may need to find an alternative to just catching MakeError

Revision 1.17  2006/03/06 13:16:16  skaller
Fix library builds so exports and imports are properly
distinguished on a library by library basis.

Revision 1.16  2006/03/04 02:21:40  skaller
Crude first order user defined reduction rules (non-polymorphic)
is now working!

Revision 1.15  2006/03/03 21:11:11  skaller
Misc fiddling with build system.
Start on expression term unification for user defined reductions.

Revision 1.14  2006/03/02 20:42:06  skaller
Nocygwin build, flx_pkgconfig.

Revision 1.13  2006/03/02 17:52:52  skaller
Fix flx_pkgconfig to handle linker switches

Revision 1.12  2006/03/02 05:44:00  skaller
Clean harder!

Revision 1.11  2006/03/02 02:41:39  skaller
Fixes for Win32/MSVC++ build.

Revision 1.10  2006/03/01 13:43:17  skaller
COnfig packages now seem to work on Linux. Added dependency
on libflx to flx_pthread.

Revision 1.9  2006/02/28 02:07:13  skaller
Refactor demux into demux + pthread.

Revision 1.8  2006/02/27 06:56:09  skaller
Refactoring speed test into modules.

Revision 1.7  2006/02/26 10:05:37  rfistman
made flx harness respect the driver_requires .resh field

Revision 1.6  2006/02/26 06:39:36  skaller
Fix flx_pkgconfig to conform to new spec.

Revision 1.5  2006/02/25 20:38:12  skaller
Upgrade flx_pkgconfig

Revision 1.4  2006/02/24 15:40:15  skaller
Enhance flx_pkgconfig

Revision 1.3  2006/02/24 03:15:01  rfistman
added flx_sdl_run

Revision 1.2  2006/02/24 01:52:57  rfistman
fixed bug in configure in which configure wasn't passing its args on

Revision 1.1  2006/02/23 19:33:01  skaller
More fiddling with build system

Revision 1.246  2006/02/23 17:06:08  skaller
Refactor build system.

Revision 1.245  2006/02/23 09:59:27  skaller
mingw builds

Revision 1.244  2006/02/23 06:50:04  skaller
Build SDL version of driver

Revision 1.243  2006/02/23 00:33:39  skaller
Split build into phases

Revision 1.242  2006/02/22 17:36:48  skaller
Rename some files.. more coming. Make RTL modules full .paks

Revision 1.241  2006/02/21 05:46:46  skaller
Fix wrong link flag tag.

Revision 1.240  2006/02/21 02:41:07  skaller
Add --pkg option to maker script. First work on callback
binding feature.

Revision 1.239  2006/02/20 09:53:01  skaller
Nocywgin build

Revision 1.238  2006/02/20 09:21:25  skaller
Mingw/nocygwin support

Revision 1.237  2006/02/20 02:48:37  skaller
Release preparation.

Revision 1.236  2006/02/19 14:35:44  skaller
More switches for WIN32

Revision 1.235  2006/02/19 14:02:51  skaller
Windows sys libs with right switches

Revision 1.234  2006/02/18 18:03:47  skaller
Package manager fixes

Revision 1.233  2006/02/18 17:04:51  skaller
Fixes for Cygwin

Revision 1.232  2006/02/18 16:30:48  skaller
More work on new package manager.

Revision 1.231  2006/02/17 09:38:32  skaller

conditionalised recursive mutex (to be removed)
fixed windows lib_requires (added lib prefix)

Revision 1.230  2006/02/16 15:19:28  skaller
MSVC++ fixes

Revision 1.229  2006/02/16 15:09:45  skaller
MSVC++ package manager

Revision 1.228  2006/02/16 11:50:25  skaller
Add ts_select_demuxer to package files

Revision 1.227  2006/02/16 11:36:28  skaller
Flx ts collector needs to go in demux since it uses mutex.

Revision 1.226  2006/02/16 10:53:43  skaller
Add dependencies for Cygwin dynamic linkage.

Revision 1.225  2006/02/16 07:51:40  skaller
Replace pkg-config with a Felix program flx_pkgconfig.
Make sure to build it in a timely manner, since flx script
now depends on it.

Revision 1.224  2006/02/16 03:30:01  skaller
More string functions in library.

Revision 1.223  2006/02/15 10:54:09  skaller
Build time packaging system.

Revision 1.221  2006/02/14 09:02:00  skaller
Splitup flx_maker.ipk to get rid of some build utilities.

Revision 1.220  2006/02/13 12:28:38  skaller
Thread safe collector

Revision 1.219  2006/02/09 21:05:33  skaller
Fixed sdl to use polling.

Revision 1.218  2006/02/08 16:19:43  skaller
Changed flx_run so it executes an exported flx_main procedure
after thread frame initialisation blocks (and thus before
async wakes up any fthreads)

Revision 1.217  2006/02/07 15:55:06  skaller
Added portable semaphores and a monitor class to demux.

Revision 1.216  2006/02/06 06:50:01  skaller
Added pthread_cond_timedwait and pthread_cond_uswait functions
to condition variables. The latter is my own invention, it waits
for a specific interval in micro-seconds. The later is more
efficient on Windows when you want to wait for an interval,
since this is the native method. Otherwise you need to first
obtain the time of day, do a nasty calculation .. and then
the timedwait function will undo that, resulting in two
unnecessary and expensive system calls.

Revision 1.215  2006/02/04 10:35:55  skaller
Portable thread sync stuff

Revision 1.213  2006/02/02 19:24:07  skaller
Couple of changes to build script for OSX and BSD from Erick

Revision 1.212  2006/02/02 18:52:35  skaller
Reorganise demux a bit

Revision 1.211  2006/02/02 15:29:32  skaller
Factor flx_run.

Revision 1.210  2006/01/30 08:58:19  skaller
Add package support to flx script

Revision 1.209  2006/01/29 07:07:21  skaller
fixed visual studio build after demux merge

Revision 1.208  2006/01/29 02:53:16  rfistman
fixed missing epoll header for linux.:w

Revision 1.207  2006/01/25 00:34:40  rfistman
removed a few outstanding references to SDL_image
fixed a tiny typo in flx_use.ipk
got rid of superfluous private fn in faio.

Revision 1.206  2006/01/24 19:15:49  skaller
Add openGL test sdl110. Currently crashes in gc.
Add async request counter to driver.
Add configuration hack for openGL.

Revision 1.205  2006/01/21 17:02:12  skaller
SDL sound with Felix callback, and asynchronous multiplexor
for timeout/keypress example. COOL!

Revision 1.204  2006/01/18 14:52:14  skaller
Wrapped SDL event source, test case in tut/examples/sdl100

Revision 1.203  2006/01/18 05:50:04  rfistman
turned sdl_event thing into a driver request

Revision 1.202  2006/01/13 05:16:50  rfistman
made worker_fifo portable

Revision 1.201  2006/01/11 04:30:45  rfistman
added portable sleep

Revision 1.200  2006/01/11 01:16:32  rfistman
added win_timer_queue to demux

Revision 1.199  2006/01/09 16:32:03  skaller
Integrate SDL tests, provide initial SDL event demux.

Revision 1.198  2006/01/08 08:56:44  skaller
Change rtl name for MACOSX to libflx_dynamic.dylib

Revision 1.197  2006/01/07 17:24:58  skaller
Added SDL binding. Fixed bug in function return type so
that lvalue return types now return C++ references.
Added _deref primitive, define deref to use it for Felix refs,
and defined a primitive for C pointers.

Revision 1.196  2006/01/05 04:00:35  rfistman
fixed problem in solaris evtports where adding both reading and
writing sockets caused a race condition (now we have two two
"half-demuxers", for input and output)

pc listener create function can now let winsock choose the port,
just like the posix version.

much factoring:
  overlapped calls factored back to demux as control blocks
  posix socket code factored in preparation for UDP/dgram and IPv6 sockets.

Revision 1.195  2006/01/03 16:15:10  skaller
Changed all print functions to fprint, which requires an
ostream as first argument. Provide macro print to support
existing code. Note overloads on print will not work.
Procedures objects can now be created on the stack,
such procedures have no resume method.

Revision 1.194  2006/01/02 00:54:16  skaller
Fixes to macro processor including bug in goto feature.

Revision 1.193  2006/01/01 09:04:54  rfistman
made a few solaris style changes (own demuxer and a few build
incompatibilities fixed)

Revision 1.192  2005/12/30 01:21:50  rfistman
conditionalised maker+bagley to use DLYD_LIBRARY_PATH on the mac.

Revision 1.191  2005/12/29 02:10:41  rfistman
now using flx_run thread spawn, fixed uninited variable, trying kqueue
event source on the mac.

Revision 1.190  2005/12/28 07:32:54  skaller
Add skeleton for async I/O tests.

Revision 1.189  2005/12/28 07:05:16  rfistman
hooked up posix async code - seems to work!

Revision 1.188  2005/12/28 03:34:16  rfistman
added faio supporting c code, partitioned files into posix/win32

Revision 1.187  2005/12/28 01:33:22  rfistman
moved all faio header files and flx support files over to felix proper
fixed typo

Revision 1.186  2005/12/27 12:31:49  skaller
Skeleton for faio.

Revision 1.185  2005/12/27 07:10:41  skaller
Fix library order, fix to choose library name based on compiler instead of os.

Revision 1.184  2005/12/27 06:05:46  skaller
Fix make script for Windows

Revision 1.183  2005/12/26 17:55:10  skaller
Add pthread support.
Add new methods for locating felix in flx script:
  FLX_INSTALL_DIR environment variable locates uninstalled package
  --test=INSTALL_DIR switch overrides it
Add new method for locating flx_elkhound to flxg:
  --elkhound=bin/flx_elkhound specifies path
  automatically set by flx script

Revision 1.182  2005/12/26 06:20:35  skaller
Add mutexlite to interfaces ..

Revision 1.181  2005/12/26 06:17:15  skaller
Copy demux interfaces to rtl directory

Revision 1.180  2005/12/26 03:38:50  skaller
Add support for Solaris, bsd, linux specific builds

Revision 1.179  2005/12/26 02:14:55  skaller
Add RF's demux library to core

Revision 1.178  2005/12/08 11:52:47  skaller
User defined statements Work in Progress.
Fix serious gc bug, abstract types of kind GC_pointer
were not being NULL initialised in generated constructors.

Revision 1.177  2005/11/21 05:23:58  skaller
svc_kill, svc_close

Revision 1.176  2005/11/13 09:58:33  skaller
Fiddling with Classes.

Revision 1.175  2005/11/12 17:26:48  skaller
First implementation of classes is working, doesn't provide
correct shapes yet (may not initialise pointers either).

Revision 1.174  2005/10/31 21:22:32  skaller
I/O channels now working.

Revision 1.173  2005/10/31 03:38:06  skaller
Fiddle with service request stuff

Revision 1.172  2005/10/29 05:48:20  skaller
Fixed numerous minor bugs

Revision 1.171  2005/10/28 04:08:43  skaller
Test in ocaml config for -w xy options needed for 3.09,
extend handling of user defined infix operators to allow
keywords.

Revision 1.170  2005/10/27 18:19:33  skaller
add -W y option to suppress Ocaml 3.09 warning Y

Revision 1.169  2005/10/27 16:46:27  skaller
Add user defined infix operators.

Revision 1.168  2005/10/24 08:29:10  skaller
Blah

Revision 1.167  2005/10/23 04:11:50  skaller
Fixed inlining bug, removed special useless call eliminator

Revision 1.166  2005/10/22 00:57:16  skaller
Implemented Service Control Requests

Revision 1.165  2005/10/19 08:32:58  skaller
Added <- operator and more OO stuff.

Revision 1.164  2005/10/19 01:28:32  rfistman
fixed problem in cygwin build, seemed that the while loop in the configure
script was actually wrong under cygwin, a syntax error.

Revision 1.163  2005/10/16 17:38:42  skaller
Add cclass wrapper construction to sugar up
wrapping C++ classes. At this stage, four member types are
supported: val, var, fun, and proc all corresponding to
non-static members. Constructors are not yet supported.

Revision 1.162  2005/10/13 20:43:09  skaller
Added --static to Windows flx script

Revision 1.161  2005/10/13 19:42:24  skaller
Add a Windows version of the 'flx' script called bin/flx.bat

Revision 1.160  2005/10/09 00:59:25  skaller
Experiment with group extraction in regexps using Inria code.

Revision 1.159  2005/10/07 18:07:11  skaller
Fix win32 build bugs .. again ..

Revision 1.158  2005/10/06 15:21:24  skaller
Refactoring build system.

Revision 1.157  2005/10/05 06:29:31  skaller
More work on type constraints, more OO in build system.

Revision 1.156  2005/10/03 18:58:11  skaller
Basic type constraints now working.

Revision 1.155  2005/09/30 19:01:19  skaller
Rewrote the lookup to use a single record for recursion stopper,
repairs on type functions so type matches reduce properly,
preparation for type constraints.

Revision 1.154  2005/09/24 21:46:33  skaller
More pathname fixes (/ vs \, using os.sep ..) and DIFF fix

Revision 1.153  2005/09/24 20:46:13  skaller
Fix static RTL to be built by the TARGET C++ compiler, not
the HOST C++ compiler.

Revision 1.152  2005/09/23 23:17:55  skaller
Fix PYTHONPATH problems; add typeset and intersection types

Revision 1.151  2005/09/21 01:26:53  skaller
Change headers and bodies to use C strings as "no substitution"
so $ etc in comments don't cause trouble.

Revision 1.150  2005/09/15 18:19:53  skaller
Minor fixes to new system on Linux

Revision 1.149  2005/09/15 14:29:13  skaller
Full native Win32 version running (no Cygwin at all)

Revision 1.148  2005/09/14 09:43:59  skaller
win32 and nocywin work, cygwin still doesn't

Revision 1.147  2005/09/12 17:59:24  skaller
Win32 build working

Revision 1.146  2005/09/12 16:32:10  skaller
Win32 build

Revision 1.145  2005/09/11 16:25:21  skaller
Add WIN32 check for running tests, don't use LD_LIBRARY_PATH

Revision 1.144  2005/09/11 16:22:30  skaller
Most of Win32 running now

Revision 1.143  2005/09/11 04:45:09  skaller
win32 build

Revision 1.142  2005/09/10 04:44:00  skaller
Remove ocamlopt -cc-lib flags (seems to work without these)

Revision 1.141  2005/09/10 04:30:22  skaller
Win32 build

Revision 1.140  2005/09/08 19:11:09  skaller
change obj_extension to EXT_OBJ

Revision 1.139  2005/09/07 17:38:51  skaller
Get -mno-cygwin to work

Revision 1.138  2005/09/06 19:13:25  skaller
Add a new option to 'flx' bash script: --nofelix prevents flxg running,
allowing a hand modified C++ program to be compiled (and run) without
needing to figure out all the flags.

Revision 1.137  2005/09/06 18:44:47  skaller
Due to inane incompatibilities in bash, Cygwin requires
quotes around the argument to env, whereas
Linux will not accept them.

Revision 1.136  2005/09/06 16:44:12  skaller
More fiddling. Optimisation is now the default!

Revision 1.135  2005/09/05 15:38:10  skaller
Fix build bug where dynamic linkage wasn't supported.

Revision 1.134  2005/09/04 17:40:21  skaller
Make the tests run in 'all' actually run all 4 combinations
of optimisation and linkage.

Revision 1.133  2005/09/03 19:35:39  skaller
New object based toolchain support system

Revision 1.132  2005/08/31 06:55:34  skaller
Make a link for Linux for the RTL so the loader finds the library.

Revision 1.131  2005/08/31 06:24:19  skaller
More cygwin fiddling

Revision 1.130  2005/08/30 19:56:30  skaller
more fiddling g++ switches

Revision 1.129  2005/08/30 02:10:05  skaller
Put -Lrtl -lflx_dynamic on the end of --test mode bin/flx dynamic link command line

Revision 1.128  2005/08/29 16:15:19  skaller
Clean up a bit, fix incorrect gc usage indicator, and
finally eliminate the collector_t &gc; statement altogether.
Add a new combinator `BEXPR_apply_struct which handles
calls to struct, cstruct, a nonconst_ctor type constructors
distinctly from applications of primitives and Felix functions.

Revision 1.127  2005/08/27 18:54:45  skaller
Get more of the python class based cross-compilation support
scripts to work. g++ class now works for the main build and tests.
bin/flx is not yet supported by this mechanism and may never be,
since it would introduce a dependence on Python to run it,
however this may be necessary for Windows anyhow, since bin/flx
is a bash script.

Revision 1.126  2005/08/26 06:11:47  skaller
Start new build method using Python class for C++ compiler.

Revision 1.125  2005/08/21 15:48:10  skaller
Fix bug in flx script in --test mode with dynamic linkage for Cygwin environment.

Revision 1.124  2005/08/18 14:29:15  rfistman
added dynamic linking for os x. uses dlcompat which may have only been
introduced in 10.3. will probably need more work for 10.2, 10.1

Revision 1.123  2005/08/08 16:23:53  skaller
Add #error preprocessor directive, fix make script to send output
to NUL in Win32 where it goes to /dev/null in unix.

Revision 1.122  2005/08/05 03:10:29  skaller
Cleaned up sm.pak so __UNIX__ flag no longer needed

Revision 1.121  2005/08/02 17:15:15  haeleth
Dynamic loading for Cygwin

Revision 1.120  2005/08/02 16:09:40  skaller
Add FLX_EXPORT to exported function declarations.

Revision 1.119  2005/08/01 07:54:26  skaller
Fixed PATH with spaces problem (however more related problems with
other variables such as include paths probably remain)

Revision 1.118  2005/07/29 08:34:50  skaller
Make config script a bit more platform independent by using os.sep,
python filecopy routine replacing cp

Revision 1.117  2005/07/28 22:11:09  skaller
Get log to work ..


@h = tangler('script/fcount.py','python')
@select(h)
import glob
import os
import sys
if '' not in sys.path: sys.path = ['']+sys.path
import flxbuild
from flxbuild.flxutil import *

try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

try:
  key = sys.argv[2]
except:
  key = "std"

try:
  globspec = sys.argv[3]
except:
  globspec = "tut/examples/*.hpp"

print "function counter: STATS FILE",filename, "KEY", key, "GLOB",globspec
dict = {}
try:
  execfile (filename)
except:pass

files = glob.glob(globspec)

for file in files:
  cmd = 'egrep "//PROC|//FUNCTION" ' + file + ' | wc -l'
  result,output = get_stdout(cmd)
  output = output[0][:-1]
  x = int(output)
  try:
    d= dict[file]
  except:
    dict[file]={}
    d = dict[file]
  d[key]=x

f = open(filename,"w")
f.write("dict="+repr(dict))
f.close()

@h = tangler('script/pfcount.py','python')
@select(h)
import glob
import os
import sys
try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

only_nonopt = 0
try:
  x = sys.argv[2]
except:
  only_nonopt = 1

dict = {}
try:
  execfile (filename)
except:pass

keys = {}
i = 0
for k in dict.keys():
  i = max(i,len(k))
  d = dict[k]
  for key in d.keys():
    keys[key]=None

keys = keys.keys()
j=0
for k in keys:
  j = max(j,len(k))

print "Function counts for test programs"
print "================================="
print
print ("%-"+str(i+2)+"s") % "File" + "    ",
for t in keys:
  print ("%"+str(j+2)+"s") % t,
print
print "--------"

skeys = dict.keys()
skeys.sort()

for k in skeys:
  d = dict[k]
  x= ("%-"+str(i+2)+"s") % k + "..  "
  discard = 0
  for t in keys:
    v = pkgdict.get(t,-1)
    if v == -1:
      v = ""
    elif (v == 1 or v == 0) and t == "inline" and only_nonopt: 
      discard = 1
      break
    else:
      v = str(v)
    v = ("%"+str(j+2)+"s") % v
    x = x+v
  if not discard: print x

@h = tangler('script/mk_expect','python')
@select(h)
import glob
import sys
for k in sys.argv[1:]:
  files = glob.glob(k+'/*.output')
  print '@head(1,"Expected outputs for '+k+'")'
  for i in files:
    j = i[:-7]+'.expect'
    print '@head(2,"'+j+'")'
    print '@select(tangler("'+j+'","data"))'
    f = open(i,"r")
    for l in f: print l,
    f.close()


@h = tangler('spkgs/misc.py')
@select(h)
# files containing ocamllex sources
MISC_LEXS = []

# files containing ocamlyacc sources
MISC_PARSES = [ ]

# ocaml modules = interfaces + implementation files
MISC_MODULES = [
  'src/flx_filesys'      ,
]

MISC_INTERFACES = MISC_MODULES

MISC_IMPLEMENTATIONS = MISC_INTERFACES

caml_interfaces = MISC_INTERFACES
caml_implementations = MISC_IMPLEMENTATIONS


@h = tangler('spkgs/cil.py')
@select(h)
CIL_LEXS = [ 'src/flx_cil_clexer', 'src/flx_cil_formatlex', ]
CIL_PARSES = [ 'src/flx_cil_cparser', 'src/flx_cil_formatparse', ]

CIL_MODULES = [
  'src/flx_cil_machdep_type',
  'src/flx_cil_cabs',
  'src/flx_cil_cilversion',
  'src/flx_cil_machdep',
  'src/flx_cil_pretty',
  'src/flx_cil_errormsg',
  'src/flx_cil_cabs_helper',
  'src/flx_cil_lexerhack',
  'src/flx_cil_escape',
  'src/flx_cil_cprint',
  'src/flx_cil_cparser',
  'src/flx_cil_clexer',
  'src/flx_cil_stats',
  'src/flx_cil_trace',
  'src/flx_cil_clist',
  'src/flx_cil_cil',
  'src/flx_cil_frontc',
  'src/flx_cil_rmtmps',
  'src/flx_cil_cabsvisit',
  'src/flx_cil_inthash',
  'src/flx_cil_formatparse',
  'src/flx_cil_formatlex',
  'src/flx_cil_util',
  'src/flx_cil_mergecil',
  'src/flx_cil_patch',
  'src/flx_cil_formatcil',
  'src/flx_cil_cilutil',
  'src/flx_cil_cabs2cil',
  'src/flx_cil_check',
]

CIL_RAW_INTERFACES = [
  'src/flx_cil_machdep_type',
  'src/flx_cil_cabs',
]

CIL_INTERFACES = CIL_MODULES
CIL_IMPLEMENTATIONS = CIL_INTERFACES
CIL_EXES = [ 'src/flxcc', ]


caml_lexes = CIL_LEXS
caml_parses = CIL_PARSES
caml_raw_interfaces = CIL_RAW_INTERFACES
caml_interfaces = CIL_INTERFACES
caml_implementations = CIL_IMPLEMENTATIONS
caml_exes = CIL_EXES
caml_require_libs = ['nums','unix','misclib','cillib','flxlib']
pkg_requires = ['flx','misc']

@h = tangler('spkgs/flx_compiler.py')
@select(h)
FLX_LEXS = [ 'src/flx_lex' ]
FLX_PARSES = [ 'src/flx_parse' ]

FLX_MODULES = [
  'src/inria_table'      ,
  'src/inria_cset'      ,
  'src/inria_syntax'      ,
  'src/inria_lexgen'      ,
  'src/flx_mtypes1'      ,
  'src/flx_ast'          ,
  'src/flx_types'        ,
  'src/flx_ctypes'       ,
  'src/flx_version'      ,
  'src/flx_ctype'        ,
  'src/flx_util'         ,
  'src/flx_dlst'         ,
  'src/flx_getopt'       ,
  'src/flx_mtypes2'      ,
  'src/flx_srcref'       ,
  'src/flx_typing'       ,
  'src/flx_exceptions'   ,
  'src/flx_string'       ,
  'src/flx_id'           ,
  'src/flx_print'        ,
  'src/flx_maps'         ,
  'src/flx_typing2'      ,
  'src/flx_unify'        ,
  'src/flx_charset'      ,
  'src/flx_constfld'     , 
  'src/flx_cexpr'        ,
  'src/flx_csubst'       , 
  'src/flx_parse'        ,
  'src/flx_keywords'     ,
  'src/flx_prelex'       ,
  'src/flx_lex1'         ,
  'src/flx_tok'          ,
  'src/flx_lexstate'     ,
  'src/flx_preproc'      ,
  'src/flx_lex'          ,
  'src/flx_pretok'       ,
  'src/flx_parse_ctrl'   ,
  'src/flx_dfa'          ,
  'src/flx_pat'          , 
  'src/flx_macro'        , 
  'src/flx_desugar'      , 
  'src/flx_mbind'        , 
  'src/flx_symtab'       , 
  'src/flx_name'         , 
  'src/flx_treg'         ,
  'src/flx_beta'         ,
  'src/flx_tpat'         , 
  'src/flx_tconstraint'  ,
  'src/flx_generic'      , 
  'src/flx_overload'     , 
  'src/flx_lookup'       , 
  'src/flx_bexe'         , 
  'src/flx_bbind'        , 
  'src/flx_label'        , 
  'src/flx_cflow'        , 
  'src/flx_call'         , 
  'src/flx_use'          , 
  'src/flx_child'        , 
  'src/flx_tailit'       , 
  'src/flx_inline'       , 
  'src/flx_stack_calls'  , 
  'src/flx_mkcls'        , 
  'src/flx_global'       , 
  'src/flx_inst'         , 
  'src/flx_tgen'         , 
  'src/flx_display'      , 
  'src/flx_ogen'         , 
  'src/flx_regen'        ,
  'src/flx_unravel'      , 
  'src/flx_pgen'         , 
  'src/flx_egen'         , 
  'src/flx_ctorgen'      , 
  'src/flx_elkgen'       , 
  'src/flx_gen'          , 
  'src/flx_flxopt'       , 
  'src/flx_terminate'    , 
]

FLX_RAW_INTERFACES = [
  'src/flx_ast'          ,
  'src/flx_types'        ,
  'src/flx_ctypes'       ,
] 

FLX_INTERFACES = FLX_MODULES

FLX_IMPLEMENTATIONS = FLX_INTERFACES

FLX_EXES = [
  'src/flxl',
  'src/flxp',
  'src/flxm',
  'src/flxd',
  'src/flxb',
  'src/flxg',
  'src/stub',
]

caml_lexes = FLX_LEXS
caml_parses = FLX_PARSES
caml_interfaces = FLX_INTERFACES
caml_raw_interfaces = FLX_RAW_INTERFACES
caml_exes = FLX_EXES
caml_implementations = FLX_IMPLEMENTATIONS
caml_require_libs = ['nums','unix','misclib','flxlib']
pkg_requires = ['misc']
caml_provide_lib = 'flxlib'
iscr_source = ["lpsrc/flx.pak"]

@h = tangler('spkgs/flx_regression_tests.py')
@select(h)
TESTS = glob.glob('test'+os.sep+'rt*.flx')
# these are supposed to fail!
BAD_TESTS = glob.glob('test'+os.sep+'bt*.flx')

unit_tests = TESTS
failure_tests = BAD_TESTS
pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.ipk']

@h = tangler('spkgs/flx_tutorial_tests.py')
@select(h)
TESTS = glob.glob('tut'+os.sep+'examples'+os.sep+'tut*.flx')
TESTS = TESTS + glob.glob('tut'+os.sep+'examples'+os.sep+'mac*.flx')
TESTS = TESTS + glob.glob('tut'+os.sep+'examples'+os.sep+'mig*.flx')

unit_tests = TESTS
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','faio']
iscr_source = [
  'lpsrc/flx_tutorial.pak',
  'lpsrc/flx_tut_bind.pak',
  'lpsrc/flx_tut_macro.pak',
  'lpsrc/flx_tut_migrate.pak',
  'lpsrc/flx_tut_expect.ipk',
  ]

@h = tangler('spkgs/ocs.py')
@select(h)
OCS_MODULES = [
  'ocs_vartable', 
  'ocs_error', 
  'ocs_port', 
  'ocs_types', 
  'ocs_sym', 
  'ocs_env',
  'ocs_char', 
  'ocs_numaux', 
  'ocs_complex', 
  'ocs_num', 
  'ocs_numstr', 
  'ocs_lex',
  'ocs_misc',
  'ocs_read', 
  'ocs_eval', 
  'ocs_list', 
  'ocs_compile', 
  'ocs_macro', 
  'ocs_prim', 
  'ocs_string',
  'ocs_vector', 
  'ocs_print', 
  'ocs_io', 
  'ocs_contin', 
  'ocs_top', 
]

@h = tangler('mk','data')
@select(h)
python script/maker $1 $2 $3 $4 $5 $6 $7 $8 $9
@os.system("chmod u+x mk")
@h = tangler('mk.bat','data')
@select(h)
python script\maker %1 %2 %3 %4 %5 %6 %7 %8 %9
@select(tangler('mkplugins/man.py'))
def plugin():    
    print "GENERATING MAN PAGES"
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = string.split(file,".")[0]
        xqt(
          "man2html man/man1/" + file + 
          '| sed -e "s%<A HREF=\\"[^<]*cgi-bin/man/man2html?1+\(.*\)\\">%<A HREF=\\"\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "htmlman/" + basename+'_1.html'
        )
    except:pass
  
@select(tangler('mkplugins/impldoc.py'))
def plugin():    
    print "GENERATING OCAMLDOCS"
    erasedir('impldoc')
    os.mkdir('impldoc')
    try:
      xqt('ocamldoc -I src -d impldoc src/*.mli -html')
      xqt('ocamldoc -I src -o impldoc/flx_impl.tex src/*.mli -latex')
      xqt('(cd impldoc; latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex)')
    except: 
     pass # well ocamldoc is full of bugs ..

@select(tangler('mkplugins/rtldoc.py'))
def plugin():    
    print "GENERATING RTLDOCS"
    erasedir('rtldoc')
    os.mkdir('rtldoc')
    try:
      xqt("doxygen misc/doxconf.dox")
    except:
      pass

@select(tangler('mkplugins/copy_mli2ml.py'))
def copy_mli2ml(MLIS):
  for f in MLIS:
    f = string.replace(f,"/",os.sep)
    src = f+'.mli'
    dst = f+'.ml'
    print("filecopy "+src+" -> "+dst)
    filecopy(src,dst)

@select(tangler('mkplugins/copy_hpp2rtl.py'))
def copy_hpp2rtl(HPPS):
  for f in HPPS:
    dst = 'rtl'+os.sep+string.split(f,'/')[-1]
    src = string.replace(f,"/",os.sep)
    print("filecopy "+src+" -> "+dst)
    filecopy(src,dst)

@select(tangler('mkplugins/ocamlit.py'))
#ocaml compilation
def ocamlit(LEXS,PARSES,INTERFACES,IMPLEMENTATIONS,EXES):
  # STEP 2: Generate lexers
  for lex in LEXS:
    file = string.replace(lex,'/',os.sep)
    xqt(OCAMLLEX + file + '.mll')

  # STEP 3: Generate parsers
  for parse in PARSES:
    file = string.replace(parse,'/',os.sep)
    xqt(OCAMLYACC+ ' -v '+ file + '.mly')
    nxqt(GREP+"conflict " + file + ".output")

  # STEP 4: Compile ocaml interfaces
  for interface in INTERFACES:
    file = string.replace(interface,'/',os.sep)
    xqt(OCAMLC + ' ' + OCAML_INCLUDES+' -c '+file+ '.mli')

  # STEP 5: Compile ocaml implementations
  for implementation in IMPLEMENTATIONS + EXES:
    file = string.replace(implementation,'/',os.sep)
    xqt(OCAMLOPT + ' '+ OCAML_INCLUDES+ ' -c ' + file +'.ml')


@select(tangler('mkplugins/build_ocamls.py'))
def build_ocamls():        
  LEXS = pkgdict.get("caml_lexes",[])
  PARSES = pkgdict.get("caml_parses",[])
  INTERFACES = pkgdict.get("caml_interfaces",[])
  IMPLEMENTATIONS = pkgdict.get("caml_implementations",[])
  EXES = pkgdict.get("caml_exes",[])
  OLIBRARIES = pkgdict.get("caml_require_libs",[])
  if (len(LEXS)+
    len(PARSES)+
    len(INTERFACES)+
    len(IMPLEMENTATIONS)+
    len(EXES)+
    len(OLIBRARIES)> 0):
    print "CAML COMPILING "+pkg
    ocamlit(LEXS,PARSES,INTERFACES,IMPLEMENTATIONS,EXES)

    # STEP 6: Build Ocaml Library
    if IMPLEMENTATIONS != []:
      lib = pkgdict.get('caml_provide_lib',pkg+"lib")
      print "CAML CREATING LIBRARY ",lib
      object_library_name = "src" + os.sep + lib + OCAML_LIB_EXTENSION
      linkstring = OCAMLOPT + " -a -o " + object_library_name + " "
      library_filetime = filetime(object_library_name)
      for implementation in IMPLEMENTATIONS:
        linkstring = linkstring + implementation +OCAML_OBJECT_EXTENSION +" "
      xqt(linkstring)

      print "CAML LINKING EXECUTABLES"
      x = ''
      for library in OLIBRARIES:
        x = x + ' ' + library + OCAML_LIB_EXTENSION

      # finally, mainline *.cmx or cma files to link to executables
      for exe in EXES:
        dst = "bin" + os.sep + string.split(exe,"/")[-1]
        xqt(OCAMLOPT + LDFLAGS + ' ' + OCAML_INCLUDES + ' -o '+dst+ x + OBJECT_FILES + ' src/flx_version_hook.ml ' + exe + OCAML_OBJECT_EXTENSION)

@select(tangler('mkplugins/build_host_tools.py'))
def build_host_tools():        
  CPPS = pkgdict.get("host_cpp_cpps",[])
  EXES = pkgdict.get("host_exes",[])
  LIBS = pkgdict.get("host_exes_require_libs",[])
  if len(CPPS)+len(EXES)+len(LIBS)>0:
    print "BUILDING HOST TOOLS"
    ars = ""
    if CPPS:
      print "HOST C++ COMPILING "+pkg
      for x in CPPS:
        if not "quiet" in options: print 'Compiling host '+pkg+' object',x
        ars = ars + x + "_static.o "
        dir,base = string.split(x,'/')
        HOST_CXX.compile_static_rtl(
          xqt,
          dir,
          base,
          dir,
          include_path=["rtl","elk"],
          macros=["FLX_STATIC_LINK"])
      tmp = string.split(ars)
      objs=[]
      for i in tmp:
        objs.append(i[:-2]) # chop off the .o
      HOST_CXX.link_static_archive(xqt,objs,dir+"/lib"+pkg+"_host_static")

    for src,bin in EXES:
      dir,base = string.split(src,'/')
      HOST_CXX.compile_static_main(
        xqt,
        dir,
        base,
        dir,
        include_path=["rtl","elk"],
        macros=["FLX_STATIC_LINK"],
        CFLAGS=CFLAGS)
      HOST_CXX.link_static_program(
        xqt,
        [src+"_static"],
        bin,
        lib_path=[dir],
        libs=["lib"+pkg+"_host_static"],
        SFLAGS=SFLAGS)


@select(tangler('mkplugins/build_testfile.py'))
def build_test(testfile):        
  optimise= "optimise_c" in options
  mode = "std"
  if optimise: mode = "Optimised"
  print "------------------------------------------------"
  print 'TRANSLATING',testfile
  basename = string.split(testfile,'.')[0]
  cppfilename = basename + ".cpp"
  resfilename = basename + ".resh"
  path = string.split(basename,'/')
  indir = string.join(path[:-1],os.sep)
  infile= path[-1]
  try:
    flxg('-Ilib ' +FLXFLAGS + basename,basename)
  except MakeError:
    print 'TESTFILE -- ERROR!',basename
    erasefile(basename+'.cpp')
    erasefile(basename+'.hpp')
    raise MakeError

  cmd = "bin"+os.sep+"flx_pkgconfig --path=config --field=cflags @"+resfilename
  result,cflags= get_stdout(cmd)
  if result: 
    print "flx_pkgconfig failed! Args=",cmd
    raise MakeError

  cflags = string.strip(cflags[0])
  #print 'Compiling generated code of ',testfile
  try:
    if SUPPORT_DYNAMIC_LOADING:
      print "COMPILING GENERATED C++ TEST CODE: " + mode+ " (dynamic)"
      TARGET_CXX.compile_felix_dll(xqt,indir,infile,indir,
        include_path=["rtl"],
        optimise=optimise,
        CFLAGS=CFLAGS+" "+cflags)

      cmd = "bin"+os.sep+"flx_pkgconfig --path=config --field=provides_dlib --field=requires_dlibs @"+resfilename
      result,dlibs= get_stdout(cmd)
      if result: 
        print "flx_pkgconfig failed! Args=",cmd
        raise MakeError
      dlibs = string.strip(dlibs[0])

      TARGET_CXX.link_felix_dll(
        xqt,[basename+"_dynamic"],
        basename,
        lib_path=[SHLIB_DIR],
        DFLAGS=DFLAGS+dlibs)

    if SUPPORT_STATIC_LINKAGE:
      print "COMPILING GENERATED C++ TEST CODE: " + mode+ " (static)"
      TARGET_CXX.compile_felix_static(
        xqt,
        indir,
        infile,
        indir,
        include_path=["rtl"],
        optimise=optimise,
        macros=["FLX_STATIC_LINK"],
        CFLAGS=CFLAGS+" "+cflags)

      cmd = "bin"+os.sep+"flx_pkgconfig -r --keeprightmost --path=config "
      cmd = cmd + "--field=provides_slib --field=requires_slibs flx_run @"+resfilename
      result,slibs= get_stdout(cmd)
      if result: 
        print "flx_pkgconfig failed! Args=",cmd
        raise MakeError
      slibs = string.strip(slibs[0])

      TARGET_CXX.link_static_program(
        xqt,
        ["rtl/flx_run_static",basename+"_static"],
        basename,
        lib_path=["rtl"],
        libs=[],
        SFLAGS=SFLAGS+slibs)
    #print 'TESTFILE -- OK!',basename
  except MakeError:
    print 'TESTFILE -- ERROR!',basename
    erasefile(basename+EXT_SHLIB)
    erasefile(basename+EXT_EXE)
    raise MakeError

  return basename


@select(tangler('mkplugins/diff_env.py'))
if os.name == 'nt': # build system is Windows Python
  DIFF = "FC /L /W "
  GREP = "#grep "
else:
  #DIFF = "diff -a -b " # build system is Unix Python
  # RF - trying out args that work on solaris (-a = not cool)
  # could use that sys type stuff here?
  DIFF = "diff -b " # build system is Unix Python
  GREP = "grep "


@select(tangler('mkplugins/virgin.py'))
#cleans everything
def plugin():
  for d in ["tmp",
     "rtl",
     "lib"+os.sep+"GL", "lib"+os.sep+"SDL", "lib", "bin",
     "elk",
     "src",
     "lib","doc",
     "man"+os.sep+"man1","man",
     "impldoc","htmlman","meta",
     "tools"+os.sep+"lua", "tools",
     "faio","demux",
     "tut"+os.sep+"examples","tut",
     "bagley"+os.sep+"data",
     "bagley"+os.sep+"felix",
     "bagley",
     "test",
     "pkg",
     "mkplugin",
     "flxbuild",
     "meta"+os.sep+"godi", "meta"+os.sep+"godiva", "meta",
     "misc"+os.sep+"vim",
     "misc"+os.sep+"lua",
     "misc"+os.sep+"jedit",
     "misc",
     "www"
     ]:
    for f in glob.glob(d + os.sep + "*"):
      print "Del",f
      erasefile(f)
    try: 
      if os.path.exists(d):
        os.rmdir(d)
        print "Rmdir",d
    except: 
      print "FAILED Rmdir",d
  for f in glob.glob(FLX_LPARCHIVE+os.sep+"lpsrc"+os.sep+"*.cache"):
    erasefile(f)
  runISCR(FLX_LPARCHIVE+os.sep+'lpsrc/flx_config.pak',1)
  sys.exit(0)
  
@select(tangler('mkplugins/clean.py'))
# cleans products, but not extracted sources
def plugin():
  for d in [ 
    "test","tut"+os.sep+"examples",
    "bagley"+os.sep+"felix",
    "src","elk","demux","faio","lib","lpsrc","rtl","bin"
    ]:
    for e in ["*.hpp","*.so","*.dll","*.cpp","*.hpp",
      "*.par","*.output","*.o","*.obj",
      "*.exp","*.lib",'*.resh','*.par',
      "*.cache","*.a","*.exp","*.exe",
      "*.cmi","*.cmx","*.cmxa",
      ]:
      for f in glob.glob(d + os.sep + e):
        erasefile(f)
  for f in glob.glob("lib"+os.sep+"*.par"):
    erasefile(f)
  for f in glob.glob(FLX_LPARCHIVE+os.sep+"lpsrc"+os.sep+"*.cache"):
    erasefile(f)

@select(tangler('mkplugins/doc_env.py'))
# where documentation gets put
WEAVER_DIRECTORY='doc/'
TUTORIAL_DIRECTORY='tut/'
TUTORIAL_DOC=TUTORIAL_DIRECTORY+'doc/'
TUTORIAL_EXAMPLES=TUTORIAL_DIRECTORY+'examples/'

@select(tangler('mkplugins/doc.py'))
def plugin():    
    print "GENERATING DOCUMENTATION"
    runISCR(FLX_LPARCHIVE+os.sep+'lpsrc/flx_config.pak')
    runISCR(FLX_LPARCHIVE+os.sep+'lpsrc/flx.pak')
    runISCR('--language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+WEAVER_DIRECTORY+' '+FLX_LPARCHIVE+os.sep'lpsrc/flx.pak')

@select(tangler('mkplugins/tutdoc.py'))
def plugin():    
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' '+FLX_LPARCHIVE+os.sep+'lpsrc/flx_tutorial.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' '+FLX_LPARCHIVE+os.sep+'lpsrc/flx_tut_macro.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' '+FLX_LPARCHIVE+os.sep+'lpsrc/flx_tut_bind.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --weaver=latex --passes=2 --weaver-directory='+TUTORIAL_DOC+' '+FLX_LPARCHIVE+os.sep+'lpsrc/flx_tut_migrate.pak')
    runISCR('--inhibit-sref=1 --language=en --weaver=web --passes=2 --weaver-directory=speed/ '+FLX_LPARCHIVE+os.sep+'lpsrc/flx_perf.pak')
    filecopy('doc'+os.sep+'interscript.css','speed'+os.sep+'interscript.css')

@select(tangler('mkplugins/build_target_rtl_dynamic.py'))
def build_target_rtl_dynamic():
  ars = ""
  CPPS = pkgdict.get("cpp_cpps",[])
  BUILD_MACRO = pkgdict.get("build_macro","ERROR!")
  EXTRA_CFLAGS = pkgdict.get("cflags","")
  EXTRA_DFLAGS = pkgdict.get("dflags","")
  if CPPS:
    print " ++ "+pkg+" RTL (dynamic)"
    for x in CPPS:
      if not "quiet" in options: print 'Compiling rtl object',x
      ars = ars + x + "_dynamic.o "
      dir,base = string.split(x,'/')
      TARGET_CXX.compile_shared_rtl(
        xqt,
        dir,
        base,
        dir,
        include_path=['rtl'],
        optimise=1,
        macros=["BUILD_"+BUILD_MACRO],
        CFLAGS=CFLAGS+EXTRA_CFLAGS)

    # LINK RTL
    tmp = string.split(ars)
    objs=[]
    for i in tmp:
      objs.append(i[:-2]) # chop off the .o
    flibs = pkgdict.get("lib_requires",[])
    needs_libs = []
    for i in flibs:
      needs_libs.append(i+"_dynamic")
    lib = pkgdict.get("provide_lib","lib"+pkg)
    TARGET_CXX.link_shared_rtl(
      xqt,objs,
      SHLIB_DIR+os.sep+lib+"_dynamic",
      lib_path=[SHLIB_DIR],
      libs=EXTRA_LIBS+needs_libs,
      DFLAGS=DFLAGS+EXTRA_DFLAGS) # hack

@select(tangler('mkplugins/build_target_rtl_static.py'))
def build_target_rtl_static():
  ars = ""
  CPPS = pkgdict.get("cpp_cpps",[])
  EXTRA_CFLAGS = pkgdict.get("cflags","")
  if CPPS:
    print " ++ "+pkg+" RTL (static)"
    for x in CPPS:
      if not "quiet" in options: print 'Compiling rtl object',x
      ars = ars + x + "_static.o "
      dir,base = string.split(x,'/')
      TARGET_CXX.compile_static_rtl(
        xqt,dir,base,
        dir,
        include_path=['rtl'],
        macros=["FLX_STATIC_LINK"],
        optimise=1,
        CFLAGS=CFLAGS+EXTRA_CFLAGS)

    tmp = string.split(ars)
    objs=[]
    for i in tmp:
      objs.append(i[:-2]) # chop off the .o
    lib = pkgdict.get("provide_lib","lib"+pkg)
    TARGET_CXX.link_static_archive(
      xqt,
      objs,
      "rtl/"+lib+"_static")

@select(tangler('mkplugins/build_felix_static_drivers.py'))
def build_felix_static_drivers():
  DRIVERS = pkgdict.get("drivers",[])
  cflags = pkgdict.get("cflags","")
  if len(DRIVERS)>0:
    print "COMPILING DRIVERS (static)"
    ars = ""
    for i,j in DRIVERS:
      if not "quiet" in options: print 'static Compiling driver object',i
      dir,base = string.split(i,'/')
      TARGET_CXX.compile_static_main(
        xqt,dir,base,dir,
        include_path=["rtl"],
        macros=["FLX_STATIC_LINK"],
        optimise=1,CFLAGS=CFLAGS+cflags)

@select(tangler('mkplugins/build_felix_dynamic_drivers.py'))
def build_felix_dynamic_drivers():
  DRIVERS = pkgdict.get("drivers",[])
  cflags = pkgdict.get("cflags","")
  if len(DRIVERS)>0:
    print "COMPILING DRIVERS (dynamic)"
    ars = ""
    dflags = pkgdict.get("dflags","")
    LIBS = pkgdict.get("drivers_require_libs",[])
    libs = []
    for lib in LIBS:
      libs.append(lib+"_dynamic")
    for i,j in DRIVERS:
      if not "quiet" in options: print 'dynamic Compiling driver object',i
      dir,base = string.split(i,'/')
      TARGET_CXX.compile_shared_main(
        xqt,dir,base,dir,
        include_path=["rtl"],
        optimise=1,
        CFLAGS=CFLAGS+cflags)
      TARGET_CXX.link_dynamic_program(
        xqt,
        [i+"_dynamic"],
        j,
        lib_path=[SHLIB_DIR],
        libs=libs,
        DFLAGS=DFLAGS+dflags)

@select(tangler('mkplugins/build_target_cpp_tools.py'))
def build_target_cpp_tools():
  ars = ""
  EXES = pkgdict.get("exes",[])
  esflags = pkgdict.get("exes_require_linkflags","")
  if len(EXES)>0:
    print "BUILDING C++ TARGET TOOLS"
    LIBS = pkgdict.get("exes_require_libs",[])
    libs = []
    for lib in LIBS: libs.append(lib+"_static")
    for src,bin in EXES:
      dir,base = string.split(src,'/')
      TARGET_CXX.compile_static_main(
        xqt,
        dir,
        base,
        dir,
        include_path=["rtl"],
        macros=["FLX_STATIC_LINK"],
        CFLAGS=CFLAGS)
      TARGET_CXX.link_static_program(
        xqt,
        [src+"_static"],
        bin,
        lib_path=[dir],
        libs=libs,
        SFLAGS=SFLAGS+esflags)

@select(tangler('mkplugins/build_target_felix_tools.py'))
# TARGET TOOLS : FELIX
def build_target_felix_tools():
  FLXS = pkgdict.get("felix_tools",[])
  if len(FLXS)>0:
    print "BUILDING FELIX TARGET TOOLS"
    LIBS = pkgdict.get("exes_require_libs",[])
    libs = []
    for lib in LIBS: libs.append(lib+"_static")
    fsflags = pkgdict.get("felix_requires_linkflags","")
    for src,exe in FLXS:
      dir,base = string.split(src,'/')
      flxg("-Ilib "+src,"crap")
      TARGET_CXX.compile_felix_static(
        xqt,
        dir,
        base,
        dir,
        include_path=['rtl'],
        macros=["FLX_STATIC_LINK"],
        CFLAGS=CFLAGS)
      TARGET_CXX.link_static_program(
        xqt,
        ['rtl/flx_run_static',src+"_static"],
        exe,
        lib_path=['rtl'],
        libs=libs,
        SFLAGS=SFLAGS+fsflags)

@select(tangler('mkplugins/performance.py'))
def plugin():
  for driver,testfile,moreargs in SPECIAL_TESTS:
    test_basename = string.split(testfile,'.')[0]
    drv_basename = string.split(driver,'.')[0]
    if LINK_MODEL == "dynamic":
      testscript = "time ./"+drv_basename+ " ./"+test_basename+SHLX+" " + moreargs
    else:
      testscript = "time ./"+test_basename+SHLX+" " + moreargs
    #print 'Executing ',testscript
    try:
      run(testscript)
      #print 'TESTFILE -- OK!',testscript
    except MakeError:
      print 'TESTFILE -- ERROR!',testscript
      raise MakeError

@select(tangler('mkplugins/speed.py'))
def plugin():    
  runISCR(FLX_LPARCHIVE+os.sep+'lpsrc/flx_perf.pak')
  run("python speed/measure.py")
  run("python speed/panal.py")
  run("gnuplot speed/mkjpgs.gpl")
  runISCR('--inhibit-sref=1 --language=en --weaver=web --passes=2 --weaver-directory=speed/ '+FLX_LPARCHIVE+os.sep+'lpsrc/flx_perf.pak')

@select(tangler('mkplugins/ocaml_env.py'))
if not globals().get("ocaml_env",None):
  ocaml_env = 1

  OCAML_OBJDIR = "src"
  BYTECODE = not NATIVE_CODE_COMPILER or "bytecode" in options 
  if BYTECODE:
    if "profile" in options: 
      OCAMLOPT = OCAMLCP
      OCAMLC = OCAMLCP
    else: OCAMLOPT = OCAMLB
  else:
    OCAMLOPT = OCAMLC
    if "profile" in options:
      OCAMLOPT = OCAMLOPT+' -p '

  OCAMLOPT = OCAMLOPT + " -I " + OCAML_OBJDIR
  OCAMLC = OCAMLC + " -I " + OCAML_OBJDIR

  if "debug" in options:
    OCAMLOPT = OCAMLOPT + '-g '

  if "optimise_felix" in options:
    OCAMLOPT = OCAMLOPT + " -unsafe -noassert -inline 5 "

  if BYTECODE == 0:
    OCAML_OBJECT_EXTENSION = '.cmx'
    OCAML_LIB_EXTENSION = '.cmxa'
  else:
    OCAML_OBJECT_EXTENSION = '.cmo'
    OCAML_LIB_EXTENSION = '.cma'

@select(tangler('mkplugins/link_model_env.py'))
if not globals().get("link_model_env",None):
  link_model_env = 1

  LINK_MODEL = DEFAULT_LINK_MODEL
  if "static" in options:
    LINK_MODEL = "static"
  if "dynamic" in options:
    LINK_MODEL == "dynamic"

  if LINK_MODEL == "dynamic" and not SUPPORT_DYNAMIC_LOADING:
    print "dynamic linkage not supported"
    sys.exit(1)

  if LINK_MODEL == "static" and not SUPPORT_STATIC_LINKAGE:
    print "dynamic linkage not supported"
    sys.exit(1)

  CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "

  if LINK_MODEL == "dynamic":
    SHLX = EXT_SHLIB
  else:
    SHLX = EXT_EXE

  CCMACS=""
  for i in options:
    if i[0:2]=="-D": CCMACS=CCMACS+i+" "

  if CCMACS:
    CCOBJ_STATIC_RTL = CCOBJ_STATIC_RTL + CCMACS
    CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + CCMACS
    CCOBJ_STATIC_FLX = CCOBJ_STATIC_FLX + CCMACS

    CCOBJ_DYNAMIC_RTL = CCOBJ_DYNAMIC_MAIN + CCMACS
    CCOBJ_DYNAMIC_MAIN = CCOBJ_DYNAMIC_MAIN + CCMACS
    CCOBJ_DYNAMIC_FLX = CCOBJ_DYNAMIC_FLX + CCMACS


@select(tangler('mkplugins/run_host_tests.py'))
def run_host_tests():    
  optimise= "optimise_c" in options
  mode = "std"
  if optimise: mode = "Optimised"
  bad_tests = pkgdict.get("failure_tests",[])
  if len(bad_tests)>0:
    print
    print "***** TESTING PACKAGE "+pkg+" ************"
    print
    for testfile in bad_tests:
      #print 'Running Felix code generator on ',testfile
      basename = string.split(testfile,'.')[0]
      cppfilename = basename + ".cpp"
      try:
        xqtq('bin'+os.sep+'flxg -e -Ilib ' + basename)
        #print 'TESTFILE -- failed as expected',basename
        erasefile(basename+'.cpp')
        erasefile(basename+'.hpp')
      except MakeError:
        print 'TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED!',basename
        erasefile(basename+'.cpp')
        erasefile(basename+'.hpp')
        raise MakeError

@select(tangler('mkplugins/run_unit_tests.py'))
def run_unit_tests():    
  optimise= "optimise_c" in options
  mode = "std"
  if optimise: mode = "Optimised"
  unit_tests = pkgdict.get("unit_tests",[])
  if len(unit_tests)>0:
    print
    print "***** TESTING PACKAGE "+pkg+" ************"
    print

    for testfile in unit_tests:
      # run the tests
      basename = build_test(testfile)
      if SUPPORT_DYNAMIC_LOADING:
        testscript = "bin"+os.sep+"flx_run "+os.curdir+os.sep+basename+EXT_SHLIB
        testscript = testscript + " >" + basename + ".output"
        testscript = testscript + " && "+DIFF+ basename + ".expect "+ basename + ".output"
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          raise MakeError

      if SUPPORT_STATIC_LINKAGE:
        testscript = basename
        testscript = os.curdir+os.sep+basename+EXT_EXE
        testscript = testscript + " >" + basename + ".output"
        testscript = testscript + " && "+DIFF+ basename + ".expect "+ basename + ".output"
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          raise MakeError


@select(tangler('mkplugins/run_demos.py'))
def run_demos():    
  optimise= "optimise_c" in options
  mode = "std"
  if optimise: mode = "Optimised"
  demos = pkgdict.get("demos",[])


  if len(demos)>0:
    print "RUNNING DEMOS"
    for testfile in demos:
      basename = build_test(testfile)
    # subroutine candidate
      resfilename = basename + ".resh"
      cmd = "bin"+os.sep+"flx_pkgconfig --path=config "
      cmd = cmd +"--field=flx_requires_driver @"+resfilename
      result,requires_driver= get_stdout(cmd)
      if result: 
        print "flx_pkgconfig failed! Args=",cmd
        raise MakeError

      requires_driver = string.strip(requires_driver[0])
  
      if not requires_driver:
        requires_driver="flx_run"

      if SUPPORT_DYNAMIC_LOADING:
        testscript = "bin"+os.sep+requires_driver+" "+os.curdir+os.sep+basename+EXT_SHLIB
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          raise MakeError

      if SUPPORT_STATIC_LINKAGE:
        testscript = os.curdir+os.sep+basename+EXT_EXE
        #print 'Executing ',testscript
        try:
          run(testscript)
          #print 'TESTFILE -- OK!',testscript
        except MakeError:
          print 'TESTFILE -- ERROR!',testscript
          raise MakeError

@select(tangler('mkplugins/xqt.py'))
get_stdouterr = get_stdout

def flush():
  try: sys.stdin.flush()
  except: pass

def run(x):
  print x
  flush()
  result = os.system(ENV+x)
  if result: print "  .. ERROR CODE",hex(result)
  flush()

  if result:
    raise MakeError

def xqt(x):
  if "quiet" not in options: print x
  flush()

  try:
    result,output = get_stdouterr(x)
  except (IOError, OSError):
    raise MakeError

  if result: 
    if "quiet" in options: print x
    print "  .. ERROR CODE",hex(result)
  if output: 
    if result or "quiet" not in options:
      print string.join(output,"")
  flush()

  if result:
    raise MakeError

# quiet execution
def xqtq(x):
  if "quiet" not in options: print x
  flush()
  result,output = get_stdouterr(x)
  if result: 
    if "quiet" in options: print x
    print "  .. ERROR CODE",hex(result)
    raise MakeError

if os.name=="nt":
  ENV="set PATH=bin;%PATH%&&"
else:
  if CYGWIN or WIN32:
    ENV = 'env PATH=bin:"$PATH" PYTHONPATH=.:"$PYTHONPATH" '
  elif MACOSX:
    ENV = 'PATH=bin:"$PATH" DYLD_LIBRARY_PATH=rtl:"$DYLD_LIBRARY_PATH" '
  else:
    ENV = 'PATH=bin:"$PATH" LD_LIBRARY_PATH=rtl:"$LD_LIBRARY_PATH" '

def exqt(x): xqt(ENV+x)

# used when a negative result is expected (return code is supposed to be nonzero)
# used for a grep which is supposed to fail
def nxqt(x):
  x = ENV+x
  if "quiet" not in options: print x
  flush()
  result,output = get_stdouterr(x)
  if not result:
    if output: print string.join(output,"")
  flush()

  if not result:
    raise MakeError

def flxg(x,basename):
  x = 'bin'+os.sep+'flxg ' + x
  exqt(x)

#interscript command (now built in part of Felix package)
def runISCR(a,force=0):
  if force:
    exqt(ISCR + "--nocache " + a)
  else:
    exqt(ISCR + '--break-on-error ' + a)


@select(tangler('mkplugins/help.py'))
# lame .. fix!
def plugin():
  print "extract - extract sources"
  print "compiler - build compiler"
  print "bytecode - build bytecode version of compiler"
  print "profile - build profiling version of compiler"
  print "drivers - build drivers"
  print "regression - run regression tests"
  print "performance - run performance tests"
  print "bagley - run bagley shootout performance tests"
  print "tutorial - run tutorial examples"
  print "tests- regression and tutorial combined"
  print "clean - remove generated C++ and binaries from test locations"
  print "debug - build debugging versions of targets"
  print "optimise_c - build high performance versions of c++ targets"
  print "optimise_felix - build high performance versions of ocaml targets NOT RECOMMENDED!"
  print "doc - build all user documentation"

@select(tangler('mkplugins/grammar.py'))
def plugin():
  os.system("env PYTHONPATH=. python script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar")
  os.system('env PYTHONPATH=. python script/flx_flx_grgen misc/flx_parse.grammar >lib/flx_grammar.flx')
  os.system('env PYTHONPATH=. python script/elk_flx_lexgen misc/flx_parse.grammar >misc/elk_flx_lex.cc')
  os.system('env PYTHONPATH=. python script/flx_tokgen misc/flx_parse.grammar >lib/flx_token.flx')

@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
@tangle("FLX_MAKER_CVS_ID='"+FLX_MAKER_CVS_ID+"'")
import os
import os.path
import glob
import stat
import string
import sys
import re
import traceback
this = globals()

if '' not in sys.path: sys.path=['']+sys.path
import flxbuild
from flxbuild.flxutil import *

try:
  execfile("config"+os.sep+"config.py")
except:
  xt,xv,tb = sys.exc_info()
  print "ERROR IN config/config.py"
  traceback.print_exception(xt,xv,tb)
  print "You must either"
  print "(a) edit config/config.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

execfile("cpkgs"+os.sep+"interscript.py")
FLXFLAGS = ""

# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

phases = []
options = sys.argv[1:]
if not options: 
  options = ["extract","optimise_c"]
  phases = ["build","host","target","run"]

packages = []
models = []
for k in options:
  if '--phase' == k[:7]:  # Windows doesn't like = so allow any sep 
    phase = k[8:]
    if phase not in phases:
      phases.append(phase)
  if '--pkg' == k[:5]:  # Windows doesn't like = so allow any sep 
    packages.append(k[6:])
  if '--model' == k[:7]:  # Windows doesn't like = so allow any sep 
    model = k[8:]
    if model not in models:
      models.append(model)

if models:
  if model == build_model:
    if "build" not in phases: phases.append("build")

  if model == host_model:
    if "host" not in phases: phases.append("host")

  if model == target_model:
    if "target" not in phases: phases.append("target")

  if model == run_model:
    if "run" not in phases: phases.append("run")

if "extract" in options or "force_extract" in options: 
    if "build" not in phases: phases.append("build")

if "build" in options: 
    if "build" not in phases: phases.append("build")
    if "host" not in phases: phases.append("host")
    if "target" not in phases: phases.append("target")

if packages and not phases:
  phases = ["build","host","target"]

if "test" in options: 
    if "run" not in phases: phases.append("run")

if "silent" in options: 
  options.append("quiet")

if "demo" in options:
  if "run" not in phases: phases.append("run")

if options:
  print "OPTIONS: ", options

for k in options:
  if "--lparchive=" == k[:12]:
    FLX_LPARCHIVE=k[12:]

print "Using LP Archive from ",
if FLX_LPARCHIVE == os.curdir:
  print "Current Directory"
else:
  print FLX_LPARCHIVE

paks = glob.glob(FLX_LPARCHIVE+os.sep+"lpsrc"+os.sep+"*.pak")
execfile("mkplugins"+os.sep+"xqt.py")
if "extract" in options:
  print "OPTIMISED SOURCE EXTRACT (use force_extract to disable optimisation)"
  for p in paks:
    print "EXTRACTING",p,"from",FLX_LPARCHIVE
    runISCR(p)
  filecopy('doc'+os.sep+'interscript.css','speed'+os.sep+'interscript.css')

if "force_extract" in options:
  print "FORCE EXTRACTING SOURCES"
  for p in paks:
    print "EXTRACTING",p
    try: os.remove(p+".cache")
    except: pass
    runISCR(p)
  filecopy('doc'+os.sep+'interscript.css','speed'+os.sep+'interscript.css')

if "virgin" in options:
  execfile("mkplugins"+os.sep+"virgin.py")
  plugin()

plugins = {}
for f in glob.glob("mkplugins"+os.sep+"*.py"):
  dir,base=string.split(f,os.sep)
  base=string.split(base,'.')[0]
  try: del plugin
  except: pass
  try:
    execfile(f)
    if "plugin" in globals():
      plugins[base]=plugin
  except:
    print "Failed to install plugin",f
print "PLUGIN FEATURES",plugins.keys()

raw_pkgs = glob.glob("spkgs"+os.sep+"*.py")
unsorted_pkgs = []
for i in raw_pkgs:
  j = string.split(i,os.sep)[1][:-3]
  unsorted_pkgs.append(j)

pkgd = {}
for pkg in unsorted_pkgs:
  class X:
    execfile("spkgs"+os.sep+pkg+".py")
  d = {}
  for k in X.__dict__.keys():
    if k[0] != '_':
      v = X.__dict__[k]
      d[k]=v
  pkgd[pkg]=d

pkgs = []
def addpkg_nr(pkg):
  if pkg not in pkgs:
    pkgs.append(pkg)

def addpkg_r(pkg):
  if pkg not in pkgs:
    if pkg not in pkgd.keys():
      print "Unknown package",pkg
      print "Please extract!"
      sys.exit(1)
    else:
      reqs = pkgd[pkg].get('pkg_requires',[])
      for i in reqs:
        addpkg_r(i)
      addpkg_nr(pkg)

for pkg in unsorted_pkgs:
  addpkg_r(pkg)

if packages:
  pkgs = filter(lambda x: x in packages,pkgs)


print "AVAILABLE SOURCES",paks
print "SELECTED PACKAGES ARE ",pkgs
print "SELECTED PHASES ARE   ",phases
print "Build model  ",build_model
print "Host model   ",host_model
print "Target model ",target_model
print "Run model    ",run_model

EXTRA_LIBS = []
CFLAGS = ""
SFLAGS = ""
DFLAGS = ""

# C files that we need to compile, with options required to build them
COBJECTS = {
}
# *.so/.a libraries
CLIBRARIES = ['nums']

# *.cmxa or .cma libraries
# and some hackery so we can if the source doesn't need
# ocaml-fileutils we can still build if it isn't found
OCAML_INCLUDES = ""

# target executable programs to produce

if 0:
  s = ' -cclib "-Lsrc '
  for library in CLIBRARIES:
    s = s + ' -l'+library
  s = s + '"'
  LDFLAGS = s
  del s
else:
  LDFLAGS = ""

if 1:
  o = ''
  for object in COBJECTS.keys():
    o = o + ' src/' + object + '.o'
  OBJECT_FILES = o
  del o

SPECIAL_TESTS = [
  ('bin'+os.sep+'flx_run','test'+os.sep+'flx_run_lib1.flx',''),
  ('test'+os.sep+'flx_perf_drv1','test'+os.sep+'flx_perf_lib1.flx','1000'),
]

# -------------------------------------------------
# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------


# ----------- Here begins the actual build procedure ---------------------

buildall = "clean" in options or "force" in options
try:
  # STEP 0: run interscript
  # in order specified by user
  for k in options:
    if k in plugins:
      plugins[k]()

#---------- PACKAGE BUILDS ---------------------------------     
  for pkg in pkgs:
    pkgdict = pkgd[pkg]
    if "host" in phases:
      print
      print "***** MAKING PACKAGE "+pkg+" ************"
      if not "quiet" in options: print

      MLIS = pkgdict.get("caml_raw_interfaces",[])
      copy_mli2ml(MLIS)
      HPPS = pkgdict.get("rtl_interfaces",[])
      copy_hpp2rtl(HPPS)

      srcs = pkgdict.get("iscr_source",[])
      src = string.join(srcs,' ')
      if src:
        print "REExtracting",pkg,"from",src
        runISCR(FLX_LPARCHIVE+os.sep+src)

      build_ocamls()

      build_host_tools()

    if "target" in phases:
      if SUPPORT_DYNAMIC_LOADING:
        build_target_rtl_dynamic()

      if SUPPORT_STATIC_LINKAGE:
        build_target_rtl_static()
      
      if SUPPORT_DYNAMIC_LOADING:
        build_felix_dynamic_drivers()

      if SUPPORT_STATIC_LINKAGE:
        build_felix_static_drivers()

      build_target_cpp_tools()
      build_target_felix_tools()

      if "test" in options:
        run_host_tests()

    if "run" in phases:
      if "test" in options:
        run_unit_tests()

      if "demo" in options:
        run_demos()
   
  if os.name != 'nt': # requires posix
    if "test" in options or "tutorial" in options or "fcount" in options:
      tkind = "std"
      if "inline" in options: tkind="inline"
      elif "noinline" in options: tkind="noinline"
      stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "tut/examples/*.hpp"'
      run(stats)
      stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "test/*.hpp"'
      run(stats)
  
    if "pfcount" in options:
      stats = 'python script/pfcount.py misc/fcounts.stats'
      run(stats)

    if "pfcount_all" in options:
      stats = 'python script/pfcount.py misc/fcounts.stats all'
      run(stats)

  print "RUN COMPLETE"

except MakeError:
  print "Terminating due to MAKE error"
  sys.exit(1)
#except:
#  print "Terminating due to UNKNOWN error"
#  sys.exit(2)

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('CONFIG_ARGS=')
@tangle('PREFIX='+PREFIX)
@tangle('LIB_DIR=${PREFIX}/lib')
@tangle('SHLIB_DIR=${PREFIX}/'+SHLIB_DIR)
@tangle('SHINC_DIR=${PREFIX}/include')
@tangle('INSTALL_DIR=${PREFIX}/lib/felix')
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('BUILTIN_ISCR=python -O interscript/bin/iscr.py --nocache')
@tangle('')
@tangle('all: dummy')
@tangle('\tpython script/maker extract ')
@tangle('\tpython script/maker')
@tangle('\tpython script/maker test ')
@tangle('')
@tangle('profile: dummy')
@tangle('\tpython script/maker --pkg=flx_compiler profile')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\tpython script/maker --pkg=flx_compiler bytecode')
@tangle('')
@tangle('bytecode.profile: dummy')
@tangle('\tpython script/maker --pkg=flx_compiler bytecode profile')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\tpython script/maker --pkg=flx_compiler bytecode debug')
@tangle('')
@tangle('extract: dummy')
@tangle('\tpython script/maker extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\tpython script/maker extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\tpython script/maker tutorial')
@tangle('')
@tangle('grammar: dummy')
@tangle('\tenv PYTHONPATH=. python script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar')
@tangle('\tenv PYTHONPATH=. python script/get_grammar src/flx_cil_cparser.mly >misc/flx_cil_cparser.grammar')
#@tangle('\tenv PYTHONPATH=. python script/elk_flx_grgen misc/flx_parse.grammar >misc/elk_flx_gr.gr')
@tangle('\tenv PYTHONPATH=. python script/flx_flx_grgen misc/flx_parse.grammar >lib/flx_grammar.flx')
#@tangle('\tenv PYTHONPATH=. python script/elk_flx_lexgen misc/flx_parse.grammar >misc/elk_flx_lex.cc')
@tangle('\tenv PYTHONPATH=. python script/flx_tokgen misc/flx_parse.grammar >lib/flx_token.flx')
@tangle('')
@tangle('compiler: dummy')
@tangle('\tpython script/maker --pkg=flx_compiler')
@tangle('')
@tangle('flx_tools:')
@tangle('\tpython script/maker tools')
@tangle('')
@tangle('tools: flx_tools grammar tools/lua_parser')
@tangle('')
@tangle('#tools: grammar bin/flx_doc tools/lua_parser')
@tangle('')
@tangle('tools/lua_parser: tools/lua_parser.flx')
@tangle('\tbin/flx --test --static -c tools/lua_parser')
@tangle('')
@tangle('bin/flx_doc: tools/flx_doc.flx')
@tangle('\tbin/flx --test --static -c tools/flx_doc && mv tools/flx_doc bin/flx_doc')
@tangle('')
@tangle('doc: grammar tools man impldoc rtldoc tutdoc')
@tangle('')
@tangle('#doc: grammar tools libdoc man impldoc tutdoc tutstyle')
@tangle('')
@tangle('impldoc: dummy')
@tangle('\tpython script/maker doc impldoc')
@tangle('')
@tangle('rtldoc: dummy')
@tangle('\tpython script/maker rtldoc')
@tangle('')
@tangle('tutdoc: dummy')
@tangle('\tpython script/maker doc tutdoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('doc.quiet: grammar tools libdoc')
@tangle('\tpython script/maker quiet doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('libdoc: grammar tools')
@tangle('\tbin/flx_doc --outdir=libdoc \\')
@tangle('\tlib/std.flx lib/stl.flx lib/flx_lex.flx \\')
@tangle('\tlib/flx_token.flx lib/flx_grammar.flx lib/lua.flx lib/lua_parse.flx')
@tangle('\tcp misc/flxdoc_style.css libdoc')
@tangle('')
@tangle('man: dummy')
@tangle('\tpython script/maker man')
@tangle('')
@tangle('test: dummy')
@tangle('\tpython script/maker test ')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('test.flx_ptf_static_pointer: dummy')
@tangle('\tpython script/maker test -DFLX_PTF_STATIC_POINTER ')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\tpython script/maker inline test ')
@tangle('')
@tangle('test.inline.static: dummy')
@tangle('\tpython script/maker inline test static ')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\tpython script/maker debug test ')
@tangle('')
@tangle('test.lua_parser: dummy')
@tangle('\tfor i in misc/lua/*.lua; do tools/lua_parser $$i; done;')
@tangle('')
@tangle('tests: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('\tmake tests.bagley')
@tangle('\tmake test.lua_parser')
@tangle('')
@tangle('tests.sdl: dummy')
@tangle('\tpython script/maker sdl')
@tangle('\tpython script/maker static sdl')
@tangle('')
@tangle('tests.verify: dummy')
@tangle('\tpython script/maker test check_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\tpython script/maker test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\tpython script/maker inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\tpython script/maker performance')
@tangle('')
@tangle('performance: tests.performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\tpython script/maker regression')
@tangle('')
@tangle('tests.bagley: dummy')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('speed: dummy')
@tangle('\tpython script/maker speed')
@tangle('')
@tangle('pfcount.all:')
@tangle('\tpython script/maker pfcount_all')
@tangle('')
@tangle('pfcount:')
@tangle('\tpython script/maker pfcount')
@tangle('')
@tangle('rtl.debug: dummy')
@tangle('\tpython script/maker rtl debug')
@tangle('')
@tangle('rtl: dummy')
@tangle('\tpython script/maker rtl')
@tangle('')
@tangle('rtl.optimise: dummy')
@tangle('\tpython script/maker rtl optimise_c')
@tangle('')
@tangle('elkhound: dummy')
@tangle('\tpython script/maker elkhound')
@tangle('')
@tangle('expect.bagley: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tenv PYTHONPATH=. python script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('expect: clean')
@tangle('\tpython script/maker bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tpython script/maker test log_output')
@tangle('\tenv PYTHONPATH=. python script/mk_expect tut/examples > lpsrc/flx_tut_expect.ipk')
@tangle('\tenv PYTHONPATH=. python script/mk_expect test > lpsrc/flx_test_expect.ipk')
@tangle('\tenv PYTHONPATH=. python script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('drivers: dummy')
@tangle('\tpython script/maker drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('\tpython script/maker drivers debug')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.08.1 or better')
@tangle('\t#REQUIRES g++ 3.xx or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required priviledges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')

@tangle('src_tarball: extract ')
@tangle('\trm -f felix-'+flx_version)
@tangle('\tln -s . felix-'+flx_version)
@tangle('\ttar -cvf flx_'+flx_version+'_src.tar\\')
@tangle('\t\tfelix-'+flx_version+'/configure \\')
@tangle('\t\tfelix-'+flx_version+'/*.bat \\')
@tangle('\t\tfelix-'+flx_version+'/Makefile \\')
@tangle('\t\tfelix-'+flx_version+'/README \\')
@tangle('\t\tfelix-'+flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+flx_version+'/COPYING \\')
@tangle('\t\tfelix-'+flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/weavers/*.py ')
@# debian requires gzip -9
@tangle('\tgzip -9 flx_'+flx_version+'_src.tar')
@tangle('\tmv -f flx_'+flx_version+'_src.tar.gz flx_'+flx_version+'_src.tgz')
@tangle('')
@tangle('media_tarball:')
@tangle('\trm -f flx_media.tgz')
@tangle('\ttar -zcvf flx_media.tgz media')
@tangle('')
@tangle('bin_tarball:')
@tangle('\trm -f felix-'+flx_version)
@tangle('\tln -s . felix-'+flx_version)
@tangle('\ttar -zcvf flx_'+flx_version+'_share.tgz\\')
@tangle('\t\tfelix-'+flx_version+'/configure\\')
@tangle('\t\tfelix-'+flx_version+'/Makefile\\')
@tangle('\t\tfelix-'+flx_version+'/README \\')
@tangle('\t\tfelix-'+flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+flx_version+'/COPYING\\')
@tangle('\t\tfelix-'+flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+flx_version+'/media/images/* \\')
@tangle('\t\tfelix-'+flx_version+'/script/maker \\')
@tangle('\t\tfelix-'+flx_version+'/script/*\\')
@tangle('\t\tfelix-'+flx_version+'/src/*.ml \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mli \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mly \\')
@tangle('\t\tfelix-'+flx_version+'/src/*.mll \\')
@tangle('\t\tfelix-'+flx_version+'/tools/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/rtl/*.cpp\\')
@tangle('\t\tfelix-'+flx_version+'/rtl/*.hpp\\')
@tangle('\t\tfelix-'+flx_version+'/doxydoc/html/*\\')
@#tangle('\t\tfelix-'+flx_version+'/libdoc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/lib/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.cpp \\')
@tangle('\t\tfelix-'+flx_version+'/test/*.expect \\')
@tangle('\t\tfelix-'+flx_version+'/tut/examples/*.flx \\')
@tangle('\t\tfelix-'+flx_version+'/tut/examples/*.expect \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/tut/doc/*.tex \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/doc/*.tex \\')
@tangle('\t\tfelix-'+flx_version+'/licences/*.txt \\')
@tangle('\t\tfelix-'+flx_version+'/misc/* \\')
@tangle('\t\tfelix-'+flx_version+'/htmlman/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/man/man1/*.1 \\')
@tangle('\t\tfelix-'+flx_version+'/impldoc/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/www/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/bin/flx \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.html \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.css \\')
@tangle('\t\tfelix-'+flx_version+'/speed/*.gpl \\')
@tangle('\t\tfelix-'+flx_version+'/speed/images/rosella/*.jpg \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/weavers/*.py \\')
@tangle('')
@tangle('tarball: src_tarball bin_tarball media_tarball')
@tangle('')
@tangle('flx_media.tgz: media_tarball')
@tangle('')
@tangle('debian/rules: lpsrc/flx_debian.pak lpsrc/flx_maker.ipk')
@tangle('\trm -rf debian')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_debian.pak')
@tangle('\tchmod u+x debian/rules')
@tangle('')
@tangle('debian-package: debian/rules')
@tangle('\t(cd .. && make -f flx/Makefile.debian_package_creator package)')
@tangle('')
@tangle('www: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_sourceforge.pak')
@tangle('')
@tangle('clean: dummy')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\tpython script/maker clean')
@tangle('')
@tangle('distclean:')
@tangle('\trm -rf pkg tut rtl test www src misc man bin doc lib impldoc htmlman tmp tmp.tmp')
@tangle('\trm -rf elk tmp faio demux tmp.out')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('\trm -rf bagley')
@tangle('\trm -rf doc_out libdoc tools')
@tangle('\trm -rf meta licences')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -rf interscript/*/*.pyo')
@tangle('\trm -rf interscript/*/*/*.pyo')
@tangle('\trm -rf speed')
@tangle('\trm -rf cpkgs')
@tangle('\trm -rf spkgs')
@tangle('\trm -rf pthread')
@tangle('\trm -rf flxbuild')
@tangle('\trm -rf mkplugins')
@tangle('\trm -rf olddebian')
@tangle('\trm -rf script')
@tangle('')
@tangle('virgin: distclean')
@tangle('\tcp Makefile Makefile.old')
@tangle('\trm -rf debian/')
@tangle('\trm -f README LICENCE VERSION CONTENTS INSTALL AUTHORS NEWS COPYING ChangeLog')
@tangle('')

@tangle('backup: dummy')
@tangle('\t(DATE=`date +"%Y-%m-%d-%H%M"`;\\')
@tangle('\tmkdir -p "lpbackup/$${DATE}";\\')
@tangle('\tfind lpsrc -name "*.ipk" -exec cp "{}" "lpbackup/$${DATE}" ";";\\')
@tangle('\tfind lpsrc -name "*.pak" -exec cp "{}" "lpbackup/$${DATE}" ";";\\')
@tangle('\tfind homepage -name "*.html" -exec cp "{}" "lpbackup/$${DATE}" ";"\\')
@tangle('\t)')
@tangle('')

@tangle('config: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_config.pak')
@tangle('\tenv PYTHONPATH=. python -O script/make_config.py --quiet --prefix=${PREFIX} ${CONFIG_ARGS}')
@tangle('')
@tangle('config/config.py: config')
@tangle('')
@tangle('boot: config/config.py')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_maker.pak')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tfor i in tmp/*.default; do cp $$i config/`basename $$i .default`; done')
@tangle('')
@tangle('wrappers.clean:')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('')
@tangle('config/cxx.flxcc: default_wrappers')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/c89.flxcc')
@tangle('\tbin/flxcc config/c99.flxcc')
@tangle('\tbin/flxcc config/gnu89.flxcc')
@tangle('\tbin/flxcc config/gnu99.flxcc')
@tangle('\tbin/flxcc config/cxx.flxcc')
@tangle('\tbin/flxcc config/cxx_sys.flxcc')
@tangle('\tbin/flxcc config/gnucxx.flxcc')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\t#"INSTALL_DIR=${INSTALL_DIR}"')
@tangle('\t#"EXEC_DIR=${EXEC_DIR}"')
@tangle('\t#"MAN_DIR=${MAN_DIR}"')
@tangle('\t#"SHLIB_DIR=${SHLIB_DIR}"')
@tangle('\t#"LIB_DIR=${LIB_DIR}"')
@tangle('\t#"SHINC_DIR=${SHINC_DIR}"')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${SHLIB_DIR}')
@tangle('\tinstall -d ${LIB_DIR}')
@tangle('\tinstall -d ${SHINC_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/config')
@tangle('\tinstall -d ${INSTALL_DIR}/doc')
@tangle('\tinstall -d ${INSTALL_DIR}/htmlman')
@tangle('\tinstall config/*.py ${INSTALL_DIR}/config')
@tangle('\tinstall config/*.flxcc ${INSTALL_DIR}/config')
@tangle('\tinstall lib/* ${INSTALL_DIR}/lib')
@tangle('\tinstall rtl/*.hpp ${SHINC_DIR}')
@tangle('\tinstall rtl/* ${INSTALL_DIR}/rtl')
@if SUPPORT_STATIC_LINKAGE:
  tangle('\t'+RANLIB+' ${INSTALL_DIR}/rtl/libflx_static.a')
  tangle('\tinstall rtl/libflx_static.a ${LIB_DIR}')
  tangle('\t'+RANLIB+' ${LIB_DIR}/libflx_static.a')
@if SUPPORT_DYNAMIC_LOADING:
  if CYGWIN:
    # static link thunk for bin/cygflx_dynamic.dll
    #tangle('\tinstall rtl/libflx_dynamic.dll.a ${SHLIB_DIR}')
    # not used now, dll goes in 'bin'
    pass
  elif MACOSX:
    tangle('\tinstall rtl/libflx_dynamic.dylib ${SHLIB_DIR}')
  else:
    tangle('\tinstall rtl/libflx_dynamic.so ${SHLIB_DIR}')
@tangle('\t(install doc/* ${INSTALL_DIR}/doc || exit 0) > /dev/null 2>&1')
@tangle('\t(install impldoc/* ${INSTALL_DIR}/impldoc || exit 0) > /dev/null 2>&1')
@tangle('\t(install htmlman/* ${INSTALL_DIR}/htmlman || exit 0) > /dev/null 2>&1')
@tangle('\tinstall bin/* ${EXEC_DIR}')
@tangle('\t(install man/man1/* ${MAN_DIR}/man1 || exit 0) > /dev/null 2>&1')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = string.replace(FLX_MAKER_CVS_ID,"$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle('.PHONY: dummy')
@tangle('')
@tangle("# These targets are for SKALLER only")
@tangle("# they're used to upload stuff to sourceforge")
@tangle('upload_images:')
@tangle('\tscp homepage/images/*.jpg skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/images')
@tangle('')
@tangle('upload_homepage: dummy')
@tangle('\tscp homepage/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('upload_www: upload_homepage')
@tangle('\tscp www/*.html skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/current/www')
@tangle('')
@tangle('upload_src: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('upload_speed: dummy')
@tangle('\tscp -r speed/*.html speed/images skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs/current/speed')
@tangle('')
@tangle('upload_media: flx_media.tgz')
@tangle('\tscp flx_media.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle('upload: dummy')
@tangle('\tscp flx_'+flx_version+'_src.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('\tscp flx_'+flx_version+'_share.tgz skaller@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues Cass

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors. The C parser is derived from
FrontC/CIL which is has BSD licence.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something .. 

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something .. 


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENCE   licence details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary
 
  Makefile   the makefile, mainly hooks into script/maker
 
  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  meta   -- contains various package manager meta-data files
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENCE')
@select(tangler('LICENCE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file 


lpsrc/flx_frontc.ipk
lpsrc/flx_cil.ipk

are covered by a BSD Licence, here is the copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.08.1 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace
   
@tangle('   tar -zxvf flx_'+flx_version+'_src.tgz')
@tangle('   cd felix_'+flx_version)

4. Bootstrap the system.

  ./configure

OR type

   make config
   make boot
   make extract

EDIT THE FILES

  config/*.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make 

6. Build the documentation and tutorial

   make doc 

7. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak 
  
                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  include "std";
  print "It works!"; endl;

and then run it:
  
  flx -Ilib mytest

@head(1,'.cvsignore')
This is actually put in the lpsrc directory to tell
cvs to ignore certain files.
@select(tangler('lpsrc/.cvsignore','data'))
*.cache
*.swp


@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.

@select(tangler('doc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('doc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)


@head(1,"fishcc")
Script to compile a C program generated by FISh.
@select(tangler("bin/fishcc"))
grab=1
CCFLAGS=""
while (( "$grab" == "1" ));
do
  case x$1 in
  x-*)
    CCFLAGS="$CCFLAGS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done
@tangle('cmd="'+CCLINK_STATIC+' $1 -O -o `basename $1 .c` `echo "$CCFLAGS"` -lflx_static"')
echo $cmd
`$cmd`

@head(1,'Run script')
@select(tangler('bin/flx.bat','data'))
@@echo off
SETLOCAL
SET RUNIT=1
SET DOFLXG=1
SET DOECHO=0
SET FID=%FLX_INSTALL_DIR%
SET STATIC=0

:DOARGS
IF "-c" EQU "%1" (
SET RUNIT=0
SHIFT
GOTO DOARGS
)

IF "--nofelix" EQU "%1" (
SET DOFLXG=0
SHIFT
GOTO DOARGS
)

IF "--echo" EQU "%1" (
echo on
SET DOECHO=1
SHIFT
GOTO DOARGS
)

IF "--test" EQU "%1" (
SET FID=.
SHIFT
GOTO DOARGS
)

IF "--static" EQU "%1" (
SET STATIC=1
SHIFT
GOTO DOARGS
)

"%FID%\BIN\FLXG" -I"%FID%\LIB" %1 >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
if %STATIC% EQU 0 (
cl /nologo /MD /c /EHs /w  /I"%FID%\RTL" %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MT /LD %1.obj /Fe%1.dll /link /LIBPATH:"%FID%\BIN" /DEFAULTLIB:libflx_dynamic >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1.exp
del %1.lib
IF %RUNIT% EQU 1 (
"%FID%\bin\flx_run" %1 %2 %3 %4 %5 %6 %7 %8 %9  
)
) else (
cl /nologo /MT /c /EHs /w  /I"%FID%\RTL" /DFLX_STATIC_LINK %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MT "%FID%\rtl\flx_run_static.obj" %1.obj /Fe%1.exe /link /LIBPATH:"%FID%\RTL" /DEFAULTLIB:libflx_static >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%1 %2 %3 %4 %5 %6 %7 %8 %9
)
GOTO FINISHED
:ERROR
ECHO SOME KIND OF ERROR OCCURED, rerun with --echo
type %1.LOG
EXIT /B 1
:FINISHED
ENDLOCAL

@select(tangler('bin/flx','data'))
#!/usr/bin/env bash
# flx - felix script harness

@tangle("CYGWIN="+str(CYGWIN))
@tangle("WIN32="+str(WIN32))
@tangle("MACOSX="+str(MACOSX))
@tangle("HAVE_GXX="+str(HAVE_GXX))
@tangle("HAVE_MSVC="+str(HAVE_MSVC))
@tangle('CCOBJ_DLLIB="'+CCOBJ_DYNAMIC_FLX+'"')
@tangle('CCLINK_DLLIB="'+CCLINK_DYNAMIC_FLX+'"')
@tangle('CCOBJ_STATIC_LIB="'+CCOBJ_STATIC_FLX+'"')
@tangle('CCLINK_STATIC="'+CCLINK_STATIC+'"')
@tangle('VERSION="'+flx_version+'"')
@tangle('EXT_LIB="'+EXT_LIB+'"')
@tangle('EXT_OBJ="'+EXT_OBJ+'"')
@tangle('EXT_EXE="'+EXT_EXE+'"')
@tangle('EXT_SHLIB="'+EXT_SHLIB+'"')
@tangle('SPEC_OBJ_FILENAME="'+SPEC_OBJ_FILENAME+'"')
@tangle('SPEC_EXE_FILENAME="'+SPEC_EXE_FILENAME+'"')
@tangle('OPTIMISE="'+OPTIMISE+'"')
@tangle('DEBUG_FLAGS="'+DEBUG_FLAGS+'"')
@if HAVE_MSVC:
  tangle("DLINK_STRING='/link /LIBPATH:bin /DEFAULTLIB:libfaio_static /DEFAULTLIB:libdemux_dynamic /DEFAULTLIB:libflx_dynamic '")
  tangle("SLINK_STRING='/link /LIBPATH:bin /DEFAULTLIB:libfaio_static /DEFAULTLIB:libdemux_static /DEFAULTLIB:libflx_static '")
 elif CYGWIN or WIN32:
  tangle("DLINK_STRING='-Lbin -lfaio_dynamic -ldemux_dynamic -lflx_dynamic'")
  tangle("SLINK_STRING='-Lbin -lfaio_static -ldemux_static -lflx_static'")
 else:
  tangle("DLINK_STRING='-Lrtl -lfaio_dynamic -ldemux_dynamic -lflx_dynamic'")
  tangle("SLINK_STRING='-Lrtl -lfaio_static -ldemux_static -lflx_static'")

@if PTHREAD_SWITCH != None:
  tangle('PTHREAD_SWITCH="'+PTHREAD_SWITCH+'"')
 else:
  tangle('PTHREAD_SWITCH=""')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=10
ECHO=0
TIME=0
@if DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""
FELIX=1
LINNKER_SWITCHES=""
MACROS=""
grab=1

INCLUDE_DIRS=""

while (( "$grab" == "1" ));
do
  case x$1 in
  x--test=*)
    TESTMODE=1
    FLX_INSTALL_DIR=${1:7}
    shift
  ;;

  x--test)
    TESTMODE=1
    FLX_INSTALL_DIR=.
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    ECHO=1
    shift
  ;;

  x--time)
    TIME=1
    shift
  ;;

  x--echo)
    ECHO=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline=*)
    INLINE=${1:9}
    shift
  ;;

  x--inline)
    INLINE=50
    shift
  ;;

  x--noinline)
    INLINE=0
    shift
  ;;

  x--opt=1)
    INLINE=10
    CCFLAGS="-O1 $CCFLAGS"
    shift
  ;;

  x--opt=2)
    INLINE=20
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--opt=3)
    INLINE=50
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--optimise)
    INLINE=10
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--optimize)
    INLINE=10
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--help)
    man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x--nofelix)
    FELIX=0
    shift
  ;;

  x-[lL]*)
   LINKER_SWITCHES="$LINKER_SWITCHES $1"
   shift
  ;;

  x-D*)
   MACROS="$MACROS $1"
   shift
  ;;

  x*)
    grab=0
  ;;

  esac
done

if [ "$TESTMODE" = "1" -a "$ECHO" = "1" ]
then
  echo "TESTMODE: running felix from $FLX_INSTALL_DIR"
fi

if [ "$TESTMODE" = "1" ]
then
PKGCONFIG_CFLAGS="bin/flx_pkgconfig --path+=config --field=cflags "
PKGCONFIG_DLIBS="bin/flx_pkgconfig  --path+=config --field=provides_dlib --field=requires_dlibs "
PKGCONFIG_SLIBS="bin/flx_pkgconfig -r --keeprightmost --path+=config --field=provides_slib --field=requires_slibs "
PKGCONFIG_DRIVER="bin/flx_pkgconfig --path+=config --field=flx_requires_driver "
elif [ "x$FLX_INSTALL_DIR" != "x" ]
then
PKGCONFIG_CFLAGS="$FLX_INSTALL_DIR/bin/flx_pkgconfig --path+=$FLX_INSTALL_DIR --field=cflags "
PKGCONFIG_DLIBS="$FLX_INSTALL_DIR/bin/flx_pkgconfig -path+=$FLX_INSTALL_DIR --field=provides_dlib --field=requires_dlibs "
PKGCONFIG_SLIBS="$FLX_INSTALL_DIR/bin/flx_pkgconfig -r --keeprightmost --path+=FLX_INSTALL_DIR --field=field-provides_slib --requires_slibs "
PKGCONFIG_DRIVER="$FLX_INSTALL_DIR/bin/flx_pkgconfig --path+=FLX_INSTALL_DIR --field=flx_requires_driver "
else
PKGCONFIG_CFLAGS="flx_pkgconfig --field=cflags "
PKGCONFIG_DLIBS="flx_pkgconfig --field=provides_dlib --field=requires_dlibs "
PKGCONFIG_SLIBS="flx_pkgconfig -r --keeprightmost --field=provides_slib --requires_slibs "
PKGCONFIG_DRIVER="flx_pkgconfig --field=flx_requires_driver "
fi

# make a list of any *.cpp files (or other g++ options ..)

cpps=""
cppos=""
grab=1
kgs=""
while (( "$grab" == "1" ));
do
  case "$1" in
    *.cpp)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .cpp`$EXT_OBJ"
      shift
    ;;

    *.cxx)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .cxx`$EXT_OBJ"
      shift
    ;;

    *.c)
      cpps="$cpps $1"
      cppos="$cppos `dirname $1`/`basename $1 .c`$EXT_OBJ"
      shift
    ;;

    *.o)
      cppos="$cppos `dirname $1`/`basename $1 .o`$EXT_OBJ"
      shift
    ;;

    *.obj)
      cppos="$cppos `dirname $1`/`basename $1 .obj`$EXT_OBJ"
      shift
    ;;

    *.a)
      cppos="$cppos $1"
      shift
    ;;

    *.lib)
      cppos="$cppos $1"
      shift
    ;;

    --pkg=*)
      pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
      shift
    ;;

# unknown flag .. pass to both compile and link
    -*)
      cpps="$cpps $1"
      cppos="$cppos $1"
      shift
    ;;

    *)
      grab=0
    ;;
  esac
done

if [ "x$1" = "x" ]
then
  echo "usage: flx filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;

  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=$arg

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

function calpackages () {
  if [ -a "$base.resh" ]
  then
    INCLUDE_DIRS="$INCLUDE_DIRS `$PKGCONFIG_CFLAGS @$base.resh`"

    DRIVER=$($(echo $PKGCONFIG_DRIVER @$base.resh))
    if [ "x" = "x$DRIVER" ]
      then
        DRIVER=flx_run
    fi

    # no idea how to check for an error!!
    if [ $STATIC = 0 ]
    then 
      LINKER_SWITCHES="$LINKER_SWITCHES $($(echo $PKGCONFIG_DLIBS $DRIVER @$base.resh))"
    else
      LINKER_SWITCHES="$LINKER_SWITCHES $($(echo $PKGCONFIG_SLIBS $DRIVER @$base.resh))"
    fi
  else
    DRIVER=flx_run
    if [ $STATIC = 0 ]
    then 
      LINKER_SWITCHES="$LINKER_SWITCHES $($(echo $PKGCONFIG_DLIBS $DRIVER))"
    else
      LINKER_SWITCHES="$LINKER_SWITCHES $($(echo $PKGCONFIG_SLIBS $DRIVER))"
    fi
  fi

  # NOTE: TRICK TO STRIP WHITESPACE that flx_pkgconfig might
  # IS THAT A BUG? Yes, now fixed in flx_pkgconfig
  # DRIVER=`echo $DRIVER`
}

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

if [ "x$FLX_INSTALL_DIR" != "x" ]
then
  INCLUDE_DIR="$FLX_INSTALL_DIR/rtl"
  FLXLIB="$FLX_INSTALL_DIR/lib"
  if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
  then
    # bash is a heap of crap! The escaped quotes here are
    # required in case the PATH has a filename with spaces
    # However this actually fails on Linux!
    FLXG="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" $FLX_INSTALL_DIR/bin/flxg"
    FLXRUN="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" $FLX_INSTALL_DIR/bin/"
  else
    FLXG="env PATH=$FLX_INSTALL_DIR/bin:\$PATH $FLX_INSTALL_DIR/bin/flxg"
    # the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
    if [ "$MACOSX" = "1" ]
    then
      FLXRUN="env DYLD_LIBRARY_PATH=$FLX_INSTALL_DIR/rtl:\$DYLD_LIBRARY_PATH $FLX_INSTALL_DIR/bin/"
    else
      FLXRUN="env LD_LIBRARY_PATH=$FLX_INSTALL_DIR/rtl:\$LD_LIBRARY_PATH $FLX_INSTALL_DIR/bin/"
    fi
  fi
  FLXRTL="$FLX_INSTALL_DIR/rtl"
  FLXBIN="$FLX_INSTALL_DIR/bin"
  FLXAR="$FLX_INSTALL_DIR/rtl"
  if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
  then
    FLXSHLIB="$FLX_INSTALL_DIR/bin"
  else
    FLXSHLIB="$FLX_INSTALL_DIR/rtl"
  fi
  ELKHOUND="--elkhound=$FLX_INSTALL_DIR/bin/flx_elkhound"
else
  # Locate the felix installation
  prefix=""
  for dir in `echo "$PATH" | sed 's/:/ /g'`
  do
    dir=$dir
    if [ -x "$dir/flxg" ]
    then
      prefix="$dir/flxg"
      break
    fi
  done
  prefix="`echo $prefix | sed 's/\/bin\/flxg$//'`"
  if [ x$prefix = x ]
  then
    echo "Cannot find felix in PATH, use --test=root to set it"
    exit 1
  else
    INCLUDE_DIR="$prefix/lib/felix/rtl"
    FLXG="$prefix/bin/flxg"
    FLXRUN="$prefix/bin/"
    FLXLIB="$prefix/lib/felix/lib"
    FLXRTL="$prefix/rtl/felix/lib"
    FLXBIN="$prefix/bin"
    FLXAR="$prefix/lib"
    if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
    then
      FLXSHLIB="$prefix/bin"
    else
      FLXSHLIB="$prefix/lib"
    fi
    ELKHOUND="--elkhound=$prefix/bin/flx_elkhound"
  fi
fi
DEBUGSWITCH=""
if [ "$DEBUG" = "1" ]; then DEBUGSWITCH=" --debug"; fi
STATIC_ENV=""
if [ "$DEBUG" = "1" ]; then STATIC_ENV="env FLX_DEBUG=1 "; fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base$EXT_SHLIB" -a "(" ! -r "$base.flx" -o "$base$EXT_SHLIB" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      calpackages
      cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
    fi
    exit $?
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base$EXT_EXE" -a "(" ! -r "$base.flx" -o "$base$EXT_EXE" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      cmd="$STATIC_ENV $base $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
    fi
    exit $?
  fi
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]
then
  VERBOSE="-v"
  CCFLAGS="$CCFLAGS$DEBUG_FLAGS"
else
  VERBOSE="-q"
fi

FLXFLAGS="--inline=$INLINE"

if [ $STATIC = 0 ]
then
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND -I$FLXLIB $INCLUDE_DIRS $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    calpackages
    CCMD="$CCOBJ_DLLIB $CCFLAGS -I$INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_DLLIB $CCFLAGS $cppos $base$EXT_OBJ $SPEC_EXE_FILENAME$base$EXT_SHLIB $DLINK_STRING $PTHREAD_SWITCH $LINKER_SWITCHES"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
          else
            cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
          fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
        exit $?
      else
        exit $?
      fi
    else
      exit $?
    fi
  fi
else
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND -I$FLXLIB $INCLUDE_DIRS $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    calpackages
    CCMD="$CCOBJ_STATIC_LIB $CCFLAGS -DFLX_STATIC_LINK -I$INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_STATIC $base$EXT_OBJ $FLXRTL/${DRIVER}_static$EXT_OBJ $cppos $SLINK_STRING $SPEC_EXE_FILENAME$base$EXT_EXE $PTHREAD_SWITCH $LINKER_SWITCHES"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        # rm -f "$base.cpp"
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $STATIC_ENV $base $args"
          else
            cmd="$STATIC_ENV $base $args"
          fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
        exit $?
      else
        exit $?
      fi
    else
      exit $?
    fi
  fi
fi

@head(1,'Package Manager Meta Info')
@head(2,'GODI')
This is the Godiva file originally used to
create the GODI data. At the moment this is
the authoritative meta data. However,
godiva may not handle all the options
we need -- so the generated makefile
is included as well.

@select(tangler('meta/godiva/flx.godiva','data'))
Package: apps-felix
@tangle('Version: '+flx_version)
Revision: 0
Depends:
Build-Depends: godi-ocaml (> 3.08) 
@tangle('Sources: http://felix.sf.net/flx_'+flx_version+'_src.tgz')
@tangle('Unpacks-To: flx_'+flx_version)
Bytecode-Target: all
Opt-Target: all
Homepage: http://felix.sf.net
Maintainer: John Skaller <skaller@users.sf.net>
Options: configure
Description: Felix Compiler
Felix Compiler
.

@select(tangler('meta/godiva/flx.godiva_camlsyntax','data'))
name = "felix";
@tangle('version = "'+flx_version+'";')
revision = 0;
category = `apps;
depends = [];
build_depends = [`godi,"ocaml", Some (`gt, "3.08")];
sources_site ="http://felix.sf.net/";
@tangle('sources_basename= "flx_'+flx_version+'_src";')
sources_extension = ".tgz";
@tangle('sources_unpacksto = "flx_'+flx_version+'";')
all_target= "all";
opt_target= "all";
homepage= "http://felix.sf.net";
maintainer = "John Skaller <skaller@users.sf.net>";
options= [`configure];
short_desc = "Felix Compiler";
long_desc = "Felix Compiler";
confopts = [
  { 
    name = "SUPPORT_DYNAMIC_LOADING";
    default = "1";
    description = "Whether to support dlopen loading";
    implementation = `configarg "--SUPPORT_DYNAMIC_LOADING"
  }
];
specfile = "meta/godiva/flx.godiva_camlsyntax";
patches = [];
filesdir = None;

@select(tangler('meta/godi/DESCR','data'))
Felix Compiler and tools.

@doc()
This makefile only here for reference (don't use it,
it should be generated).

@select(tangler('meta/godi/Makefile','data'))
# This file was automatically generated by GODIVA
.include "../../mk/bsd.prefs.mk"
.include "../../mk/godi.pkg.mk"

@tangle('VERSION=        '+flx_version)
PKGNAME=        apps-felix-${VERSION}
@tangle('PKGREVISION=    '+godi_revision) 
@tangle('DISTNAME=       flx_'+flx_version)
@tangle('DISTFILES=      flx_'+flx_version+'_src.tgz')
CATEGORIES=     apps
MASTER_SITES=   http://felix.sf.net/
MAINTAINER=     John Skaller <skaller@users.sf.net>
HOMEPAGE=       http://felix.sf.net
COMMENT=        Felix Compiler

# confopt defaults:


AUTOGENERATE_PLIST = yes
PKG  =          apps-felix
MAKE_FLAGS=     PREFIX=${PREFIX}  



PATH:=          ${LOCALBASE}/bin:"${PATH}"
HAS_CONFIGURE = yes
CONFIGURE_ARGS+= --prefix ${PREFIX}
CONFIGURE_ENV+= ${BUILD_OCAMLFIND_ENV}
USE_GMAKE = yes

MAKE_ENV+=  ${BUILD_OCAMLFIND_ENV} PKGBASE=${PKGBASE:Q}

pre-configure-copy:
.	if exists(files)
	    cd files && ${PAX} -rw -pp . ${WRKSRC}
.	endif

pre-configure: pre-configure-copy

pre-install-mkdirs:
.	for d in bin lib/ocaml/pkg-lib doc share man etc info sbin include
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/${d}
.	endfor
.	for n in 1 2 3 4 5 6 7 8 9
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/man/man${n}
.	endfor

pre-install: pre-install-mkdirs

ALL_TARGET=     all
.if ${GODI_HAVE_OCAMLOPT} == "yes"
# ALL_TARGET+= all
.endif

post-install:
	mkdir -p ${PREFIX}/doc/${PKG}
.	for DOC in 
	    install -m 0644 ${WRKSRC}/${DOC} ${PREFIX}/doc/${PKG}
.	endfor

.include "../../mk/bsd.pkg.mk"

@head(1,'Finish up')
Just cleaning up script now.
@try:
   os.system('chmod u+x configure')
   os.system('chmod u+x bin/flx')
   os.system('chmod u+x bin/fishcc')
 except:pass

