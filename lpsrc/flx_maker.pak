@import config

@head(1,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID

@def make_executable(path):
   import stat
   try:
     mode = os.stat(path).st_mode
     os.chmod(path, mode | stat.S_IXUSR)
   except OSError, e:
     print e

@h = tangler('script/bin2hex.py')
@select(h)
# convert a binary file to hex
import sys
fn = sys.argv[1]
f = open(fn)
data = f.read()
f.close()
counter = 0
for ch in data:
  print ("%02x" % ord(ch)),
  counter = counter + 1
  if counter == 8:
    print
    counter = 0
print

@select(tangler('script/fcount.py','python'))
import glob
import os
import sys
if '' not in sys.path: sys.path = ['']+sys.path
from fbuild.flxbuild.flxutil import xqt

try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

try:
  key = sys.argv[2]
except:
  key = "std"

try:
  globspec = sys.argv[3]
except:
  globspec = "tut/examples/*.hpp"

print "function counter: STATS FILE",filename, "KEY", key, "GLOB",globspec
dict = {}
try:
  execfile (filename)
except:pass

files = glob.glob(globspec)

for file in files:
  cmd = 'egrep "//PROC|//FUNCTION" ' + file + ' | wc -l'
  output = xqt(cmd)[0][:-1]
  x = int(output)
  try:
    d= dict[file]
  except:
    dict[file]={}
    d = dict[file]
  d[key]=x

f = open(filename,"w")
f.write("dict="+repr(dict))
f.close()

@h = tangler('script/pfcount.py','python')
@select(h)
import glob
import os
import sys
try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

only_nonopt = 0
try:
  x = sys.argv[2]
except:
  only_nonopt = 1

dict = {}
try:
  execfile (filename)
except:pass

keys = {}
i = 0
for k in dict.keys():
  i = max(i,len(k))
  d = dict[k]
  for key in d.keys():
    keys[key]=None

keys = keys.keys()
j=0
for k in keys:
  j = max(j,len(k))

print "Function counts for test programs"
print "================================="
print
print ("%-"+str(i+2)+"s") % "File" + "    ",
for t in keys:
  print ("%"+str(j+2)+"s") % t,
print
print "--------"

skeys = dict.keys()
skeys.sort()

for k in skeys:
  d = dict[k]
  x= ("%-"+str(i+2)+"s") % k + "..  "
  discard = 0
  for t in keys:
    v = pkgdict.get(t,-1)
    if v == -1:
      v = ""
    elif (v == 1 or v == 0) and t == "inline" and only_nonopt:
      discard = 1
      break
    else:
      v = str(v)
    v = ("%"+str(j+2)+"s") % v
    x = x+v
  if not discard: print x

@h = tangler('script/mk_expect','python')
@select(h)
import glob
import sys
for k in sys.argv[1:]:
  files = glob.glob(k+'/*.output')
  print '@head(1,"Expected outputs for '+k+'")'
  for i in files:
    j = i[:-7]+'.expect'
    print '@head(2,"'+j+'")'
    print '@select(tangler("'+j+'","data"))'
    f = open(i,"r")
    for l in f: print l,
    f.close()


@h = tangler('spkgs/tutorial.py')
@select(h)
pkg_requires = [
  'flx_tutorial',
  'flx_tut_macro',
  'flx_tut_bind',
  'flx_tut_migrate'
  ]

iscr_source = [
  'lpsrc/flx_tutorial',
  'lpsrc/flx_tut_macro',
  'lpsrc/flx_tut_bind',
  'lpsrc/flx_tut_migrate',
  ]

@select(tangler('spkgs/flx_maker.py'))
iscr_source = ['lpsrc/flx_maker.pak']

weaver_directory = 'doc/flx/flx_maker/'

@select(tangler('umk','python'))
#!/usr/bin/env python
import os
import sys

@tangle('src_dir = %r' % config.src_dir)
os.environ['PYTHONPATH'] = src_dir + os.pathsep + os.environ.get('PYTHONPATH', '')

os.execl(
    sys.executable,
    sys.executable,
    os.path.join(src_dir, 'fbuild_old', 'bin', 'fbuild'),
    *sys.argv[1:])
@make_executable('umk')

@select(tangler('mk','python'))
#!/usr/bin/env python
import os
import sys
import time

@tangle('src_dir = %r' % config.src_dir)

sys.path.append(os.path.join(src_dir, 'fbuild_old', 'lib'))

from fbuild.flxbuild.flxutil import Tee, tee_cmd

def main():
    cmd = [sys.executable, 'umk'] + sys.argv[1:]
    stdout = Tee()
    try:
        return tee_cmd(cmd, stdout)
    finally:
        f = open('mk_' + time.strftime('%Y-%m-%d-%H%M') + '.log', 'w')
        print >> f, stdout.getvalue()

if __name__ == '__main__':
    sys.exit(main())
@make_executable('mk')

@select(tangler('spkgs/__init__.py'))
@doc()

@select(tangler('misc/ldoc.flx'))
include "std";
include "judy";
include "pthread";
include "flx_demux";
include "flx_faio";
include "flx_stream";
include "tre";

include "mmap";

include "glob";
include "flx_gmp";

include "mpi/mpi";

include "SDL/SDL_active";
include "SDL/SDL_audio";
include "SDL/SDL_cdrom";
include "SDL/SDL_endian";
include "SDL/SDL_error";
include "SDL/SDL_events";
include "SDL/SDL";
include "SDL/SDL_framerate";
include "SDL/SDL_gfxPrimitives";
include "SDL/SDL_gfxPrimitives_font";
include "SDL/SDL_imageFilter";
include "SDL/SDL_image";
include "SDL/SDL_joystick";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_mixer";
include "SDL/SDL_mouse";
include "SDL/SDL_mutex";
include "SDL/SDL_net";
include "SDL/SDL_opengl";
include "SDL/SDL_rotozoom";
include "SDL/SDL_rwops";
include "SDL/SDL_sound";
include "SDL/SDL_timer";
include "SDL/SDL_ttf";
include "SDL/SDL_types";
include "SDL/SDL_version";
include "SDL/SDL_video";
@doc()

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('CONFIG_ARGS=')
@tangle('PREFIX=' + config.PREFIX)
@tangle('INSTALL_DIR=${PREFIX}/lib/felix/felix-' + config.flx_version)
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('DOC_DIR=${INSTALL_DIR}')
@tangle('BUILTIN_ISCR=%s -O interscript/bin/iscr.py --nocache' % sys.executable)
@tangle('')
@tangle('all: config/__init__.py script/maker')
@tangle('\t./mk extract ')
@tangle('\t./mk --phase=build')
@tangle('\t./mk --phase=host')
@tangle('\t./mk --phase=target')
@tangle('\t./mk test ')
@tangle('')

@tangle('config: config/init__.py')
@tangle('')
@tangle('config/__init__.py: lpsrc/flx_config.pak')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_config.pak')
@tangle('\tenv PYTHONPATH=. %s -O script/make_config.py --quiet --prefix=${PREFIX} ${CONFIG_ARGS}' % sys.executable)
@tangle('')
@tangle('script/maker: config/__init__.py lpsrc/flx_maker.pak')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_maker.pak')
@tangle('')
@tangle('make: script/maker')
@tangle('')
@tangle('boot: script/maker')
@tangle('')

@tangle('virgin: distclean')
@tangle('')

@tangle('# ============== VARIOUS TARGETS ==============')
@tangle('profile: dummy')
@tangle('\t./mk --pkg=flx_compiler profile')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode')
@tangle('')
@tangle('bytecode.profile: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode profile')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode debug')
@tangle('')
@tangle('extract: dummy')
@tangle('\t./mk extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\t./mk extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\t./mk tutorial')
@tangle('')
@tangle('grammar: dummy')
@tangle('\tenv PYTHONPATH=. %s script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/get_grammar src/cil/flx_cil_cparser.mly >misc/flx_cil_cparser.grammar' % sys.executable)
#@tangle('\tenv PYTHONPATH=. %s script/elk_flx_grgen misc/flx_parse.grammar >misc/elk_flx_gr.gr' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/flx_flx_grgen misc/flx_parse.grammar >lib/flx_grammar.flx' % sys.executable)
#@tangle('\tenv PYTHONPATH=. %s script/elk_flx_lexgen misc/flx_parse.grammar >misc/elk_flx_lex.cc' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/flx_tokgen misc/flx_parse.grammar >lib/flx_token.flx' % sys.executable)
@tangle('')
@tangle('compiler: dummy')
@tangle('\t./mk --pkg=flx_compiler')
@tangle('')
@tangle('flx_tools:')
@tangle('\t./mk tools')
@tangle('')
@tangle('tools: flx_tools grammar')
@tangle('#tools: flx_tools grammar tools/lua_parser')
@tangle('')
@tangle('#tools: grammar bin/flx_doc tools/lua_parser')
@tangle('')
@tangle('tools/lua_parser: tools/lua_parser.flx')
@tangle('\tbin/flx --test --static -c tools/lua_parser')
@tangle('')
@tangle('bin/flx_doc: tools/flx_doc.flx')
@tangle('\tbin/flx --test --static -c tools/flx_doc && mv tools/flx_doc bin/flx_doc')
@tangle('')
@tangle('doc: grammar tools man impldoc rtldoc tutdoc')
@tangle('')
@tangle('#doc: grammar tools libdoc man impldoc tutdoc tutstyle')
@tangle('')
@tangle('impldoc: dummy')
@tangle('\t./mk doc impldoc')
@tangle('')
@tangle('rtldoc: dummy')
@tangle('\t./mk rtldoc')
@tangle('')
@tangle('tutdoc: dummy')
@tangle('\t./mk doc tutdoc')
@tangle('\t#cp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('doc.quiet: grammar tools libdoc')
@tangle('\t./mk quiet doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('libdoc: grammar tools')
@tangle('\tbin/flx_doc --outdir=libdoc \\')
@tangle('\tlib/std.flx lib/stl.flx lib/flx_lex.flx \\')
@tangle('\tlib/flx_token.flx lib/flx_grammar.flx lib/lua.flx lib/lua_parse.flx')
@tangle('\tcp misc/flxdoc_style.css libdoc')
@tangle('')
@tangle('man: dummy')
@tangle('\t./mk man')
@tangle('')
@tangle('test: dummy')
@tangle('\t./mk test ')
@tangle('')
@tangle('test.flx_ptf_static_pointer: dummy')
@tangle('\t./mk test -DFLX_PTF_STATIC_POINTER ')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\t./mk inline test ')
@tangle('')
@tangle('test.inline.static: dummy')
@tangle('\t./mk inline test static ')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\t./mk debug test ')
@tangle('')
@tangle('test.lua_parser: dummy')
@tangle('\tfor i in misc/lua/*.lua; do tools/lua_parser $$i; done;')
@tangle('')
@tangle('tests: dummy')
@tangle('\t./mk test check_output')
@tangle('\tmake tests.bagley')
@tangle('\tmake test.lua_parser')
@tangle('')
@tangle('tests.sdl: dummy')
@tangle('\t./mk sdl')
@tangle('\t./mk static sdl')
@tangle('')
@tangle('tests.verify: dummy')
@tangle('\t./mk test check_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\t./mk test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\t./mk inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\t./mk performance')
@tangle('')
@tangle('performance: tests.performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\t./mk regression')
@tangle('')
@tangle('tests.bagley: dummy')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('speed: dummy')
@tangle('\t./mk speed')
@tangle('')
@tangle('pfcount.all:')
@tangle('\t./mk pfcount_all')
@tangle('')
@tangle('pfcount:')
@tangle('\t./mk pfcount')
@tangle('')
@tangle('rtl.debug: dummy')
@tangle('\t./mk rtl debug')
@tangle('')
@tangle('rtl: dummy')
@tangle('\t./mk rtl')
@tangle('')
@tangle('rtl.optimise: dummy')
@tangle('\t./mk rtl optimise_c')
@tangle('')
@tangle('elkhound: dummy')
@tangle('\t./mk elkhound')
@tangle('')
@tangle('expect.bagley: clean')
@tangle('\t./mk bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tenv PYTHONPATH=. %s script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk' % sys.executable)
@tangle('')
@tangle('expect: clean')
@tangle('\t./mk bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\t./mk test log_output')
@tangle('\tenv PYTHONPATH=. %s script/mk_expect tut/examples > lpsrc/flx_tut_expect.ipk' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/mk_expect test > lpsrc/flx_test_expect.ipk' % sys.executable)
@tangle('\tenv PYTHONPATH=. %s script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk' % sys.executable)
@tangle('')
@tangle('drivers: dummy')
@tangle('\t./mk drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.08.1 or better')
@tangle('\t#REQUIRES g++ 3.xx or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required privileges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')
@tangle('')
@tangle('clean-src:')
@tangle('\trm -rf lpsrc')
@tangle('\trm -rf interscript')
@tangle('\trm -rf raw')
@tangle('\trm -rf gpl')
@tangle('\trm -rf lgpl')
@tangle('\trm -rf sandbox')
@tangle('\trm -rf boot.sh')
@tangle('\trm -rf boot.bat')
@tangle('')
@tangle('debian/rules: lpsrc/flx_debian.pak lpsrc/flx_maker.ipk')
@tangle('\trm -rf debian')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_debian.pak')
@tangle('\tchmod u+x debian/rules')
@tangle('')
@tangle('debian-package: debian/rules')
@tangle('\t(cd .. && make -f flx/Makefile.debian_package_creator package)')
@tangle('')
@tangle('www: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_sourceforge.pak')
@tangle('')
@tangle('distclean:')
@tangle('\trm -rf pkg tut rtl test www src misc man bin doc lib impldoc htmlman tmp tmp.tmp')
@tangle('\trm -rf elk tmp faio demux tmp.out demos judy ocs sex dypgen tre')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('\trm -rf bagley')
@tangle('\trm -rf doc_out libdoc tools doxydoc')
@tangle('\trm -rf meta licences')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf lpsrc-cache')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -rf interscript/*/*.pyo')
@tangle('\trm -rf interscript/*/*/*.pyo')
@tangle('\trm -rf interscript/*.pyc')
@tangle('\trm -rf interscript/*/*.pyc')
@tangle('\trm -rf interscript/*/*/*.pyc')
@tangle('\trm -rf speed')
@tangle('\trm -rf cpkgs')
@tangle('\trm -rf spkgs')
@tangle('\trm -rf pthread')
@tangle('\trm -rf olddebian')
@tangle('\trm -rf script')
@tangle('\trm -rf manifests')
@tangle('\trm -rf pkg-stamps')
@tangle('')
@tangle('backup: dummy')
@tangle('\t(DATE=`date +"%Y-%m-%d-%H%M"`;\\')
@tangle('\tmkdir -p ~/felix-backup/lpbackup/$${DATE};\\')
@tangle('\tcp lpsrc/*.ipk ~/felix-backup/lpbackup/$${DATE};\\')
@tangle('\tcp lpsrc/*.pak ~/felix-backup/lpbackup/$${DATE};\\')
@tangle('\t)')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tfor i in tmp/*.default; do cp $$i config/`basename $$i .default`; done')
@tangle('')
@tangle('wrappers.clean:')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('')
@tangle('config/cxx.flxcc: default_wrappers')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/c89.flxcc')
@tangle('\tbin/flxcc config/c99.flxcc')
@tangle('\tbin/flxcc config/gnu89.flxcc')
@tangle('\tbin/flxcc config/gnu99.flxcc')
@tangle('\tbin/flxcc config/cxx.flxcc')
@tangle('\tbin/flxcc config/cxx_sys.flxcc')
@tangle('\tbin/flxcc config/gnucxx.flxcc')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/bin')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/config')
@tangle('\tinstall -d ${DOC_DIR}/doc')
@tangle('\tinstall -d ${EXEC_DIR}')
@tangle('\tfor file in `ls config/*.py` `ls config/*.fpc` `ls config/*.flxcc`; do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/config; fi; done')
@tangle('\tinstall bin/flx ${EXEC_DIR}')
@tangle('\tfor file in `ls bin/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/bin; fi; done')
@tangle('\tfor file in `ls rtl/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/rtl; fi; done')
@tangle('\tfor file in `ls lib/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/lib; fi; done')
@tangle('\tfor file in `ls doc/*`;      do if [ -f $$file ]; then install $$file ${DOC_DIR}/doc; fi; done')
@tangle('\tfor file in `ls man/man1/*`; do if [ -f $$file ]; then install $$file ${MAN_DIR}/man1; fi; done')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = FLX_MAKER_CVS_ID.replace("$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle('.PHONY: dummy')
@tangle('')
@tangle('#')
@tangle('# ============== TARBALL MAKERS AND UPLOADERS ==============')
@tangle('#')
@tangle('# ------- TARBALL MAKERS --------------')
@tangle('#')
@tangle('')
@tangle('src_tarball: ')
@tangle('\trm -f felix-'+config.flx_version)
@tangle('\tln -s . felix-'+config.flx_version)
@tangle('\ttar --recursion -cvf  flx_'+config.flx_version+'_src.tar\\')
@tangle('\t\tfelix-'+config.flx_version+'/configure \\')
@tangle('\t\tfelix-'+config.flx_version+'/autogen.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/boot.bat \\')
@tangle('\t\tfelix-'+config.flx_version+'/fbuildroot.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+config.flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+config.flx_version+'/src/ \\')
@tangle('\t\tfelix-'+config.flx_version+'/fbuild \\')
@tangle('\t\tfelix-'+config.flx_version+'/test/ \\')
@tangle('\t\tfelix-'+config.flx_version+'/spkgs/ \\')
@tangle('\t\tfelix-'+config.flx_version+'/demos \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+config.flx_version+'/interscript/weavers/*.py ')
@# debian requires gzip -9
@tangle('\tgzip -9 flx_'+config.flx_version+'_src.tar')
@tangle('\tmv -f flx_'+config.flx_version+'_src.tar.gz flx_'+config.flx_version+'_src.tgz')
@tangle('')
@tangle('media_tarball:')
@tangle('\trm -f flx_media.tgz')
@tangle('\ttar -zcvf flx_media.tgz media')
@tangle('')
@tangle('doc_tarball:')
@tangle('\trm -f flx_doc.tgz')
@tangle('\ttar -zcvf flx_doc.tgz doc')
@tangle('')
@tangle('speed_tarball:')
@tangle('\trm -f flx_speed.tgz')
@tangle('\ttar -zcvf flx_speed.tgz speed/*.html speed/*.css speed/machine/*/images/*.jpg speed/machine/*/rankings/*.txt')
@tangle('')
@tangle('#')
@tangle('# ------- TARBALL FILES  --------------')
@tangle('#')
@tangle('flx_media.tgz: media_tarball')
@tangle('')
@tangle('flx_doc.tgz: doc_tarball')
@tangle('')
@tangle('flx_speed.tgz: speed_tarball')
@tangle('')
@tangle('flx_'+config.flx_version+'_src.tgz: src_tarball')
@tangle('')
@tangle('tarballs: flx_'+config.flx_version+'_src.tgz flx_speed.tgz flx_doc.tgz flx_media.tgz')
@tangle('')
@tangle('#')
@tangle('# ------- UPLOADERS --------------')
@tangle('#')
@tangle("#")
@tangle("# ******* WEB SITE MISC")
@tangle("#")
@tangle('upload_images:')
@tangle('\tscp homepage/images/*.jpg ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/images')
@tangle('')
@tangle('upload_homepage: dummy')
@tangle('\tscp homepage/*.html ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('upload_www: upload_homepage')
@tangle('\tscp www/*.html ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('')
@tangle("#")
@tangle("# ******* LP SOURCE TARBALL")
@tangle("#")
@tangle('upload_src: flx_'+config.flx_version+'_src.tgz')
@tangle('\tscp flx_'+config.flx_version+'_src.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle("#")
@tangle("# ******* MEDIA REQUIRED FOR TESTS")
@tangle("#")
@tangle('upload_media: flx_media.tgz')
@tangle('\tscp flx_media.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle("#")
@tangle("# ******* SPEED TEST TARBALL")
@tangle("#")
@tangle('upload_speed: flx_speed.tgz')
@tangle('\tscp -r flx_speed.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle("#")
@tangle("# ******* DOC TARBALL")
@tangle("#")
@tangle('upload_docs: flx_doc.tgz')
@tangle('\tscp -r flx_doc.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('# note: media is not uploaded here because it does not change much ')
@tangle('upload: upload_src upload_speed upload_docs')
@tangle('')
@tangle("#")
@tangle("# --------- UNPACKER -----------------------")
@tangle("#")
@tangle('unpack:')
@tangle('\tssh ${USER}@felix.sf.net "(cd /home/groups/f/fe/felix/htdocs/; tar -zxvf flx_doc.tgz; tar -zxvf flx_speed.tgz)"')
@tangle('')
@tangle('')
@tangle('')
@tangle('')
@tangle('')
@tangle('')

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues CassÃ©

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors. The C parser is derived from
FrontC/CIL which is has BSD licence.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something ..

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something ..


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests,
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver.

Top level files:

@tangle('  VERSION   current version number, should be '+config.flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENCE   licence details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary

  Makefile   the makefile, mainly hooks into script/maker

  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  meta   -- contains various package manager meta-data files
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENCE')
@select(tangler('LICENCE'))
@tangle('Version ' + config.flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file


lpsrc/cil.pak

are covered by a BSD Licence, here is the copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted,
 * provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 3. The name of the authors may not be used to endorse or promote products
 * derived from  this software without specific prior written permission.
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.08.1 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace

@tangle('   tar -zxvf flx_'+config.flx_version+'_src.tgz')
@tangle('   cd felix_'+config.flx_version)

4. Bootstrap the system.

  ./configure

OR type

   make config
   make boot
   make extract

EDIT THE FILES

  config/*.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make

6. Build the documentation and tutorial

   make doc

7. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak

                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  print "It works!"; endl;

and then run it:

  flx -Ilib mytest

@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.
Also some gif images.

@python("//")
def mkgif(fn,d):
  try:
    os.mkdir("misc")
  except:
    pass
  f = open("misc"+os.sep+fn+".gif","w")
  f.write(d)
  f.close()

plus=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\x91\x00\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\x00\x00"+
  "\x00\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x14\x8c\x8f\xa0"+
  "\x0b\xb6\xb2\x9c\x82\xca\x89\x7b"+
  "\x5b\x78\x71\xcf\xce\x74\x08\x52"+
  "\x00\x00\x3b")

minus=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\x91\x00\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\x00\x00"+
  "\x00\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x11\x8c\x8f\xa0"+
  "\x0b\xc6\xeb\x5e\x0b\x40\x58\x3b"+
  "\x65\x96\xf1\xa1\x1f\x14\x00\x3b")

dot=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\xa1\x03\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\xff\xff"+
  "\xff\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x0d\x84\x8f\xa9"+
  "\x20\x2b\x9f\x9e\x8c\x50\xb5\x85"+
  "\x55\x01\x00\x3b")

mkgif("plus",plus)
mkgif("minus",plus)
mkgif("dot",dot)

//

@select(tangler('misc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('misc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)


@head(1,"fishcc")
Script to compile a C program generated by FISh.
@select(tangler("bin/fishcc"))
grab=1
CCFLAGS=""
while (( "$grab" == "1" ));
do
  case x$1 in
  x-*)
    CCFLAGS="$CCFLAGS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done
@tangle('cmd="'+config.TARGET_CXX.options.CCLINK_STATIC+' $1 -O -o `basename $1 .c` `echo "$CCFLAGS"` -lflx_static"')
echo $cmd
`$cmd`

@head(1,'Run script')
@select(tangler('bin/flx.bat','data'))
@@echo off
SETLOCAL
SET RUNIT=1
SET DOFLXG=1
SET DOECHO=0
SET FID=%FLX_INSTALL_DIR%
SET STATIC=0

:DOARGS
IF "-c" EQU "%1" (
SET RUNIT=0
SHIFT
GOTO DOARGS
)

IF "--nofelix" EQU "%1" (
SET DOFLXG=0
SHIFT
GOTO DOARGS
)

IF "--echo" EQU "%1" (
echo on
SET DOECHO=1
SHIFT
GOTO DOARGS
)

IF "--test" EQU "%1" (
SET FID=.
SHIFT
GOTO DOARGS
)

IF "--static" EQU "%1" (
SET STATIC=1
SHIFT
GOTO DOARGS
)

"%FID%\BIN\FLXG" -I"%FID%\LIB" --import:flx.flxh std %1 >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
if %STATIC% EQU 0 (
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:cflags @%1.resh >%1_cflags.txt
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MD /c /EHs /w  /I"%FID%\LIB\RTL" /I"%FID%\config\target" @%1_cflags.txt %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:provides_dlib --field:requires_dlibs @%1.resh >%1_linkflags.txt
if ERRORLEVEL 1 GOTO ERROR
link /dll %1.obj /OUT:%1.dll @%1_linkflags.txt /LIBPATH:"%FID%\BIN" /DEFAULTLIB:libflx_dynamic >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1.exp
del %1.lib
del %1_cflags.txt
del %1_linkflags.txt
IF %RUNIT% EQU 1 (
"%FID%\bin\flx_arun" %1.dll %2 %3 %4 %5 %6 %7 %8 %9
)
) else (
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:cflags @%1.resh >%1_cflags.txt
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MT /c /EHs /w  /I"%FID%\LIB\RTL" /I"%FID%\config\target" /DFLX_STATIC_LINK @%1_cflags.txt %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:provides_slib --field:requires_slibs @%1.resh >%1_linkflags.txt
link "%FID%\rtl\flx_arun_static.obj" %1.obj /OUT:%1.exe @%1_linkflags.txt /LIBPATH:"%FID%\RTL" /DEFAULTLIB:libflx_async_static /DEFAULTLIB:libfaio_static /DEFAULTLIB:libdemux_static /DEFAULTLIB:libflx_pthread_static /DEFAULTLIB:libflx_static >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1_cflags.txt
del %1_linkflags.txt
%1 %2 %3 %4 %5 %6 %7 %8 %9
)
GOTO FINISHED
:ERROR
ECHO SOME KIND OF ERROR OCCURED, rerun with --echo
type %1.LOG
EXIT /B 1
:FINISHED
ENDLOCAL

@select(tangler('bin/flx.py','data'))
#!/usr/bin/env python
# flx.py - felix script harness (python version)
import os
import os.path
import sys
import stat
import string

@tangle("INSTALL_ROOT='%s/lib/felix/felix-%s'" % (config.PREFIX, config.flx_version))
FLX_INSTALL_DIR = os.getenv("FLX_INSTALL_DIR", INSTALL_ROOT)
@tangle("CYGWIN="+str(config.CYGWIN))
@tangle("WIN32="+str(config.WIN32))
@tangle("MACOSX="+str(config.MACOSX))
@tangle("HAVE_GNU="+str(config.HAVE_GNU))
@tangle("HAVE_MSVC="+str(config.HAVE_MSVC))
@if config.TARGET_CXX.options.HAVE_PIC:
  tangle('CCOBJ_DLLIB="'+config.TARGET_CXX.options.CCOBJ_DYNAMIC_FLX+' '+config.TARGET_CXX.options.PIC+'"')
 else:
  tangle('CCOBJ_DLLIB="'+config.TARGET_CXX.options.CCOBJ_DYNAMIC_FLX+'"')
@tangle('CCLINK_DLLIB="'+config.TARGET_CXX.options.CCLINK_DYNAMIC_FLX+'"')
@tangle('CCOBJ_STATIC_LIB="'+config.TARGET_CXX.options.CCOBJ_STATIC_FLX+'"')
@tangle('CCLINK_STATIC="'+config.TARGET_CXX.options.CCLINK_STATIC+'"')
@tangle('VERSION="'+config.flx_version+'"')
@tangle('EXT_LIB="'+config.TARGET_CXX.options.EXT_LIB+'"')
@tangle('EXT_STATIC_OBJ="'+config.TARGET_CXX.options.EXT_STATIC_OBJ+'"')
@tangle('EXT_SHARED_OBJ="'+config.TARGET_CXX.options.EXT_SHARED_OBJ+'"')
@tangle('EXT_EXE="'+config.TARGET_CXX.options.EXT_EXE+'"')
@tangle('EXT_SHLIB="'+config.TARGET_CXX.options.EXT_SHLIB+'"')
@tangle('SPEC_OBJ_FILENAME="'+config.TARGET_CXX.options.SPEC_OBJ_FILENAME+'"')
@tangle('SPEC_EXE_FILENAME="'+config.TARGET_CXX.options.SPEC_EXE_FILENAME+'"')
@tangle('OPTIMISE="'+config.TARGET_CXX.options.OPTIMISE+'"')
@tangle('DEBUG_FLAGS="'+config.TARGET_CXX.options.DEBUG_FLAGS+'"')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=100
ECHO=0
TIME=0
NOOPTIMISE=0
TIMECMD="time -p"

@if config.DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""
FELIX=1
LINKER_SWITCHES=""
MACROS=""
grab=1
cpps=""
cppos=""
INCLUDE_DIRS=""
INCLUDE_FILES=""
NOSTDLIB=0
STDOUT=""
STDIMPORT="--import=flx.flxh"
IMPORTS=""

def splitext(p):
  if p[-5:-1] == ".flx":
    return p[:-5],".flx"
  elif p[-5:-1] == ".cpp":
    return p[:-5],".cpp"
  return p,""

def system(cmd):
  if ECHO==1: print cmd
  result = os.system(cmd)
  if ECHO==1: print "Result code " + str(result)
  return result

argno=1
def prefix(arg,key):
  return arg[:len(key)]==key

compile_exts = ['cpp','cxx']
linkexts = ['o','obj','lib','dll','a','so']

while grab == 1 and argno<len(sys.argv):
  arg = sys.argv[argno]
  #print "ARGNO="+str(argno)+", arg='"+arg+"'"
  path,ext = splitext(arg)
  dir,base = os.path.split(path)
  #print "path="+path+", ext="+ext+",dir="+dir+",base="+base
  #print "cpps="+cpps
  #print "cppos="+cppos
  #print "arg='"+arg+"'"
  if ext != "flx" and ext != "":
    if ext in compile_exts:
      cpps = cpps + " " + arg
      cppos = cppos + " " + path + "." + EXT_OBJ
    else:
     cppos = cppos + " " + arg

  elif arg == "--nostdimport":
    STDIMPORT=""

  elif prefix(arg,"--import="):
   IMPORTS=IMPORTS + " " + arg[9:]

  elif prefix(arg,"--test="):
    TESTMODE=1
    FLX_INSTALL_DIR=arg[7:]

  elif arg=="--test":
    TESTMODE=1
    FLX_INSTALL_DIR="."

  elif prefix(arg,"--stdout="):
    STDOUT=arg[9:]

  elif arg=="--force":
    RECOMPILE=1

  elif arg=="--debug":
    DEBUG=1
    ECHO=1
    NOOPTIMISE=1

  elif arg=="--nostdlib":
    NOSTDLIB=1

  elif arg == "--echo":
    ECHO=1

  elif arg == "--static":
    STATIC=1

  elif prefix(arg,"--inline="):
    INLINE=int(arg[:9])

  elif arg == "--inline":
    INLINE=100

  elif arg == "--noinline":
    INLINE=0

  elif arg == "--version":
    print "version .."
    print VERSION
    sys.exit(0)

  elif arg == "--where":
    print FLX_INSTALL_DIR
    sys.exit(0)

  elif arg == "--time":
    TIME=1

  elif arg == "--help":
    os.system("man -M "+FLX_INSTALL_DIR+os.sep+man"+" flx")
    sys.exit(0)

  elif arg == "-c":
    RUNIT=0

  elif prefix(arg,"-I"):
    INCLUDE_DIRS=INCLUDE_DIRS + " " + arg

  elif arg== "--nofelix":
    FELIX=0

  elif prefix(arg,"-l") or prefix(arg,"-L"):
   LINKER_SWITCHES=LINKER_SWITCHES + " " + arg

  elif prefix(arg,"-D"):
   MACROS=MACROS + " " + arg

  elif prefix(arg,"--pkg="):
    pkgs= pkgs + " " + arg[6:]

  elif prefix(arg,"--"):
    print "Unknown option '"+ arg+"'"
    sys.exit(1)

# the main filename -- subsequent args are args to flx_run
  else:
    grab=0
  argno = argno + 1

#print grab,argno,len(sys.argv)
if grab == 1 and argno == len(sys.argv):
  print "usage: flx [options] filename"
  sys.exit(1)

#print "#--------"
#print "DONE, option index = "+str(argno)
#print "path="+path+", ext="+ext+",dir="+dir+",base="+base
#print "cpps="+cpps
#print "cppos="+cppos

if NOOPTIMISE == 0:
  CCFLAGS=CCFLAGS+" " + OPTIMISE

@if config.HAVE_MSVC:
  tangle('DLINK_STRING="/link /LIBPATH:"+FLX_INSTALL_DIR+"\\\\bin "')
  tangle('SLINK_STRING="/link /LIBPATH:"+FLX_INSTALL_DIR+"\\\\bin "')
 elif config.CYGWIN or config.WIN32:
  tangle('DLINK_STRING="-L"+{FLX_INSTALL_DIR+"/bin "')
  tangle('SLINK_STRING="-L"+FLX_INSTALL_DIR+"/lib/rtl "')
 else:
  tangle('DLINK_STRING="-L"+FLX_INSTALL_DIR+"/lib/rtl "')
  tangle('SLINK_STRING="-L"+FLX_INSTALL_DIR+"/lib/rtl "')


PKGCONFIG=os.path.join(FLX_INSTALL_DIR,"bin","flx_pkgconfig")

if ECHO == 1:
  print "#FLX_INSTALL_DIR="+FLX_INSTALL_DIR
  print "#PKGCONFIG="+PKGCONFIG

CONFIG_DIR = os.path.join(FLX_INSTALL_DIR,'config')

# find external header files
PKGCONFIG_CFLAGS=PKGCONFIG+ " --path+="+FLX_INSTALL_DIR+"/config --field=cflags "

# external header files
PKGCONFIG_INCLUDES=PKGCONFIG+ " --path+="+FLX_INSTALL_DIR+"/config --field=includes "

# find external dynload libraries
PKGCONFIG_DLIBS=PKGCONFIG+" -r --path+="+FLX_INSTALL_DIR+"/config --field=provides_dlib --field=requires_dlibs "

# find external static libraries
PKGCONFIG_SLIBS=PKGCONFIG+" -r --keeprightmost --path+="+FLX_INSTALL_DIR+"/config --field=provides_slib --field=requires_slibs "

#find driver package required
PKGCONFIG_DRIVER=PKGCONFIG+" --path+="+FLX_INSTALL_DIR+"/config --field=flx_requires_driver "

# make a list of any *.cpp files (or other g++ options ..)

if STATIC == 0:
  EXT_OBJ=EXT_SHARED_OBJ
else:
  EXT_OBJ=EXT_STATIC_OBJ

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

# Find absolute pathname

if path == "":
  sys.stderr.write("No such felix program: "+path+"\n")
  sys.exit(1)

def get_stdout(x,outit=None):
  # We're screwed if popen doesn't work ..

  if os.name == "nt": # popen doesn't work on Windows
    result = os.system(x + " >tmp.out")
    fout = open("tmp.out")
    output = fout.readlines()
    if outit:
      for line in output: outit(line)
    fout.close()
  else:
    fout = os.popen(x+" 2>&1 ","r")
    output = []
    try:
      for line in fout:
        output.append(line)
        if outit: outit(line)
    finally:
      result = fout.close()
  return result,output

def xqt(cmd,dflt=None):
  if ECHO == 1: print cmd
  result,output = get_stdout(cmd)
  if result == None:
     output=output[0][:-1] # first line excluding newline
     if ECHO==1:print "output="+output
     return output
  if dflt==None:
    sys.stderr.write("Error "+repr(result)+" executing command " + cmd+"\n")
    sys.exit(result)
  else: return dflt

def calpackages ():
  # find all include directories
  global INCLUDE_DIRS, INCLUDE_FILES, LINK_STRING, DRIVER

  x = xqt(PKGCONFIG_CFLAGS+ " @"+path+".resh")
  INCLUDE_DIRS=INCLUDE_DIRS +" " + x

  x = xqt(PKGCONFIG_INCLUDES+ " @"+path+".resh")
  INCLUDE_FILES=INCLUDE_FILES +" " + x


  # find the driver package
  DRIVER_PKG=xqt(PKGCONFIG_DRIVER+" @"+path+".resh")
  if DRIVER_PKG == "":
    DRIVER_PKG="flx_run"

  # find the driver entity
  if STATIC == 0:
    # dynamic linkage: the driver executable
    DRIVER=FLX_INSTALL_DIR+"/bin/"+DRIVER_PKG+EXT_EXE
  else:
    # static linkage: the driver object file
    DRIVER=FLX_INSTALL_DIR+"/lib/rtl/"+DRIVER_PKG+EXT_STATIC_OBJ

  if STATIC == 0:
    # dynamic linkage: all the libraries required by the application
    LINK_STRING=DLINK_STRING+LINKER_SWITCHES+xqt(
      PKGCONFIG_DLIBS+" @"+path+".resh")
  else:
    # static linkage: all the libraries required by the application and driver
    LINK_STRING=SLINK_STRING+LINKER_SWITCHES+xqt(
      PKGCONFIG_SLIBS+" "+DRIVER_PKG+" @"+path+".resh")

  if ECHO == 1:
    print "#RESOURCE FILE="+path+".resh"
    print "#INCLUDE_DIRS="+INCLUDE_DIRS
    print "#INCLUDE_FILES="+INCLUDE_FILES
    print "#DRIVER="+DRIVER
    print "#LINK_STRING="+LINK_STRING

def write_include_file(path):
  includes = INCLUDE_FILES.strip().split()
  f = open(path+".includes","w")
  for i in includes:
    f.write("#include " + i + "\n")
  f.close()

# grab program arguments
grab=1
args=' '.join(sys.argv[argno:])

INCLUDE_DIR="-I"+FLX_INSTALL_DIR+"/lib/rtl" + " -I"+FLX_INSTALL_DIR+"/config/target"
FLXLIB="-I"+FLX_INSTALL_DIR+"/lib"
STDLIB="std"
if NOSTDLIB == 1:
  FLXLIB=""
  STDLIB=""

FLXG="env PATH="+FLX_INSTALL_DIR+"/bin:$PATH "+FLX_INSTALL_DIR+"/bin/flxg"
# the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
if MACOSX == 1:
  FLXRUN="env DYLD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$DYLD_LIBRARY_PATH "
else:
  FLXRUN="env LD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$LD_LIBRARY_PATH "
ELKHOUND="--elkhound="+FLX_INSTALL_DIR+"/bin/flx_elkhound"

DEBUGSWITCH=""
if DEBUG == 1: DEBUGSWITCH=" --debug"

STATIC_ENV=""
if DEBUG == 1: STATIC_ENV="env FLX_DEBUG=1 "

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except EnvironmentError:
    t = 0
  return t

if RECOMPILE == 0 and RUNIT == 1:
  # not (--force or -c)
  if STATIC == 0:
    if (filetime(path+EXT_SHLIB) > filetime (path+".flx")):
      calpackages()
      cmd=FLXRUN+DRIVER+DEBUGSWITCH+" "+ path+EXT_SHLIB+" "+args
      sys.exit(system(cmd))
  else:
    if (filetime(path+EXT_EXE) > filetime(path+".flx")):
      cmd=STATIC_ENV+" "+path+" "+args
      sys.exit(system(cmd))

# Need Felix and c++ compile, then run it

if DEBUG == 1:
  VERBOSE="-v"
  CCFLAGS=CCFLAGS+DEBUG_FLAGS
else:
  VERBOSE="-q"

FLXFLAGS="--inline="+str(INLINE)

result = 0

if STATIC == 0:
  if FELIX == 1:
    FCMD=' '.join([
      FLXG,
      VERBOSE, FLXFLAGS, ELKHOUND, FLXLIB,
      INCLUDE_DIRS, STDIMPORT, IMPORTS,
      STDLIB, path])
    result=system(FCMD)
    if result != 0: sys.exit(0!=result)
    calpackages()
    write_include_file(path)
    CCMD=' '.join([
      CCOBJ_DLLIB, CCFLAGS, "-DTARGET_BUILD",
      INCLUDE_DIR, INCLUDE_DIRS, MACROS,
      cpps, path+".cpp",
      SPEC_OBJ_FILENAME+path+EXT_OBJ])
    LCMD=' '.join([
      CCLINK_DLLIB, CCFLAGS,
      cppos, path+EXT_OBJ,
      SPEC_EXE_FILENAME+path+EXT_SHLIB,
      LINK_STRING])
    result = system(CCMD)
    if result == 0:
      result = system(LCMD)
      if result == 0:
        if RUNIT == 1:
          if TIME == 1:
            cmd=' '.join([
              TIMECMD,
              FLXRUN+DRIVER+DEBUGSWITCH,
              path+EXT_SHLIB, args])
          else:
            cmd=' '.join([
              FLXRUN+DRIVER+DEBUGSWITCH,
              path+EXT_SHLIB, args])
          if STDOUT != "": cmd=cmd+" > " +STDOUT
          sys.exit(0!=system(cmd))
else:
  if FELIX == 1:
    FCMD=' '.join([
      FLXG, VERBOSE, FLXFLAGS, ELKHOUND,
      FLXLIB, INCLUDE_DIRS, STDIMPORT,
      IMPORTS, STDLIB, path])
    result=system(FCMD)
  if result == 0:
    calpackages()
    write_include_file(path)
    CCMD=' '.join([
      CCOBJ_STATIC_LIB,
      CCFLAGS, "-DTARGET_BUILD",
      "-DFLX_STATIC_LINK", INCLUDE_DIR, INCLUDE_DIRS,
      MACROS, cpps, path+".cpp",
      SPEC_OBJ_FILENAME+path+EXT_OBJ])
    LCMD=' '.join([
      CCLINK_STATIC, SPEC_EXE_FILENAME+path+EXT_EXE,
      path+EXT_OBJ, DRIVER, cppos, LINK_STRING])
    result=system(CCMD)
    if result == 0:
      result=system(LCMD)
      if result == 0:
        # rm -f "$base.cpp"
        if RUNIT == 1:
          if TIME == 1:
            cmd=' '.join([
              TIMECMD, STATIC_ENV, path, args])
          else:
            cmd=' '.join([
              STATIC_ENV, path,args])
          if STDOUT != "": cmd=cmd + " > "+STDOUT
          sys.exit(0!=system(cmd))
sys.exit(0!=result)

@select(tangler('bin/flx','data'))
#!/usr/bin/env bash
# flx - felix script harness
@tangle("INSTALL_ROOT="+config.PREFIX+"/lib/felix/felix-"+config.flx_version)
@tangle("FLX_INSTALL_DIR=${FLX_INSTALL_DIR:-$INSTALL_ROOT}")
@tangle("CYGWIN="+str(config.CYGWIN and 1 or 0))
@tangle("WIN32="+str(config.WIN32 and 1 or 0))
@tangle("MACOSX="+str(config.MACOSX and 1 or 0))
@tangle("HAVE_GNU="+str(config.HAVE_GNU and 1 or 0))
@tangle("HAVE_MSVC="+str(config.HAVE_MSVC and 1 or 0))
@if config.TARGET_CXX.options.HAVE_PIC:
  tangle('CCOBJ_DLLIB="'+config.TARGET_CXX.options.CCOBJ_DYNAMIC_FLX+' '+config.TARGET_CXX.options.PIC+'"')
 else:
  tangle('CCOBJ_DLLIB="'+config.TARGET_CXX.options.CCOBJ_DYNAMIC_FLX+'"')
@tangle('CCLINK_DLLIB="'+config.TARGET_CXX.options.CCLINK_DYNAMIC_FLX+'"')
@tangle('CCOBJ_STATIC_LIB="'+config.TARGET_CXX.options.CCOBJ_STATIC_FLX+'"')
@tangle('CCLINK_STATIC="'+config.TARGET_CXX.options.CCLINK_STATIC+'"')
@tangle('VERSION="'+config.flx_version+'"')
@tangle('EXT_LIB="'+config.TARGET_CXX.options.EXT_LIB+'"')
@tangle('EXT_STATIC_OBJ="'+config.TARGET_CXX.options.EXT_STATIC_OBJ+'"')
@tangle('EXT_SHARED_OBJ="'+config.TARGET_CXX.options.EXT_SHARED_OBJ+'"')
@tangle('EXT_EXE="'+config.TARGET_CXX.options.EXT_EXE+'"')
@tangle('EXT_SHLIB="'+config.TARGET_CXX.options.EXT_SHLIB+'"')
@tangle('SPEC_OBJ_FILENAME="'+config.TARGET_CXX.options.SPEC_OBJ_FILENAME+'"')
@tangle('SPEC_EXE_FILENAME="'+config.TARGET_CXX.options.SPEC_EXE_FILENAME+'"')
@tangle('OPTIMISE="'+config.TARGET_CXX.options.OPTIMISE+'"')
@tangle('DEBUG_FLAGS="'+config.TARGET_CXX.options.DEBUG_FLAGS+'"')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=100
ECHO=0
TIME=0
NOOPTIMISE=0

@if config.DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""
INCLUDE_FILES=""
FELIX=1
LINKER_SWITCHES=""
MACROS=""
grab=1
cpps=""
cppos=""
INCLUDE_DIRS=""
NOSTDLIB=0
STDOUT=""
STDIMPORT="--import=flx.flxh"
IMPORTS=""
OUTPUT_DIR=""

while (( "$grab" == "1" ));
do
  case x$1 in

  x--nostdimport)
    STDIMPORT=""
    shift
  ;;

  x--import=*)
   IMPORTS="$IMPORTS --import=${1:9}"
   shift
 ;;

  x--test=*)
    TESTMODE=1
    FLX_INSTALL_DIR=${1:7}
    shift
  ;;

  x--test)
    TESTMODE=1
    FLX_INSTALL_DIR=.
    shift
  ;;

  x--stdout=*)
    STDOUT=${1:9}
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    ECHO=1
    NOOPTIMISE=1
    shift
  ;;

  x--time)
    TIME=1
    shift
  ;;

  x--nostdlib)
    NOSTDLIB=1
    shift
  ;;

  x--echo)
    ECHO=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline=*)
    INLINE=${1:9}
    shift
  ;;

  x--inline)
    INLINE=100
    shift
  ;;

  x--noinline)
    INLINE=0
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--output_dir=*)
    OUTPUT_DIR=$1
    shift
  ;;

  x--help)
    man -M $FLX_INSTALL_DIR/man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x--nofelix)
    FELIX=0
    shift
  ;;

  x-[lL]*)
   LINKER_SWITCHES="$LINKER_SWITCHES $1"
   shift
  ;;

  x-D*)
   MACROS="$MACROS $1"
   shift
  ;;

  x*.cpp)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .cpp`$EXT_OBJ"
    shift
  ;;

  x*.cxx)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .cxx`$EXT_OBJ"
    shift
  ;;

  x*.c)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .c`$EXT_OBJ"
    shift
  ;;

  x*.o)
    cppos="$cppos `dirname $1`/`basename $1 .o`$EXT_OBJ"
    shift
  ;;

  x*.obj)
    cppos="$cppos `dirname $1`/`basename $1 .obj`$EXT_OBJ"
    shift
  ;;

  x*.a)
    cppos="$cppos $1"
    shift
  ;;

  x*.lib)
    cppos="$cppos $1"
    shift
  ;;

  x--pkg=*)
    pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
    shift
  ;;

# unknown flag .. pass to both compile and link
   x-*)
      cpps="$cpps $1"
      cppos="$cppos $1"
      shift
    ;;

# the main filename -- subsequent args are args to flx_run
  x*)
    grab=0
  ;;

  esac
done

if [ "$NOOPTIMISE" = "0" ]
then
  CCFLAGS=$CCFLAGS$OPTIMISE
fi

@if config.HAVE_MSVC:
  tangle('DLINK_STRING="/link /LIBPATH:${FLX_INSTALL_DIR}\\\\bin "')
  tangle('SLINK_STRING="/link /LIBPATH:${FLX_INSTALL_DIR}\\\\bin "')
 elif config.CYGWIN or config.WIN32:
  tangle('DLINK_STRING="-L${FLX_INSTALL_DIR}/bin "')
  tangle('SLINK_STRING="-L${FLX_INSTALL_DIR}/lib/rtl "')
 else:
  tangle('DLINK_STRING="-L${FLX_INSTALL_DIR}/lib/rtl "')
  tangle('SLINK_STRING="-L${FLX_INSTALL_DIR}/lib/rtl "')


PKGCONFIG="env FLX_DEBUG=0 FLX_ALLOW_COLLECTION_ANYWHERE=0 $FLX_INSTALL_DIR/bin/flx_pkgconfig"

if [ "$ECHO" = "1" ]
then
  echo "#FLX_INSTALL_DIR=$FLX_INSTALL_DIR"
  echo "#PKGCONFIG=$PKGCONFIG"
fi


# find external header files
PKGCONFIG_CFLAGS="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=cflags "

# external header files
PKGCONFIG_INCLUDES="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=includes "

# find external dynload libraries
PKGCONFIG_DLIBS="$PKGCONFIG -r --path+=$FLX_INSTALL_DIR/config --field=provides_dlib --field=requires_dlibs "

# find external static libraries
PKGCONFIG_SLIBS="$PKGCONFIG -r --keeprightmost --path+=$FLX_INSTALL_DIR/config --field=provides_slib --field=requires_slibs "

#find driver package required
PKGCONFIG_DRIVER="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=flx_requires_driver "

# make a list of any *.cpp files (or other g++ options ..)

if [ $STATIC = 0 ]
then
  EXT_OBJ=$EXT_SHARED_OBJ
else
  EXT_OBJ=$EXT_STATIC_OBJ
fi

if [ "x$1" = "x" ]
then
  echo "usage: flx [options] filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;

  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=$arg

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

function calpackages () {
  # find all include directories
  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_CFLAGS @$base.resh"
  fi

  INCLUDE_DIRS="$INCLUDE_DIRS $($(echo $PKGCONFIG_CFLAGS @$base.resh))"

  # find all include files
  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_INCLUDES @$base.resh"
  fi

  INCLUDE_FILES="$INCLUDE_FILES $($(echo $PKGCONFIG_INCLUDES @$base.resh))"


  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_DRIVER @$base.resh"
  fi

  # find the driver package
  DRIVER_PKG=$($(echo $PKGCONFIG_DRIVER @$base.resh))
  if [ x$DRIVER_PKG = x ]
  then
    # default to flx_run if none specified
    DRIVER_PKG=flx_run
  fi

  # find the driver entity
  if [ $STATIC = 0 ]
  then
    # dynamic linkage: the driver executable
    DRIVER=$FLX_INSTALL_DIR/bin/$DRIVER_PKG$EXT_EXE
  else
    # static linkage: the driver object file
    DRIVER=$FLX_INSTALL_DIR/lib/rtl/$DRIVER_PKG$EXT_STATIC_OBJ
  fi

  if [ $STATIC = 0 ]
  then
    if [ "$ECHO" = "1" ]
    then
     echo "$PKGCONFIG_DLIBS @$base.resh"
    fi

    # dynamic linkage: all the libraries required by the application
    LINK_STRING="$DLINK_STRING$LINKER_SWITCHES $($(echo $PKGCONFIG_DLIBS @$base.resh))"
  else
    if [ "$ECHO" = "1" ]
    then
     echo "$PKGCONFIG_SLIBS $DRIVER_PKG @$base.resh"
    fi

    # static linkage: all the libraries required by the application and driver
    LINK_STRING="$SLINK_STRING$LINKER_SWITCHES $($(echo $PKGCONFIG_SLIBS $DRIVER_PKG @$base.resh))"
  fi

  if [ $ECHO = 1 ]
  then
    echo "#RESOURCE FILE=$base.resh"
    echo "#INCLUDE_DIRS=$INCLUDE_DIRS"
    echo "#INCLUDE_FILES=$INCLUDE_FILES"
    echo "#DRIVER=$DRIVER"
    echo "#LINK_STRING=$LINK_STRING"
  fi

}

function write_include_file() {
  (for filename in ${INCLUDE_FILES:1}; do echo "#include $filename"; done) > $1.includes
}

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

INCLUDE_DIR="-I$FLX_INSTALL_DIR/lib/rtl -I$FLX_INSTALL_DIR/config/target"
FLXLIB="-I$FLX_INSTALL_DIR/lib"
STDLIB="std"
if [ "$NOSTDLIB" = "1" ]
then
  FLXLIB=""
  STDLIB=""
fi

if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
then
  # bash is a heap of crap! The escaped quotes here are
  # required in case the PATH has a filename with spaces
  # However this actually fails on Linux!
  FLXG="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" $FLX_INSTALL_DIR/bin/flxg"
  FLXRUN="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" "
else
  FLXG="env PATH=$FLX_INSTALL_DIR/bin:\$PATH $FLX_INSTALL_DIR/bin/flxg"
  # the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
  if [ "$MACOSX" = "1" ]
  then
    FLXRUN="env DYLD_LIBRARY_PATH=$FLX_INSTALL_DIR/lib/rtl:\$DYLD_LIBRARY_PATH "
  else
    FLXRUN="env LD_LIBRARY_PATH=$FLX_INSTALL_DIR/lib/rtl:\$LD_LIBRARY_PATH "
  fi
fi
ELKHOUND="--elkhound=$FLX_INSTALL_DIR/bin/flx_elkhound"

DEBUGSWITCH=""
if [ "$DEBUG" = "1" ]; then DEBUGSWITCH=" --debug"; fi
STATIC_ENV=""
if [ "$DEBUG" = "1" ]; then STATIC_ENV="env FLX_DEBUG=1 "; fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base$EXT_SHLIB" -a "(" ! -r "$base.flx" -o "$base$EXT_SHLIB" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      calpackages
      write_include_file $base
      cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
      exit $?
    fi
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base$EXT_EXE" -a "(" ! -r "$base.flx" -o "$base$EXT_EXE" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      cmd="$STATIC_ENV $base $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
      exit $?
    fi
  fi
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]
then
  VERBOSE="-v"
  CCFLAGS="$CCFLAGS$DEBUG_FLAGS"
else
  VERBOSE="-q"
fi

FLXFLAGS="--inline=$INLIN $OUTPUT_DIR"

if [ $STATIC = 0 ]
then
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND $FLXLIB $INCLUDE_DIRS $STDIMPORT $IMPORTS $STDLIB $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD || exit $?
  fi
  calpackages
  write_include_file $base
  CCMD="$CCOBJ_DLLIB $CCFLAGS -DTARGET_BUILD $INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
  LCMD="$CCLINK_DLLIB $CCFLAGS $cppos $base$EXT_OBJ $SPEC_EXE_FILENAME$base$EXT_SHLIB $LINK_STRING "
  if [ $ECHO = 1 ]; then echo "$CCMD"; fi
  eval $CCMD || exit $?
	if [ $ECHO = 1 ]; then echo "$LCMD"; fi
	eval $LCMD || exit $?
	if [ $RUNIT = 1 ]
	then
		if [ $TIME = 1 ]
		then
			cmd="time $FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
		else
			cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
		fi
		if [ "$STDOUT" != "" ]; then cmd="$cmd > $STDOUT"; fi
		if [ $ECHO = 1 ]; then echo $cmd; fi
		eval $cmd || exit $?
	fi
else
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND $FLXLIB $INCLUDE_DIRS $STDIMPORT $IMPORTS $STDLIB $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD || exit $?
    if [ $? != 0 ]; then exit $?; fi
  fi
  calpackages
  write_include_file $base
  CCMD="$CCOBJ_STATIC_LIB $CCFLAGS -DTARGET_BUILD -DFLX_STATIC_LINK $INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
  LCMD="$CCLINK_STATIC $SPEC_EXE_FILENAME$base$EXT_EXE $base$EXT_OBJ ${DRIVER} $cppos $LINK_STRING"
  if [ $ECHO = 1 ]; then echo "$CCMD"; fi
  eval $CCMD || exit $?
  if [ $ECHO = 1 ]; then echo "$LCMD"; fi
  eval $LCMD || exit $?
  # rm -f "$base.cpp"
  if [ $RUNIT = 1 ]
  then
    if [ $TIME = 1 ]
    then
      cmd="time $STATIC_ENV $base $args"
    else
      cmd="$STATIC_ENV $base $args"
    fi
    if [ "$STDOUT" != "" ]; then cmd="$cmd > $STDOUT"; fi
    if [ $ECHO = 1 ]; then echo $cmd; fi
    eval $cmd || exit $?
  fi
fi

@select(tangler('bin/flx-postinstall-check','data'))
#!/usr/bin/env bash
FLX=flx
if [ "x$1" != x ]; then FLX="$1 $2 $3 $4 $5 $6 $7 $8"; fi

echo "Felix command is $FLX"
ok=0
bad=0
total=0
failed[0]=""

for i in test/*/*.flx tut/*/*.flx
do
  expect=`dirname $i`/`basename $i .flx`.expect
  if test -e $expect
  then
    total=$(($total+1))
    echo "$total -- check dynamic $i"
    rm -rf tmp.out
    $FLX --force --stdout=tmp.out $i
    diff -a -b -y --suppress-common-lines $expect tmp.out
    if [ "$?" != "0" ]
    then
      echo "*********ERROR"
      failed[$bad]="$total dynamic $i"
      bad=$(($bad+1))
    else
      ok=$(($ok+1))
    fi
    total=$(($total+1))
    echo "$total -- check static $i"
    rm -rf tmp.out
    $FLX --force --static --stdout=tmp.out $i
    diff -a -b -y --suppress-common-lines $expect tmp.out
    if [ "$?" != "0" ]
    then
      echo "*********ERROR"
      failed[$bad]="$total static $i"
      bad=$(($bad+1))
    else
      ok=$(($ok+1))
    fi
  fi
done

if [ $bad != 0 ]
then
  echo "============="
  echo "$bad FAILURES"
  echo "============="
  for ((i=0; i<$bad; i=$i+1)); do echo ${failed[$i]}; done
  echo $failed
  echo
fi
echo
echo "============"
echo "TEST SUMMARY"
echo "============"
echo "GOOD $ok"
echo "BAD  $bad"
echo "---------"
echo "TOTAL $total"
echo "---------"

exit $bad

@head(1,'Package Manager Meta Info')
@head(2,'GODI')
This is the Godiva file originally used to
create the GODI data. At the moment this is
the authoritative meta data. However,
godiva may not handle all the options
we need -- so the generated makefile
is included as well.

@select(tangler('meta/godiva/flx.godiva','data'))
Package: apps-felix
@tangle('Version: '+config.flx_version)
Revision: 0
Depends:
Build-Depends: godi-ocaml (> 3.08)
@tangle('Sources: http://felix.sf.net/flx_'+config.flx_version+'_src.tgz')
@tangle('Unpacks-To: flx_'+config.flx_version)
Bytecode-Target: all
Opt-Target: all
Homepage: http://felix.sf.net
Maintainer: John Skaller <skaller@users.sf.net>
Options: configure
Description: Felix Compiler
Felix Compiler
.

@select(tangler('meta/godiva/flx.godiva_camlsyntax','data'))
name = "felix";
@tangle('version = "'+config.flx_version+'";')
revision = 0;
category = `apps;
depends = [];
build_depends = [`godi,"ocaml", Some (`gt, "3.08")];
sources_site ="http://felix.sf.net/";
@tangle('sources_basename= "flx_'+config.flx_version+'_src";')
sources_extension = ".tgz";
@tangle('sources_unpacksto = "flx_'+config.flx_version+'";')
all_target= "all";
opt_target= "all";
homepage= "http://felix.sf.net";
maintainer = "John Skaller <skaller@users.sf.net>";
options= [`configure];
short_desc = "Felix Compiler";
long_desc = "Felix Compiler";
confopts = [
  {
    name = "SUPPORT_DYNAMIC_LOADING";
    default = "1";
    description = "Whether to support dlopen loading";
    implementation = `configarg "--SUPPORT_DYNAMIC_LOADING"
  }
];
specfile = "meta/godiva/flx.godiva_camlsyntax";
patches = [];
filesdir = None;

@select(tangler('meta/godi/DESCR','data'))
Felix Compiler and tools.

@doc()
This makefile only here for reference (don't use it,
it should be generated).

@select(tangler('meta/godi/Makefile','data'))
# This file was automatically generated by GODIVA
.include "../../mk/bsd.prefs.mk"
.include "../../mk/godi.pkg.mk"

@tangle('VERSION=        '+config.flx_version)
PKGNAME=        apps-felix-${VERSION}
@tangle('PKGREVISION=    '+config.godi_revision)
@tangle('DISTNAME=       flx_'+config.flx_version)
@tangle('DISTFILES=      flx_'+config.flx_version+'_src.tgz')
CATEGORIES=     apps
MASTER_SITES=   http://felix.sf.net/
MAINTAINER=     John Skaller <skaller@users.sf.net>
HOMEPAGE=       http://felix.sf.net
COMMENT=        Felix Compiler

# confopt defaults:


AUTOGENERATE_PLIST = yes
PKG  =          apps-felix
MAKE_FLAGS=     PREFIX=${PREFIX}



PATH:=          ${LOCALBASE}/bin:"${PATH}"
HAS_CONFIGURE = yes
CONFIGURE_ARGS+= --prefix ${PREFIX}
CONFIGURE_ENV+= ${BUILD_OCAMLFIND_ENV}
USE_GMAKE = yes

MAKE_ENV+=  ${BUILD_OCAMLFIND_ENV} PKGBASE=${PKGBASE:Q}

pre-configure-copy:
.	if exists(files)
	    cd files && ${PAX} -rw -pp . ${WRKSRC}
.	endif

pre-configure: pre-configure-copy

pre-install-mkdirs:
.	for d in bin lib/ocaml/pkg-lib doc share man etc info sbin include
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/${d}
.	endfor
.	for n in 1 2 3 4 5 6 7 8 9
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/man/man${n}
.	endfor

pre-install: pre-install-mkdirs

ALL_TARGET=     all
.if ${GODI_HAVE_OCAMLOPT} == "yes"
# ALL_TARGET+= all
.endif

post-install:
	mkdir -p ${PREFIX}/doc/${PKG}
.	for DOC in
	    install -m 0644 ${WRKSRC}/${DOC} ${PREFIX}/doc/${PKG}
.	endfor

.include "../../mk/bsd.pkg.mk"

@head(1,'Finish up')
Just cleaning up script now.
@make_executable(os.path.join('bin', 'flx'))
@make_executable(os.path.join('bin', 'flx.py'))
@make_executable(os.path.join('bin', 'fishcc'))


